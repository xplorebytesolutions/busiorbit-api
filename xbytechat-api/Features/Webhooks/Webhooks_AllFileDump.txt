Folder and File Content Report
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\ExtrackAllFiles.bat 
====================================================== 
 
@echo off
REM This script will find all files and output their name and content into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh
> "%outputFile%" (echo Folder and File Content Report)
echo. >> "%outputFile%"

REM Loop through all files in the current directory and subdirectories
for /R . %%F in (*.*) do (
    echo ====================================================== >> "%outputFile%"
    echo FILE: %%F >> "%outputFile%"
    echo ====================================================== >> "%outputFile%"
    echo. >> "%outputFile%"
    type "%%F" >> "%outputFile%" 2>nul
    echo. >> "%outputFile%"
    echo. >> "%outputFile%"
)

echo Finished! All content has been extracted to %outputFile% 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Webhooks_AllFileDump.txt 
====================================================== 
 
Folder and File Content Report
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\ExtrackAllFiles.bat 
====================================================== 
 
@echo off
REM This script will find all files and output their name and content into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh
> "%outputFile%" (echo Folder and File Content Report)
echo. >> "%outputFile%"

REM Loop through all files in the current directory and subdirectories
for /R . %%F in (*.*) do (
    echo ====================================================== >> "%outputFile%"
    echo FILE: %%F >> "%outputFile%"
    echo ====================================================== >> "%outputFile%"
    echo. >> "%outputFile%"
    type "%%F" >> "%outputFile%" 2>nul
    echo. >> "%outputFile%"
    echo. >> "%outputFile%"
)

echo Finished! All content has been extracted to %outputFile% 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Webhooks_AllFileDump.txt 
====================================================== 
 
Folder and File Content Report
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\BackgroundWorkers\WebhookAutoCleanupWorker.cs 
====================================================== 
 
Ôªøusing xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.BackgroundWorkers
{
    public class WebhookAutoCleanupWorker : BackgroundService
    {
        private readonly ILogger<WebhookAutoCleanupWorker> _logger;
        private readonly IServiceProvider _services;

        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)
        {
            _services = services;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                using var scope = _services.CreateScope();
                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();

                if (await maintenanceService.IsAutoCleanupEnabledAsync())
                {
                    var count = await maintenanceService.RunCleanupAsync();
                    _logger.LogInformation($"üßπ Auto-cleaned {count} old webhook logs.");
                }

                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\BackgroundWorkers\WebhookQueueWorker.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.Services;
using xbytechat.api.Features.Webhooks.DTOs;

public class WebhookQueueWorker : BackgroundService
{
    private readonly IWebhookQueueService _queueService;
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<WebhookQueueWorker> _logger;

    public WebhookQueueWorker(
        IWebhookQueueService queueService,
        IServiceScopeFactory scopeFactory,
        ILogger<WebhookQueueWorker> logger)
    {
        _queueService = queueService;
        _scopeFactory = scopeFactory;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("üöÄ Webhook Queue Worker started.");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                var payload = await _queueService.DequeueAsync(stoppingToken);
                var clonedPayload = payload.Clone(); // ‚úÖ Avoid disposal issue

                using var scope = _scopeFactory.CreateScope();

                // üîÑ Resolve scoped dependencies
                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();
                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();

                // üöÄ Dispatch
                await dispatcher.DispatchAsync(clonedPayload);
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("üõë Graceful shutdown requested.");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error while processing webhook payload.");

                try
                {
                    using var scope = _scopeFactory.CreateScope();
                    var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();

                    var fallback = new FailedWebhookLogDto
                    {
                        SourceModule = "WebhookQueueWorker",
                        FailureType = "DispatchError",
                        ErrorMessage = ex.Message,
                       // RawJson = ex.Data["payload"]?.ToString() ?? "(unavailable)",
                        RawJson = ex.Data["payload"]?.ToString() ?? "{}",
                        CreatedAt = DateTime.UtcNow
                    };

                    await failureLogger.LogFailureAsync(fallback);
                }
                catch (Exception innerEx)
                {
                    _logger.LogError(innerEx, "‚ö†Ô∏è Failed to log to FailedWebhookLogs table.");
                }
            }
        }

        _logger.LogInformation("üõë Webhook Queue Worker stopped.");
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\FailedWebhookLogsController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using xbytechat.api.Features.Tracking.Services;
using xbytechat.api.Features.Tracking.Models;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Tracking.Controllers
{
    [ApiController]
    [Route("api/failed-webhooks")]
    public class FailedWebhookLogsController : ControllerBase
    {
        private readonly IFailedWebhookLogService _service;

        public FailedWebhookLogsController(IFailedWebhookLogService service)
        {
            _service = service;
        }

        [HttpGet]
        public async Task<IActionResult> GetAllAsync()
        {
            var logs = await _service.GetAllAsync();
            return Ok(logs);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetById(Guid id)
        {
            var log = await _service.GetByIdAsync(id);
            if (log == null)
                return NotFound();

            return Ok(log);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\MaintenanceController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Models;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks")]
    public class MaintenanceController : ControllerBase
    {
        private readonly AppDbContext _context;
        private readonly IMaintenanceService _maintenance;

        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)
        {
            _context = context;
            _maintenance = maintenance;
        }

        // ‚úÖ Injected Test Log for Dev Testing
        [HttpPost("inject-test-log")]
        public async Task<IActionResult> InjectTestLog()
        {
            var testLog = new FailedWebhookLog
            {
                SourceModule = "WebhookQueueWorker",
                FailureType = "DispatchError",
                ErrorMessage = "üß™ Simulated webhook dispatch failure for testing.",
                RawJson = "{\"sample\":\"test_payload\",\"reason\":\"unit_test\"}",
                CreatedAt = DateTime.UtcNow
            };

            _context.FailedWebhookLogs.Add(testLog);
            await _context.SaveChangesAsync();

            return Ok(new { message = "‚úÖ Injected test log successfully." });
        }

        // ‚úÖ Manual Cleanup Trigger
        [HttpPost("cleanup-now")]
        public async Task<IActionResult> CleanupNow()
        {
            var cutoff = DateTime.UtcNow.AddDays(-7);
            var oldLogs = await _context.FailedWebhookLogs
                .Where(x => x.CreatedAt < cutoff)
                .ToListAsync();

            if (!oldLogs.Any())
                return Ok(new { message = "‚úÖ No logs to delete." });

            _context.FailedWebhookLogs.RemoveRange(oldLogs);
            await _context.SaveChangesAsync();

            return Ok(new { message = $"‚úÖ Deleted {oldLogs.Count} old logs." });
        }

        // ‚úÖ Count of all failed logs
        [HttpGet("failed/count")]
        public async Task<IActionResult> GetFailedCount()
        {
            var count = await _context.FailedWebhookLogs.CountAsync();
            return Ok(count);
        }

        // ‚úÖ Cleanup Setting Status
             [HttpGet("settings")]
        public async Task<IActionResult> GetCleanupStatus()
        {
            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();
            var lastRun = await _maintenance.GetLastCleanupTimeAsync();

            return Ok(new
            {
                enabled,
                lastCleanupAt = lastRun
            });
        }

        // ‚úÖ Enable Auto Cleanup
        [HttpPost("enable-cleanup")]
        public async Task<IActionResult> EnableCleanup()
        {
            await _maintenance.EnableAutoCleanupAsync();
            return Ok(new { message = "‚úÖ Auto-cleanup enabled." });
        }

        // ‚úÖ Disable Auto Cleanup
        [HttpPost("disable-cleanup")]
        public async Task<IActionResult> DisableCleanup()
        {
            await _maintenance.DisableAutoCleanupAsync();
            return Ok(new { message = "‚úÖ Auto-cleanup disabled." });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WebhookCallback.cs 
====================================================== 
 
Ôªø// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Text.Json;
using System.Threading;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhookcallback")]
    public class WebhookCallbackController : ControllerBase
    {
        private readonly ILogger<WebhookCallbackController> _logger;
        private readonly IWebhookQueueService _queue;

        public WebhookCallbackController(
            ILogger<WebhookCallbackController> logger,
            IWebhookQueueService queue)
        {
            _logger = logger;
            _queue = queue;
        }

        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here
        [HttpPost]
        [Consumes("application/json")]
        [Produces("application/json")]
        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)
        {
            if (!Request.HasJsonContentType())
            {
                return BadRequest(new { error = "Content-Type must be application/json" });
            }

            try
            {
                var raw = payload.GetRawText();
                _logger.LogInformation("üì• Webhook received. bytes={Len}", raw.Length);

                // Clone JsonElement before queueing
                _queue.Enqueue(payload.Clone());

                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily
                return Ok(new { received = true });
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("‚ö†Ô∏è Webhook processing cancelled by client.");
                return StatusCode(499);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to enqueue webhook payload.");
                // 500 lets BSP retry later
                return StatusCode(500, new { error = "webhook_enqueue_failed" });
            }
        }
    }

    // Small helper for JSON content-type
    internal static class HttpRequestContentTypeExtensions
    {
        public static bool HasJsonContentType(this HttpRequest request)
        {
            if (request?.ContentType is null) return false;
            return request.ContentType.StartsWith("application/json", StringComparison.OrdinalIgnoreCase);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WebhookTestController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks/test")]
    public class WebhookTestController : ControllerBase
    {
        private readonly IWebhookQueueService _queue;

        public WebhookTestController(IWebhookQueueService queue)
        {
            _queue = queue;
        }

        [HttpPost("simulate-failure")]
        public IActionResult SimulateWebhookFailure()
        {
            var fakePayload = new
            {
                entry = new[]
                {
                    new
                    {
                        changes = new[]
                        {
                            new
                            {
                                value = new
                                {
                                    // This will cause dispatcher to throw due to invalid structure
                                    unexpected = "üß™ Simulated bad structure"
                                }
                            }
                        }
                    }
                }
            };

            var json = JsonSerializer.Serialize(fakePayload);
            var element = JsonDocument.Parse(json).RootElement;

            _queue.Enqueue(element);

            return Ok(new
            {
                message = "‚úÖ Test payload enqueued to simulate failure.",
                enqueued = true
            });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Controllers\WhatsAppWebhookController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using xbytechat.api.Features.Tracking.DTOs;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Controllers
{
    [ApiController]
    [Route("api/webhooks/whatsapp")]
    public class WhatsAppWebhookController : ControllerBase
    {
        private readonly ILogger<WhatsAppWebhookController> _logger;
        private readonly IConfiguration _config;
        private readonly AppDbContext _context;
        private readonly IWhatsAppWebhookService _webhookService;
        private readonly IWebhookQueueService _queue;
            public WhatsAppWebhookController(ILogger<WhatsAppWebhookController> logger,
            IConfiguration config, AppDbContext context, IWhatsAppWebhookService webhookService, IWebhookQueueService queue)
        {
            _logger = logger;
            _config = config;
            _context = context;
            _webhookService = webhookService;
            _queue = queue;
        }

        // ‚úÖ Step 1: Meta verification endpoint (GET)
        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge
        [HttpGet]
        public IActionResult VerifyWebhook(
            [FromQuery(Name = "hub.mode")] string mode,
            [FromQuery(Name = "hub.verify_token")] string token,
            [FromQuery(Name = "hub.challenge")] string challenge)
        {
            // üîê Load your secret token from config or environment
            var expectedToken = _config["WhatsApp:MetaToken"];

            if (mode == "subscribe" && token == expectedToken)
            {
                _logger.LogInformation("‚úÖ WhatsApp webhook verified successfully.");
                return Ok(challenge); // Meta expects a 200 OK with the challenge value
            }

            _logger.LogWarning("‚ùå WhatsApp webhook verification failed.");
            return Forbid("Token mismatch.");
        }

     
        [HttpPost]
        public IActionResult HandleStatus([FromBody] JsonElement payload)
        {
            _logger.LogWarning("üì• Webhook received at controller:\n" + payload.ToString());

            try
            {
                var cloned = payload.Clone(); // Important to clone here
                _queue.Enqueue(cloned);

                _logger.LogInformation("üì• Webhook payload enqueued successfully.");
                return Ok(new { received = true });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to enqueue WhatsApp webhook payload.");
                return StatusCode(500, new { error = "Webhook queue failed" });
            }
        }


    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Directory\IProviderDirectory.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Directory
{
    /// <summary>
    /// Resolves BusinessId from provider-specific webhook identifiers.
    /// </summary>
    public interface IProviderDirectory
    {
        /// <param name="provider">"meta" or "pinnacle" (lowercase preferred)</param>
        /// <param name="phoneNumberId">Meta/Pinnacle phone_number_id (strongest key)</param>
        /// <param name="displayPhoneNumber">Formatted sending number (e.g. "+91XXXXXXXXXX")</param>
        /// <param name="wabaId">WhatsApp Business Account ID (Meta)</param>
        /// <param name="waId">Optional WA ID (recipient); used only as a last-ditch heuristic</param>
        Task<Guid?> ResolveBusinessIdAsync(
            string? provider,
            string? phoneNumberId,
            string? displayPhoneNumber,
            string? wabaId,
            string? waId,
            CancellationToken ct = default);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Directory\ProviderDirectory.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using xbytechat_api.WhatsAppSettings.Models;

namespace xbytechat.api.Features.Webhooks.Directory
{
    /// <summary>
    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.
    /// </summary>
    public class ProviderDirectory : IProviderDirectory
    {
        private readonly AppDbContext _db;
        private readonly ILogger<ProviderDirectory> _logger;
        private readonly IMemoryCache _cache;

        // reduce DB hits during webhook bursts
        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);

        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)
        {
            _db = db;
            _logger = logger;
            _cache = cache;
        }

        public async Task<Guid?> ResolveBusinessIdAsync(
            string? provider,
            string? phoneNumberId,
            string? displayPhoneNumber,
            string? wabaId,
            string? waId,
            CancellationToken ct = default)
        {
            provider = provider?.Trim().ToLowerInvariant();

            var cacheKey = $"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}";
            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))
                return cached;

            try
            {
                // ‚öì 1) Strongest match: provider + phone_number_id
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))
                {
                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                // ‚öì 2) Next: provider + display_phone_number (normalized)
                var normalizedDisplay = Normalize(displayPhoneNumber);
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))
                {
                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                // ‚öì 3) Next: provider + wabaId (Meta)
                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))
                {
                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);
                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
                }

                _logger.LogWarning(
                    "ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}",
                    provider, phoneNumberId, normalizedDisplay, wabaId
                );
                return CacheAndReturn(cacheKey, null);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ProviderDirectory lookup failed.");
                return null;
            }
        }

        private Guid? CacheAndReturn(string key, Guid? value)
        {
            _cache.Set(key, value, CacheTtl);
            return value;
        }

        /// <summary>
        /// Centralized query; now materializes candidates so Normalize() runs in-memory.
        /// </summary>
        private async Task<Guid?> QueryByAsync(
            string provider,
            string? phoneNumberId = null,
            string? displayPhoneNumber = null,
            string? wabaId = null,
            CancellationToken ct = default)
        {
            // Only bring back what we need
            var candidates = await _db.Set<WhatsAppSettingEntity>()
                .AsNoTracking()
                .Where(s => s.IsActive && s.Provider.ToLower() == provider)
                .Select(s => new
                {
                    s.BusinessId,
                    s.PhoneNumberId,
                    s.WhatsAppBusinessNumber,
                    s.WabaId
                })
                .ToListAsync(ct);

            var normDisp = Normalize(displayPhoneNumber);

            var hit = candidates.FirstOrDefault(s =>
                (!string.IsNullOrEmpty(phoneNumberId) && s.PhoneNumberId == phoneNumberId) ||
                (!string.IsNullOrEmpty(normDisp) && Normalize(s.WhatsAppBusinessNumber) == normDisp) ||
                (!string.IsNullOrEmpty(wabaId) && s.WabaId == wabaId)
            );

            return hit?.BusinessId;
        }

        /// <summary>
        /// Normalize phone formatting for robust comparisons.
        /// </summary>
        private static string? Normalize(string? phone)
        {
            if (string.IsNullOrWhiteSpace(phone)) return null;
            var trimmed = phone.Trim();
            var hasPlus = trimmed.StartsWith("+");
            var digits = new string(trimmed.Where(char.IsDigit).ToArray());
            return hasPlus ? "+" + digits : digits;
        }
    }
}


//using System;
//using System.Linq;
//using System.Threading;
//using System.Threading.Tasks;
//using Microsoft.EntityFrameworkCore;
//using Microsoft.Extensions.Caching.Memory;
//using Microsoft.Extensions.Logging;
//using xbytechat_api.WhatsAppSettings.Models;

//namespace xbytechat.api.Features.Webhooks.Directory
//{
//    /// <summary>
//    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.
//    /// </summary>
//    public class ProviderDirectory : IProviderDirectory
//    {
//        private readonly AppDbContext _db;
//        private readonly ILogger<ProviderDirectory> _logger;
//        private readonly IMemoryCache _cache;

//        // reduce DB hits during webhook bursts
//        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);

//        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)
//        {
//            _db = db;
//            _logger = logger;
//            _cache = cache;
//        }

//        public async Task<Guid?> ResolveBusinessIdAsync(
//            string? provider,
//            string? phoneNumberId,
//            string? displayPhoneNumber,
//            string? wabaId,
//            string? waId,
//            CancellationToken ct = default)
//        {
//            provider = provider?.Trim().ToLowerInvariant();

//            var cacheKey = $"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}";
//            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))
//                return cached;

//            try
//            {
//                // ‚öì 1) Strongest match: provider + phone_number_id
//                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))
//                {
//                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);
//                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
//                }

//                // ‚öì 2) Next: provider + display_phone_number (normalized)
//                var normalizedDisplay = Normalize(displayPhoneNumber);
//                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))
//                {
//                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);
//                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
//                }

//                // ‚öì 3) Next: provider + wabaId (Meta)
//                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))
//                {
//                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);
//                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);
//                }

//                // (Optional) 4) Heuristic: waId ‚Üí very weak; only if you store it
//                // If you keep sender WA IDs in settings, you could add another query here.

//                _logger.LogWarning("ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}",
//                    provider, phoneNumberId, normalizedDisplay, wabaId);
//                return CacheAndReturn(cacheKey, null);
//            }
//            catch (Exception ex)
//            {
//                _logger.LogError(ex, "ProviderDirectory lookup failed.");
//                return null;
//            }
//        }

//        private Guid? CacheAndReturn(string key, Guid? value)
//        {
//            _cache.Set(key, value, CacheTtl);
//            return value;
//        }

//        /// <summary>
//        /// Centralized query; tweak entity/property names here if your model differs.
//        /// </summary>
//        private async Task<Guid?> QueryByAsync(
//                                string provider,
//                                string? phoneNumberId = null,
//                                string? displayPhoneNumber = null,
//                                string? wabaId = null,
//                                CancellationToken ct = default)
//        {
//            return await _db.Set<WhatsAppSettingEntity>()   // üëà use your real entity
//                .AsNoTracking()
//                .Where(s => s.IsActive && s.Provider.ToLower() == provider)
//                .Where(s =>
//                    (phoneNumberId != null && s.PhoneNumberId == phoneNumberId) ||
//                    (displayPhoneNumber != null && Normalize(s.WhatsAppBusinessNumber) == displayPhoneNumber) ||
//                    (wabaId != null && s.WabaId == wabaId)
//                )
//                .Select(s => (Guid?)s.BusinessId)
//                .FirstOrDefaultAsync(ct);
//        }

//        /// <summary>
//        /// Normalize phone formatting for robust comparisons.
//        /// </summary>
//        private static string? Normalize(string? phone)
//        {
//            if (string.IsNullOrWhiteSpace(phone)) return null;
//            // keep leading '+' if present, strip spaces, dashes, parentheses
//            var trimmed = phone.Trim();
//            var hasPlus = trimmed.StartsWith("+");
//            var digits = new string(trimmed.Where(char.IsDigit).ToArray());
//            return hasPlus ? "+" + digits : digits;
//        }

//        // ‚ö†Ô∏è Replace with your actual settings entity if named differently

//    }
//}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\DTOs\FailedWebhookLogDto.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.Webhooks.DTOs
{
    public class FailedWebhookLogDto
    {
        public string? ErrorMessage { get; set; }
        public string? SourceModule { get; set; }
        public string? FailureType { get; set; }
        public string RawJson { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Models\FailedWebhookLog.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.Webhooks.Models
{
    public class FailedWebhookLog
    {
        public Guid Id { get; set; } = Guid.NewGuid();

        // üß† Debug Metadata
        public string? ErrorMessage { get; set; }
        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor
        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED

        // üì¶ Raw Data Snapshot
        public string RawJson { get; set; } = string.Empty;

        // üïí Timeline
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Models\WebhookSettings.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Models
{
    public class WebhookSettings
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public bool AutoCleanupEnabled { get; set; } = true;
        public DateTime? LastCleanupAt { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Controllers\PinnacleWebhookController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;
using xbytechat.api.Features.Webhooks.Services;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers
{
    [ApiController]
    [Route("api/pinnacle/callback")]
    public sealed class PinnacleWebhookController : ControllerBase
    {
        private readonly IWebhookQueueService _queue;
        private readonly IPinnacleToMetaAdapter _adapter;
        private readonly ILogger<PinnacleWebhookController> _logger;

        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)
        {
            _queue = queue;
            _adapter = adapter;
            _logger = logger;
        }

        [HttpPost]
        public IActionResult Post([FromBody] JsonElement body)
        {
            // Transform to the envelope WhatsAppWebhookDispatcher already expects
            var metaEnvelope = _adapter.ToMetaEnvelope(body);
            _queue.Enqueue(metaEnvelope);
            _logger.LogInformation("üì® Pinnacle payload transformed and enqueued.");
            return Ok(new { received = true });
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Services\Adapters\IPinnacleToMetaAdapter.cs 
====================================================== 
 
Ôªøusing System.Text.Json;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters
{
    public interface IPinnacleToMetaAdapter
    {
        /// <summary>Converts provider-native payload to Meta-like envelope:
        /// { "entry":[{ "changes":[{ "value": { ... } }]}] }</summary>
        JsonElement ToMetaEnvelope(JsonElement pinnPayload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Pinnacle\Services\Adapters\PinnacleToMetaAdapter.cs 
====================================================== 
 
Ôªøusing System.Buffers;
using System.Text.Json;

namespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;

public sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter
{
    public JsonElement ToMetaEnvelope(JsonElement p)
    {
        var buf = new ArrayBufferWriter<byte>();
        using var w = new Utf8JsonWriter(buf);

        w.WriteStartObject();
        w.WritePropertyName("entry");
        w.WriteStartArray();
        w.WriteStartObject(); // entry[0]
        w.WritePropertyName("changes");
        w.WriteStartArray();
        w.WriteStartObject(); // changes[0]
        w.WritePropertyName("value");
        w.WriteStartObject();

        // NEW: try to emit metadata up-front (harmless if not found)
        WriteMetadata(p, w);

        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))
        {
            w.WritePropertyName("provider_raw");
            p.WriteTo(w);
        }

        w.WriteEndObject(); // value
        w.WriteEndObject(); // change
        w.WriteEndArray();  // changes
        w.WriteEndObject(); // entry[0]
        w.WriteEndArray();  // entry
        w.WriteEndObject(); // root
        w.Flush();

        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);
        using var doc = JsonDocument.Parse(ros);
        return doc.RootElement.Clone();
    }

    // ---- NEW ----
    // Best-effort extraction; tolerate any Pinnacle layout you have.
    // We only write fields if we can resolve them.
    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)
    {
        string? displayPhone = null;
        string? phoneNumberId = null;
        string? wabaId = null;

        // common guesses; add/rename to match your Pinnacle payload
        // 1) flat
        if (p.TryGetProperty("display_phone_number", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();
        if (p.TryGetProperty("phone_number_id", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();
        if (p.TryGetProperty("waba_id", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();

        // 2) channel
        if (p.TryGetProperty("channel", out var ch) && ch.ValueKind == JsonValueKind.Object)
        {
            if (displayPhone is null && ch.TryGetProperty("display_phone_number", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();
            if (displayPhone is null && ch.TryGetProperty("phone", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();

            if (phoneNumberId is null && ch.TryGetProperty("phone_number_id", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();
            if (phoneNumberId is null && ch.TryGetProperty("id", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();

            if (wabaId is null && ch.TryGetProperty("waba_id", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();
        }

        // 3) meta-style wrapper
        if (p.TryGetProperty("metadata", out var meta) && meta.ValueKind == JsonValueKind.Object)
        {
            if (displayPhone is null && meta.TryGetProperty("display_phone_number", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();
            if (phoneNumberId is null && meta.TryGetProperty("phone_number_id", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();
            if (wabaId is null && meta.TryGetProperty("waba_id", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();
        }

        if (displayPhone is null && p.TryGetProperty("business", out var biz) && biz.ValueKind == JsonValueKind.Object)
        {
            if (biz.TryGetProperty("phone", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();
            if (biz.TryGetProperty("phone_id", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();
        }

        // Only emit if we have at least one of them.
        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)
        {
            w.WritePropertyName("metadata");
            w.WriteStartObject();
            if (displayPhone is not null) w.WriteString("display_phone_number", displayPhone);
            if (phoneNumberId is not null) w.WriteString("phone_number_id", phoneNumberId);
            if (wabaId is not null) w.WriteString("waba_id", wabaId);
            w.WriteEndObject();
        }
    }
    // ---- NEW END ----

    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)
    {
        string? id = null, status = null;
        long? ts = null;

        if (p.TryGetProperty("messageId", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();
        if (p.TryGetProperty("id", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();
        if (p.TryGetProperty("status", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();

        if (p.TryGetProperty("timestamp", out var t))
        {
            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();
            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;
        }

        if (p.TryGetProperty("data", out var d) && d.ValueKind == JsonValueKind.Object)
        {
            if (id is null && d.TryGetProperty("id", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();
            if (status is null && d.TryGetProperty("status", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();
            if (ts is null && d.TryGetProperty("ts", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();
        }

        if (id is null || status is null) return false;

        w.WritePropertyName("statuses");
        w.WriteStartArray();
        w.WriteStartObject();
        w.WriteString("id", id);
        w.WriteString("status", status);
        if (ts.HasValue) w.WriteNumber("timestamp", ts.Value);
        w.WriteEndObject();
        w.WriteEndArray();
        return true;
    }

    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)
    {
        // { "click": { "title":"Flow Test", "contextId":"wamid..", "from":"<biz_phone?>" , "user":"<customer_wa_id?>" } }
        if (p.TryGetProperty("click", out var c) && c.ValueKind == JsonValueKind.Object)
        {
            var title = c.TryGetProperty("title", out var t) ? t.GetString() : null;
            var ctxId = c.TryGetProperty("contextId", out var ctx) ? ctx.GetString() : null;

            // customer who clicked
            var customerFrom = c.TryGetProperty("user", out var u) && u.ValueKind == JsonValueKind.String
                ? u.GetString()
                : (c.TryGetProperty("from", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);

            // **business** number that sent the message (Meta provides this as context.from)
            var businessFrom =
                (p.TryGetProperty("display_phone_number", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :
                (p.TryGetProperty("channel", out var ch) && ch.ValueKind == JsonValueKind.Object &&
                 ch.TryGetProperty("phone", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :
                (c.TryGetProperty("from", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort

            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))
            {
                w.WritePropertyName("messages");
                w.WriteStartArray();
                w.WriteStartObject();
                w.WriteString("type", "button");
                w.WriteString("from", customerFrom ?? "");          // customer wa_id
                w.WritePropertyName("button");
                w.WriteStartObject();
                w.WriteString("text", title!);
                w.WriteEndObject();
                w.WritePropertyName("context");
                w.WriteStartObject();
                w.WriteString("id", ctxId!);
                if (!string.IsNullOrWhiteSpace(businessFrom))
                    w.WriteString("from", businessFrom!);           // **important for directory resolution**
                w.WriteEndObject();
                w.WriteEndObject();
                w.WriteEndArray();
                return true;
            }
        }

        // { "message": { "from":"<customer_wa_id>", "body":"hi", "type":"text" }, "channel":{ "phone":"<biz_phone>" } }
        if (p.TryGetProperty("message", out var m) && m.ValueKind == JsonValueKind.Object)
        {
            var type = m.TryGetProperty("type", out var tp) ? tp.GetString() : "text";
            var from = m.TryGetProperty("from", out var fr) ? fr.GetString() : "";

            w.WritePropertyName("messages");
            w.WriteStartArray();
            w.WriteStartObject();
            w.WriteString("type", type ?? "text");
            w.WriteString("from", from ?? "");
            if ((type ?? "text") == "text")
            {
                var body = m.TryGetProperty("body", out var bd) ? bd.GetString() : "";
                w.WritePropertyName("text");
                w.WriteStartObject();
                w.WriteString("body", body ?? "");
                w.WriteEndObject();
            }
            w.WriteEndObject();
            w.WriteEndArray();
            return true;
        }

        return false;
    }
}


//using System.Buffers;
//using System.Text.Json;

//namespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;

//public sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter
//{
//    public JsonElement ToMetaEnvelope(JsonElement p)
//    {
//        var buf = new ArrayBufferWriter<byte>();     // not IDisposable
//        using var w = new Utf8JsonWriter(buf);       // IS IDisposable

//        w.WriteStartObject();
//        w.WritePropertyName("entry");
//        w.WriteStartArray();
//        w.WriteStartObject();                         // entry[0]
//        w.WritePropertyName("changes");
//        w.WriteStartArray();
//        w.WriteStartObject();                         // changes[0]
//        w.WritePropertyName("value");
//        w.WriteStartObject();

//        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))
//        {
//            w.WritePropertyName("provider_raw");
//            p.WriteTo(w);
//        }

//        w.WriteEndObject(); // value
//        w.WriteEndObject(); // change
//        w.WriteEndArray();  // changes
//        w.WriteEndObject(); // entry[0]
//        w.WriteEndArray();  // entry
//        w.WriteEndObject(); // root
//        w.Flush();

//        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);
//        using var doc = JsonDocument.Parse(ros);
//        return doc.RootElement.Clone();               // detach from doc
//    }
//    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)
//    {
//        // Heuristics for Pinnacle status payloads; adjust keys if your schema differs.
//        // Accept shapes:
//        // { "status":"delivered","messageId":"wamid...","timestamp":169... }
//        // { "data": { "status":"read","id":"wamid...","ts":169... } }
//        string? id = null, status = null;
//        long? ts = null;

//        if (p.TryGetProperty("messageId", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();
//        if (p.TryGetProperty("id", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();
//        if (p.TryGetProperty("status", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();

//        if (p.TryGetProperty("timestamp", out var t))
//        {
//            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();
//            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;
//        }

//        if (p.TryGetProperty("data", out var d) && d.ValueKind == JsonValueKind.Object)
//        {
//            if (id is null && d.TryGetProperty("id", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();
//            if (status is null && d.TryGetProperty("status", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();
//            if (ts is null && d.TryGetProperty("ts", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();
//        }

//        if (id is null || status is null) return false;

//        w.WritePropertyName("statuses");
//        w.WriteStartArray();
//        w.WriteStartObject();
//        w.WriteString("id", id);
//        w.WriteString("status", status);
//        if (ts.HasValue) w.WriteNumber("timestamp", ts.Value);
//        w.WriteEndObject();
//        w.WriteEndArray();
//        return true;
//    }

//    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)
//    {
//        // Click shape example:
//        // { "click": { "title":"Contact Sales", "contextId":"wamid..", "from":"91..." } }
//        if (p.TryGetProperty("click", out var c) && c.ValueKind == JsonValueKind.Object)
//        {
//            var title = c.TryGetProperty("title", out var t) ? t.GetString() : null;
//            var ctxId = c.TryGetProperty("contextId", out var ctx) ? ctx.GetString() : null;
//            var from = c.TryGetProperty("from", out var f) ? f.GetString() : null;

//            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))
//            {
//                w.WritePropertyName("messages");
//                w.WriteStartArray();
//                w.WriteStartObject();
//                w.WriteString("type", "button");
//                w.WriteString("from", from ?? "");
//                w.WritePropertyName("button");
//                w.WriteStartObject();
//                w.WriteString("text", title!);
//                w.WriteEndObject();
//                w.WritePropertyName("context");
//                w.WriteStartObject();
//                w.WriteString("id", ctxId!);
//                w.WriteEndObject();
//                w.WriteEndObject();
//                w.WriteEndArray();
//                return true;
//            }
//        }

//        // Inbound text example:
//        // { "message": { "from":"91...", "body":"hi", "type":"text" } }
//        if (p.TryGetProperty("message", out var m) && m.ValueKind == JsonValueKind.Object)
//        {
//            var type = m.TryGetProperty("type", out var tp) ? tp.GetString() : "text";
//            var from = m.TryGetProperty("from", out var fr) ? fr.GetString() : "";
//            var body = m.TryGetProperty("body", out var bd) ? bd.GetString() : "";

//            w.WritePropertyName("messages");
//            w.WriteStartArray();
//            w.WriteStartObject();
//            w.WriteString("type", type ?? "text");
//            w.WriteString("from", from ?? "");
//            if ((type ?? "text") == "text")
//            {
//                w.WritePropertyName("text");
//                w.WriteStartObject();
//                w.WriteString("body", body ?? "");
//                w.WriteEndObject();
//            }
//            w.WriteEndObject();
//            w.WriteEndArray();
//            return true;
//        }

//        return false;
//    }
//}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\FailedWebhookLogCleanupService.cs 
====================================================== 
 
Ôªøusing Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class FailedWebhookLogCleanupService : BackgroundService
    {
        private readonly ILogger<FailedWebhookLogCleanupService> _logger;
        private readonly IServiceProvider _services;
        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run

        public FailedWebhookLogCleanupService(ILogger<FailedWebhookLogCleanupService> logger, IServiceProvider services)
        {
            _logger = logger;
            _services = services;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("üßπ FailedWebhookLogCleanupService started.");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _services.CreateScope();
                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();

                    var cutoff = DateTime.UtcNow.AddDays(-7);
                    var oldLogs = await db.FailedWebhookLogs
                        .Where(x => x.CreatedAt < cutoff)
                        .ToListAsync(stoppingToken);

                    if (oldLogs.Any())
                    {
                        db.FailedWebhookLogs.RemoveRange(oldLogs);
                        await db.SaveChangesAsync(stoppingToken);
                        _logger.LogInformation("üßπ Deleted {Count} old failed webhook logs.", oldLogs.Count);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Failed to clean up old webhook logs.");
                }

                await Task.Delay(_interval, stoppingToken); // wait before next cleanup
            }

            _logger.LogInformation("üõë FailedWebhookLogCleanupService stopped.");
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\FailedWebhookLogService.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.DTOs;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class FailedWebhookLogService : IFailedWebhookLogService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<FailedWebhookLogService> _logger;

        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task LogFailureAsync(FailedWebhookLogDto dto)
        {
            try
            {
                var log = new FailedWebhookLog
                {
                    ErrorMessage = dto.ErrorMessage,
                    SourceModule = dto.SourceModule,
                    FailureType = dto.FailureType,
                    RawJson = dto.RawJson,
                    CreatedAt = dto.CreatedAt
                };

                await _context.FailedWebhookLogs.AddAsync(log);
                await _context.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to persist webhook error log");
            }
        }

        public async Task<List<FailedWebhookLog>> GetAllAsync()
        {
            return await _context.FailedWebhookLogs
                .OrderByDescending(x => x.CreatedAt)
                .Take(100) // prevent DB overload
                .ToListAsync();
        }

        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)
        {
            return await _context.FailedWebhookLogs.FindAsync(id);
        }

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IFailedWebhookLogService.cs 
====================================================== 
 
Ôªøusing System.Threading.Tasks;
using xbytechat.api.Features.Webhooks.DTOs;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IFailedWebhookLogService
    {
        Task LogFailureAsync(FailedWebhookLogDto dto);
        Task<List<FailedWebhookLog>> GetAllAsync();
        Task<FailedWebhookLog?> GetByIdAsync(Guid id);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IMaintenanceService.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Services
{
    public interface IMaintenanceService
    {
        Task<bool> IsAutoCleanupEnabledAsync();
        Task EnableAutoCleanupAsync();
        Task DisableAutoCleanupAsync();
        Task<DateTime?> GetLastCleanupTimeAsync();
        Task<int> RunCleanupAsync();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWebhookQueueService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using xbytechat.api.Features.Tracking.DTOs;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWebhookQueueService
    {
        void Enqueue(JsonElement payload);
        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);
        int GetQueueLength();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWhatsAppWebhookDispatcher.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWhatsAppWebhookDispatcher
    {
        Task DispatchAsync(JsonElement payload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\IWhatsAppWebhookService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services
{
    public interface IWhatsAppWebhookService
    {
        
        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\MaintenanceService.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Webhooks.Models;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class MaintenanceService : IMaintenanceService
    {
        private readonly AppDbContext _context;

        public MaintenanceService(AppDbContext context)
        {
            _context = context;
        }

        public async Task<bool> IsAutoCleanupEnabledAsync()
        {
            var setting = await _context.WebhookSettings
                .AsNoTracking()
                .FirstOrDefaultAsync();

            return setting?.AutoCleanupEnabled ?? false;
        }

        public async Task<DateTime?> GetLastCleanupTimeAsync()
        {
            return await _context.WebhookSettings
                .AsNoTracking()
                .Select(s => s.LastCleanupAt)
                .FirstOrDefaultAsync();
        }

        public async Task EnableAutoCleanupAsync()
        {
            var setting = await GetOrCreateAsync();
            setting.AutoCleanupEnabled = true;
            await _context.SaveChangesAsync();
        }

        public async Task DisableAutoCleanupAsync()
        {
            var setting = await GetOrCreateAsync();
            setting.AutoCleanupEnabled = false;
            await _context.SaveChangesAsync();
        }

        public async Task<int> RunCleanupAsync()
        {
            var threshold = DateTime.UtcNow.AddDays(-7);
            var oldLogs = await _context.FailedWebhookLogs
                .Where(l => l.CreatedAt < threshold)
                .ToListAsync();

            if (oldLogs.Any())
                _context.FailedWebhookLogs.RemoveRange(oldLogs);

            var setting = await GetOrCreateAsync();
            setting.LastCleanupAt = DateTime.UtcNow;

            await _context.SaveChangesAsync();
            return oldLogs.Count;
        }

        private async Task<WebhookSettings> GetOrCreateAsync()
        {
            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();
            if (setting == null)
            {
                setting = new WebhookSettings
                {
                    AutoCleanupEnabled = false,
                    LastCleanupAt = null
                };
                _context.WebhookSettings.Add(setting);
                await _context.SaveChangesAsync();
            }
            return setting;
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WebhookQueueService.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Channels;

namespace xbytechat.api.Features.Webhooks.Services
{
    public class WebhookQueueService : IWebhookQueueService
    {
        private readonly Channel<JsonElement> _queue;

        public WebhookQueueService()
        {
            var options = new BoundedChannelOptions(5000)
            {
                FullMode = BoundedChannelFullMode.Wait,
                SingleReader = true,
                SingleWriter = false
            };

            _queue = Channel.CreateBounded<JsonElement>(options);
        }

        public void Enqueue(JsonElement item)
        {
            if (!_queue.Writer.TryWrite(item))
            {
                throw new InvalidOperationException("‚ö†Ô∏è Webhook queue is full.");
            }
        }

        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)
        {
            return await _queue.Reader.ReadAsync(cancellationToken);
        }

        public int GetQueueLength() => _queue.Reader.Count;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WhatsAppWebhookDispatcher.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using xbytechat.api.Features.Webhooks.Directory;            // ‚úÖ provider directory
using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;
using xbytechat.api.Features.Webhooks.Services.Processors;

namespace xbytechat.api.Features.Webhooks.Services
{
    /// <summary>
    /// Central dispatcher for WhatsApp webhook events.
    /// Routes payloads to the appropriate processor based on payload type.
    /// </summary>
    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher
    {
        private readonly IStatusWebhookProcessor _statusProcessor;           // legacy fallback (keep)
        private readonly ITemplateWebhookProcessor _templateProcessor;       // template events path (unchanged)
        private readonly IClickWebhookProcessor _clickProcessor;             // click/journey path (unchanged)
        private readonly IInboundMessageProcessor _inboundMessageProcessor;  // inbound chat path (unchanged)
        private readonly IWhatsAppWebhookService _webhookService;            // ‚úÖ for new unified status updater call
        private readonly IProviderDirectory _directory;                      // ‚úÖ resolve BusinessId from provider hints
        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;
        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;
        public WhatsAppWebhookDispatcher(
            IStatusWebhookProcessor statusProcessor,
            ITemplateWebhookProcessor templateProcessor,
            ILogger<WhatsAppWebhookDispatcher> logger,
            IClickWebhookProcessor clickProcessor,
            IInboundMessageProcessor inboundMessageProcessor,
            IWhatsAppWebhookService webhookService,     // ‚úÖ add
            IProviderDirectory directory,
             IPinnacleToMetaAdapter pinnacleToMetaAdapter
        // ‚úÖ add
        )
        {
            _statusProcessor = statusProcessor;
            _templateProcessor = templateProcessor;
            _logger = logger;
            _clickProcessor = clickProcessor;
            _inboundMessageProcessor = inboundMessageProcessor;
            _webhookService = webhookService;
            _directory = directory;
            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;
        }

        //public async Task DispatchAsync(JsonElement payload)
        //{
        //    _logger.LogWarning("üì¶ Dispatcher Raw Payload:\n{Payload}", payload.ToString());

        //    try
        //    {
        //        if (!payload.TryGetProperty("entry", out var entries)) return;

        //        foreach (var entry in entries.EnumerateArray())
        //        {
        //            if (!entry.TryGetProperty("changes", out var changes)) continue;

        //            foreach (var change in changes.EnumerateArray())
        //            {
        //                if (!change.TryGetProperty("value", out var value)) continue;

        //                // üì® STATUS UPDATES (Meta: value.statuses[], Pinnacle: often status/event fields)
        //                if (IsStatusPayload(payload))
        //                {
        //                    // ‚úÖ NEW: provider-aware status routing with graceful fallback
        //                    var provider = DetectProvider(payload); // "meta" | "pinnacle" | null

        //                    Guid? businessId = null;
        //                    try
        //                    {
        //                        var hints = ExtractNumberHints(payload, provider);
        //                        businessId = await _directory.ResolveBusinessIdAsync(
        //                            provider: provider,
        //                            phoneNumberId: hints.PhoneNumberId,
        //                            displayPhoneNumber: hints.DisplayPhoneNumber,
        //                            wabaId: hints.WabaId,
        //                            waId: hints.WaId
        //                        );
        //                    }
        //                    catch (Exception ex)
        //                    {
        //                        _logger.LogError(ex, "ProviderDirectory lookup failed; will fallback to legacy status processor.");
        //                    }

        //                    if (businessId is Guid bid && !string.IsNullOrWhiteSpace(provider))
        //                    {
        //                        _logger.LogInformation("üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})", provider, bid);
        //                        await _webhookService.ProcessStatusUpdateAsync(bid, provider!, payload);
        //                    }
        //                    else
        //                    {
        //                        _logger.LogWarning("‚ö†Ô∏è Status routing fallback ‚Üí legacy processor (provider={Provider}, businessId={BusinessId})", provider, businessId);
        //                        await _statusProcessor.ProcessStatusUpdateAsync(payload);
        //                    }
        //                    continue;
        //                }

        //                // üßæ Template Events (unchanged)
        //                if (value.TryGetProperty("event", out var eventType)
        //                    && eventType.GetString()?.StartsWith("template_") == true)
        //                {
        //                    _logger.LogInformation("üì¶ Routing to Template Processor");
        //                    await _templateProcessor.ProcessTemplateUpdateAsync(payload);
        //                    continue;
        //                }

        //                // üéØ Messages block (clicks + inbound)
        //                if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
        //                {
        //                    _logger.LogDebug("‚ÑπÔ∏è No 'messages' array present.");
        //                    continue;
        //                }

        //                foreach (var m in msgs.EnumerateArray())
        //                {
        //                    if (!m.TryGetProperty("type", out var typeProp))
        //                    {
        //                        _logger.LogDebug("‚ÑπÔ∏è Message without 'type' field.");
        //                        continue;
        //                    }

        //                    var type = typeProp.GetString();

        //                    // (A) Legacy quick-reply button ‚Üí CLICK
        //                    if (type == "button")
        //                    {
        //                        _logger.LogInformation("üëâ Routing to Click Processor (legacy 'button')");
        //                        await _clickProcessor.ProcessClickAsync(value);
        //                        continue;
        //                    }

        //                    // (B) Interactive (button_reply / list_reply) ‚Üí CLICK
        //                    if (type == "interactive" && m.TryGetProperty("interactive", out var interactive))
        //                    {
        //                        if (interactive.TryGetProperty("type", out var interactiveType) &&
        //                            interactiveType.GetString() == "button_reply")
        //                        {
        //                            _logger.LogInformation("üëâ Routing to Click Processor (interactive/button_reply)");
        //                            await _clickProcessor.ProcessClickAsync(value);
        //                            continue;
        //                        }

        //                        if (interactive.TryGetProperty("list_reply", out _))
        //                        {
        //                            _logger.LogInformation("üëâ Routing to Click Processor (interactive/list_reply)");
        //                            await _clickProcessor.ProcessClickAsync(value);
        //                            continue;
        //                        }
        //                    }

        //                    // (C) Inbound plain message types ‚Üí INBOUND
        //                    if (type is "text" or "image" or "audio")
        //                    {
        //                        _logger.LogInformation("üí¨ Routing to InboundMessageProcessor (type: {Type})", type);
        //                        await _inboundMessageProcessor.ProcessChatAsync(value);
        //                        continue;
        //                    }

        //                    _logger.LogDebug("‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.", type);
        //                }
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "‚ùå Dispatcher failed to process WhatsApp webhook.");
        //    }
        //}

        // --------------- helpers ----------------
        public async Task DispatchAsync(JsonElement payload)
        {
            _logger.LogWarning("üì¶ Dispatcher Raw Payload:\n{Payload}", payload.ToString());

            try
            {
                // 0) Detect provider & normalize to a Meta-like envelope for downstream processors
                var provider = DetectProvider(payload); // "meta" | "pinnacle" | null

                JsonElement envelope = provider == "pinnacle"
                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)
                    : payload;

                if (!envelope.TryGetProperty("entry", out var entries)) return;

                foreach (var entry in entries.EnumerateArray())
                {
                    if (!entry.TryGetProperty("changes", out var changes)) continue;

                    foreach (var change in changes.EnumerateArray())
                    {
                        if (!change.TryGetProperty("value", out var value)) continue;

                        // 1) STATUS UPDATES
                        if (IsStatusPayload(envelope)) // üîÅ use envelope, not raw payload
                        {
                            Guid? businessId = null;
                            try
                            {
                                var hints = ExtractNumberHints(envelope, provider); // üîÅ from envelope
                                businessId = await _directory.ResolveBusinessIdAsync(
                                    provider: provider,
                                    phoneNumberId: hints.PhoneNumberId,
                                    displayPhoneNumber: hints.DisplayPhoneNumber,
                                    wabaId: hints.WabaId,
                                    waId: hints.WaId
                                );
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "ProviderDirectory lookup failed; will fallback to legacy status processor.");
                            }

                            if (businessId is Guid bid && !string.IsNullOrWhiteSpace(provider))
                            {
                                _logger.LogInformation("üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})", provider, bid);
                                await _webhookService.ProcessStatusUpdateAsync(bid, provider!, envelope); // üîÅ pass envelope
                            }
                            else
                            {
                                _logger.LogWarning("‚ö†Ô∏è Status routing fallback ‚Üí legacy processor (provider={Provider}, businessId={BusinessId})", provider, businessId);
                                await _statusProcessor.ProcessStatusUpdateAsync(envelope); // üîÅ pass envelope
                            }
                            continue;
                        }

                        // 2) TEMPLATE EVENTS (unchanged)
                        if (value.TryGetProperty("event", out var eventType)
                            && eventType.GetString()?.StartsWith("template_") == true)
                        {
                            _logger.LogInformation("üì¶ Routing to Template Processor");
                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope); // üîÅ pass envelope
                            continue;
                        }

                        // 3) MESSAGES (clicks + inbound)
                        if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
                        {
                            _logger.LogDebug("‚ÑπÔ∏è No 'messages' array present.");
                            continue;
                        }

                        foreach (var m in msgs.EnumerateArray())
                        {
                            if (!m.TryGetProperty("type", out var typeProp))
                            {
                                _logger.LogDebug("‚ÑπÔ∏è Message without 'type' field.");
                                continue;
                            }

                            var type = typeProp.GetString();

                            // (A) Legacy quick-reply button ‚Üí CLICK
                            if (type == "button")
                            {
                                _logger.LogInformation("üëâ Routing to Click Processor (legacy 'button')");
                                await _clickProcessor.ProcessClickAsync(change.GetProperty("value")); // üîÅ from envelope
                                continue;
                            }

                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK
                            if (type == "interactive" && m.TryGetProperty("interactive", out var interactive))
                            {
                                if (interactive.TryGetProperty("type", out var interactiveType) &&
                                    interactiveType.GetString() == "button_reply")
                                {
                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/button_reply)");
                                    await _clickProcessor.ProcessClickAsync(change.GetProperty("value")); // üîÅ from envelope
                                    continue;
                                }

                                if (interactive.TryGetProperty("list_reply", out _))
                                {
                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/list_reply)");
                                    await _clickProcessor.ProcessClickAsync(change.GetProperty("value")); // üîÅ from envelope
                                    continue;
                                }
                            }

                            // (C) Inbound plain message types ‚Üí INBOUND
                            if (type is "text" or "image" or "audio")
                            {
                                _logger.LogInformation("üí¨ Routing to InboundMessageProcessor (type: {Type})", type);
                                await _inboundMessageProcessor.ProcessChatAsync(change.GetProperty("value")); // üîÅ from envelope
                                continue;
                            }

                            _logger.LogDebug("‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.", type);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Dispatcher failed to process WhatsApp webhook.");
            }
        }

        private static bool IsStatusPayload(JsonElement root)
        {
            // Try Meta shape first: entry[].changes[].value.statuses
            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty("statuses", out _))
                return true;

            // Try common Pinnacle shapes: "status" or event containing "status"
            if (root.TryGetProperty("status", out _)) return true;
            if (root.TryGetProperty("event", out var ev) &&
                (ev.GetString()?.Contains("status", StringComparison.OrdinalIgnoreCase) ?? false))
                return true;

            return false;
        }

        private static string? DetectProvider(JsonElement root)
        {
            // Heuristics by envelope
            if (root.TryGetProperty("object", out var obj) && obj.GetString() == "whatsapp_business_account")
                return "meta";
            if (root.TryGetProperty("entry", out _))
                return "meta";
            if (root.TryGetProperty("event", out _))
                return "pinnacle";

            return null;
        }

        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)
        {
            res = default;
            if (!root.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)
                return false;

            var entry = entries[0];
            if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)
                return false;

            var change = changes[0];
            if (!change.TryGetProperty("value", out var value))
                return false;

            res = (value, change, entry);
            return true;
        }

        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)
        {
            var hints = new NumberHints();

            if (string.Equals(provider, "meta", StringComparison.OrdinalIgnoreCase))
            {
                if (TryGetMetaValue(root, out var v))
                {
                    if (v.Value.TryGetProperty("metadata", out var md))
                    {
                        if (md.TryGetProperty("phone_number_id", out var pnid))
                            hints.PhoneNumberId = pnid.GetString();

                        if (md.TryGetProperty("display_phone_number", out var disp))
                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());
                    }

                    if (v.Value.TryGetProperty("statuses", out var statuses) &&
                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)
                    {
                        var s0 = statuses[0];
                        if (s0.TryGetProperty("recipient_id", out var rid))
                            hints.WaId = rid.GetString();
                    }
                }
            }
            else if (string.Equals(provider, "pinnacle", StringComparison.OrdinalIgnoreCase))
            {
                // Adjust to your Pinnacle adapter payload (post-adaptation).
                // If you inject phone_number_id when adapting to Meta shape, this will pick it up:
                if (root.TryGetProperty("phone_number_id", out var pn))
                    hints.PhoneNumberId = pn.GetString();

                // Fallback to sender number fields:
                if (root.TryGetProperty("from", out var from))
                    hints.DisplayPhoneNumber = NormalizePhone(from.GetString());
                else if (root.TryGetProperty("msisdn", out var msisdn))
                    hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());

                if (root.TryGetProperty("wabaId", out var waba))
                    hints.WabaId = waba.GetString();
            }

            return hints;
        }

        private static string? NormalizePhone(string? v)
        {
            if (string.IsNullOrWhiteSpace(v)) return null;
            var t = v.Trim();
            var keepPlus = t.StartsWith("+");
            var digits = new string(t.Where(char.IsDigit).ToArray());
            return keepPlus ? "+" + digits : digits;
        }

        private struct NumberHints
        {
            public string? PhoneNumberId { get; set; }
            public string? DisplayPhoneNumber { get; set; }
            public string? WabaId { get; set; }
            public string? WaId { get; set; }
        }
    }
}


//using System;
//using System.Text.Json;
//using System.Threading.Tasks;
//using Microsoft.Extensions.Logging;
//using xbytechat.api.Features.Webhooks.Services.Processors;
//using static System.Net.Mime.MediaTypeNames;

//namespace xbytechat.api.Features.Webhooks.Services
//{
//    /// <summary>
//    /// Central dispatcher for WhatsApp webhook events.
//    /// Routes payloads to the appropriate processor based on payload type.
//    /// </summary>
//    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher
//    {
//        private readonly IStatusWebhookProcessor _statusProcessor;
//        private readonly ITemplateWebhookProcessor _templateProcessor;
//        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;
//        private readonly IClickWebhookProcessor _clickProcessor;
//        private readonly IInboundMessageProcessor _inboundMessageProcessor;
//        public WhatsAppWebhookDispatcher(
//            IStatusWebhookProcessor statusProcessor,
//            ITemplateWebhookProcessor templateProcessor,
//            ILogger<WhatsAppWebhookDispatcher> logger,
//            IClickWebhookProcessor clickProcessor,
//            IInboundMessageProcessor inboundMessageProcessor)
//        {
//            _statusProcessor = statusProcessor;
//            _templateProcessor = templateProcessor;
//            _logger = logger;
//            _clickProcessor = clickProcessor;
//            _inboundMessageProcessor = inboundMessageProcessor;
//        }



//        public async Task DispatchAsync(JsonElement payload)
//        {
//            _logger.LogWarning("üì¶ Dispatcher Raw Payload:\n{Payload}", payload.ToString());

//            try
//            {
//                if (!payload.TryGetProperty("entry", out var entries)) return;

//                foreach (var entry in entries.EnumerateArray())
//                {
//                    if (!entry.TryGetProperty("changes", out var changes)) continue;

//                    foreach (var change in changes.EnumerateArray())
//                    {
//                        if (!change.TryGetProperty("value", out var value)) continue;

//                        // üì® Status Updates
//                        if (value.TryGetProperty("statuses", out _))
//                        {
//                            _logger.LogInformation("üì¶ Routing to Status Processor");
//                            await _statusProcessor.ProcessStatusUpdateAsync(payload);
//                            continue;
//                        }

//                        // üßæ Template Events
//                        if (value.TryGetProperty("event", out var eventType)
//                            && eventType.GetString()?.StartsWith("template_") == true)
//                        {
//                            _logger.LogInformation("üì¶ Routing to Template Processor");
//                            await _templateProcessor.ProcessTemplateUpdateAsync(payload);
//                            continue;
//                        }

//                        // üéØ Messages block
//                        if (!value.TryGetProperty("messages", out var msgs) || msgs.GetArrayLength() == 0)
//                        {
//                            _logger.LogDebug("‚ÑπÔ∏è No 'messages' array present.");
//                            continue;
//                        }

//                        foreach (var m in msgs.EnumerateArray())
//                        {
//                            if (!m.TryGetProperty("type", out var typeProp))
//                            {
//                                _logger.LogDebug("‚ÑπÔ∏è Message without 'type' field.");
//                                continue;
//                            }

//                            var type = typeProp.GetString();

//                            // (A) Legacy quick-reply button
//                            if (type == "button")
//                            {
//                                _logger.LogInformation("üëâ Routing to Click Processor (legacy 'button')");
//                                await _clickProcessor.ProcessClickAsync(value);
//                                continue;
//                            }

//                            // (B) Interactive: button_reply OR list_reply
//                            if (type == "interactive" && m.TryGetProperty("interactive", out var interactive))
//                            {
//                                // button_reply
//                                if (interactive.TryGetProperty("type", out var interactiveType) &&
//                                    interactiveType.GetString() == "button_reply")
//                                {
//                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/button_reply)");
//                                    await _clickProcessor.ProcessClickAsync(value);
//                                    continue;
//                                }

//                                // list_reply (list menu selections are also "clicks" in our flow)
//                                if (interactive.TryGetProperty("list_reply", out _))
//                                {
//                                    _logger.LogInformation("üëâ Routing to Click Processor (interactive/list_reply)");
//                                    await _clickProcessor.ProcessClickAsync(value);
//                                    continue;
//                                }
//                            }

//                            // (C) Inbound plain message types
//                            if (type is "text" or "image" or "audio")
//                            {
//                                _logger.LogInformation("üí¨ Routing to InboundMessageProcessor (type: {Type})", type);
//                                await _inboundMessageProcessor.ProcessChatAsync(value);
//                                continue;
//                            }

//                            _logger.LogDebug("‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.", type);
//                        }
//                    }
//                }
//            }
//            catch (Exception ex)
//            {
//                _logger.LogError(ex, "‚ùå Dispatcher failed to process WhatsApp webhook.");
//            }
//        }

//    }
//}

 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\WhatsAppWebhookService.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

using xbytechat.api;                                      // AppDbContext
using xbytechat.api.Features.CampaignTracking.Models;     // CampaignSendLog
using xbytechat.api.Features.Webhooks.Status;             // IMessageStatusUpdater, StatusEvent, MessageDeliveryState

namespace xbytechat.api.Features.Webhooks.Services
{
    public class WhatsAppWebhookService : IWhatsAppWebhookService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<WhatsAppWebhookService> _logger;
        private readonly IMessageStatusUpdater _updater;

        public WhatsAppWebhookService(
            AppDbContext context,
            ILogger<WhatsAppWebhookService> logger,
            IMessageStatusUpdater updater)
        {
            _context = context;
            _logger = logger;
            _updater = updater;
        }

        /// <summary>
        /// Legacy path: payload only (Meta-like).
        /// We keep this for back-compat, but we *upgrade* behavior:
        /// - For each status: find CampaignSendLog by MessageId
        /// - If found ‚Üí get BusinessId and delegate to the unified updater
        /// - If not found ‚Üí keep legacy log-only update (minimal)
        /// </summary>
        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)
        {
            _logger.LogInformation("üì¶ Processing Webhook Status (legacy):\n{Pretty}",
                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));

            if (!payload.TryGetProperty("entry", out var entries))
            {
                _logger.LogWarning("‚ö†Ô∏è Payload missing 'entry' property.");
                return;
            }

            foreach (var entry in entries.EnumerateArray())
            {
                if (!entry.TryGetProperty("changes", out var changes)) continue;

                foreach (var change in changes.EnumerateArray())
                {
                    if (!change.TryGetProperty("value", out var value)) continue;
                    if (!value.TryGetProperty("statuses", out var statuses)) continue;

                    foreach (var status in statuses.EnumerateArray())
                    {
                        string? messageId = status.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
                        string? statusText = status.TryGetProperty("status", out var statusProp) ? statusProp.GetString() : null;

                        // timestamp may be string or number
                        long ts = 0;
                        if (status.TryGetProperty("timestamp", out var tsProp))
                        {
                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsedTs))
                                ts = parsedTs;
                            else if (tsProp.ValueKind == JsonValueKind.Number)
                                ts = tsProp.GetInt64();
                        }

                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))
                        {
                            _logger.LogWarning("‚ö†Ô∏è Missing messageId or status in webhook payload.");
                            continue;
                        }

                        // Try to locate CampaignSendLog (gives us BusinessId)
                        var sendLog = await _context.Set<CampaignSendLog>()
                            .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);

                        if (sendLog != null)
                        {
                            var ev = new StatusEvent
                            {
                                BusinessId = sendLog.BusinessId,
                                Provider = "meta", // legacy path is Meta-shaped; adjust if you also send Pinnacle here
                                ProviderMessageId = messageId,
                                State = MapMetaState(statusText),
                                OccurredAt = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts) : DateTimeOffset.UtcNow
                            };

                            await _updater.UpdateAsync(ev, ct);
                            _logger.LogInformation("‚úÖ Unified update applied for MessageId {MessageId} (state={State})", messageId, statusText);
                        }
                        else
                        {
                            // Fallback: minimal legacy update to CampaignSendLogs (kept from your original code)
                            var time = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts).UtcDateTime : (DateTime?)null;

                            var log = await _context.Set<CampaignSendLog>()
                                .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);

                            if (log == null)
                            {
                                _logger.LogWarning("‚ö†Ô∏è No matching CampaignSendLog for MessageId: {MessageId}", messageId);
                                continue;
                            }

                            var newStatus = statusText switch
                            {
                                "sent" => "Sent",
                                "delivered" => "Delivered",
                                "read" => "Read",
                                _ => null
                            };

                            bool isUpdated = false;

                            if (!string.IsNullOrEmpty(newStatus) && !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))
                            {
                                log.SendStatus = newStatus;
                                isUpdated = true;
                            }

                            if (statusText == "delivered" && log.DeliveredAt == null && time.HasValue)
                            {
                                log.DeliveredAt = time.Value;
                                isUpdated = true;
                            }

                            if (statusText == "read" && log.ReadAt == null && time.HasValue)
                            {
                                log.ReadAt = time.Value;
                                isUpdated = true;
                            }

                            if (isUpdated)
                            {
                                await _context.SaveChangesAsync(ct);
                                _logger.LogInformation("‚úÖ Log updated for MessageId: {MessageId} ‚Üí {Status}", messageId, newStatus);
                            }
                            else
                            {
                                _logger.LogInformation("üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId}", statusText, messageId);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// New provider-aware overload called by the dispatcher after it resolves BusinessId + Provider.
        /// Always uses the unified updater.
        /// </summary>
        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)
        {
            provider = (provider ?? "").Trim().ToLowerInvariant();

            foreach (var ev in ParseStatusEvents(businessId, provider, payload))
            {
                await _updater.UpdateAsync(ev, ct);
            }
        }

        // ---------------- Parsers (Meta + Pinnacle) ----------------

        private static IEnumerable<StatusEvent> ParseStatusEvents(Guid businessId, string provider, JsonElement root)
        {
            if (provider == "meta" || provider == "meta_cloud" || provider == "meta-cloud")
            {
                if (TryGetMetaValue(root, out var v) &&
                    v.Value.TryGetProperty("statuses", out var statuses) &&
                    statuses.ValueKind == JsonValueKind.Array)
                {
                    foreach (var s in statuses.EnumerateArray())
                    {
                        var stateStr = s.TryGetProperty("status", out var st) ? st.GetString() : null;
                        var state = MapMetaState(stateStr);

                        var tsStr = s.TryGetProperty("timestamp", out var tsv) ? tsv.ToString() : null;
                        var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;

                        var providerMsgId = s.TryGetProperty("id", out var idv) ? idv.GetString() : null;
                        var waId = s.TryGetProperty("recipient_id", out var rid) ? rid.GetString() : null;

                        string? errorCode = null, errorMsg = null;
                        if (s.TryGetProperty("errors", out var errs) && errs.ValueKind == JsonValueKind.Array && errs.GetArrayLength() > 0)
                        {
                            var e0 = errs[0];
                            if (e0.TryGetProperty("code", out var cv)) errorCode = cv.ToString();
                            if (e0.TryGetProperty("message", out var mv)) errorMsg = mv.GetString();
                        }

                        string? conversationId = null;
                        if (s.TryGetProperty("conversation", out var conv) && conv.TryGetProperty("id", out var cid))
                            conversationId = cid.GetString();

                        yield return new StatusEvent
                        {
                            BusinessId = businessId,
                            Provider = "meta",
                            ProviderMessageId = providerMsgId ?? string.Empty,
                            RecipientWaId = waId,
                            State = state,
                            OccurredAt = occurredAt,
                            ErrorCode = errorCode,
                            ErrorMessage = errorMsg,
                            ConversationId = conversationId
                        };
                    }
                }
                yield break;
            }

            if (provider == "pinnacle")
            {
                // Support both object and array shapes
                if (root.ValueKind == JsonValueKind.Object)
                {
                    foreach (var ev in ParsePinnacleObject(businessId, root))
                        yield return ev;
                }
                else if (root.ValueKind == JsonValueKind.Array)
                {
                    foreach (var item in root.EnumerateArray())
                        foreach (var ev in ParsePinnacleObject(businessId, item))
                            yield return ev;
                }
                yield break;
            }
        }

        private static IEnumerable<StatusEvent> ParsePinnacleObject(Guid businessId, JsonElement obj)
        {
            var providerMsgId = obj.TryGetProperty("message_id", out var mid) ? mid.GetString()
                              : obj.TryGetProperty("id", out var idv) ? idv.GetString()
                              : null;

            var waId = obj.TryGetProperty("to", out var to) ? to.GetString()
                     : obj.TryGetProperty("recipient_id", out var rid) ? rid.GetString()
                     : null;

            var stateStr = obj.TryGetProperty("status", out var st) ? st.GetString()
                         : obj.TryGetProperty("event", out var ev) ? ev.GetString()
                         : null;

            var state = MapPinnacleState(stateStr);

            var tsStr = obj.TryGetProperty("timestamp", out var tsv) ? tsv.ToString() : null;
            var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;

            string? errorCode = null, errorMsg = null;
            if (obj.TryGetProperty("error", out var err))
            {
                if (err.TryGetProperty("code", out var cv)) errorCode = cv.ToString();
                if (err.TryGetProperty("message", out var mv)) errorMsg = mv.GetString();
            }

            yield return new StatusEvent
            {
                BusinessId = businessId,
                Provider = "pinnacle",
                ProviderMessageId = providerMsgId ?? string.Empty,
                RecipientWaId = waId,
                State = state,
                OccurredAt = occurredAt,
                ErrorCode = errorCode,
                ErrorMessage = errorMsg
            };
        }

        // ---------------- helpers ----------------

        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)
        {
            res = default;
            if (!root.TryGetProperty("entry", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)
                return false;

            var entry = entries[0];
            if (!entry.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)
                return false;

            var change = changes[0];
            if (!change.TryGetProperty("value", out var value))
                return false;

            res = (value, change, entry);
            return true;
        }

        private static MessageDeliveryState MapMetaState(string? s) =>
            (s ?? "").ToLowerInvariant() switch
            {
                "sent" => MessageDeliveryState.Sent,
                "delivered" => MessageDeliveryState.Delivered,
                "read" => MessageDeliveryState.Read,
                "failed" => MessageDeliveryState.Failed,
                "deleted" => MessageDeliveryState.Deleted,
                _ => MessageDeliveryState.Sent
            };

        private static MessageDeliveryState MapPinnacleState(string? s)
        {
            var v = (s ?? "").ToLowerInvariant();
            if (v.Contains("deliv")) return MessageDeliveryState.Delivered;
            if (v.Contains("read")) return MessageDeliveryState.Read;
            if (v.Contains("fail") || v.Contains("error")) return MessageDeliveryState.Failed;
            if (v.Contains("sent") || v.Contains("submit")) return MessageDeliveryState.Sent;
            if (v.Contains("delete")) return MessageDeliveryState.Deleted;
            return MessageDeliveryState.Sent;
        }

        private static DateTimeOffset? TryParseUnix(string? val)
        {
            if (string.IsNullOrWhiteSpace(val)) return null;
            if (long.TryParse(val, out var s)) return DateTimeOffset.FromUnixTimeSeconds(s);
            return null;
        }
    }
}


//using System;
//using System.Linq;
//using System.Text.Json;
//using System.Threading.Tasks;
//using Microsoft.EntityFrameworkCore;
//using Microsoft.Extensions.Logging;

//namespace xbytechat.api.Features.Webhooks.Services
//{
//    public class WhatsAppWebhookService : IWhatsAppWebhookService
//    {
//        private readonly AppDbContext _context;
//        private readonly ILogger<WhatsAppWebhookService> _logger;

//        public WhatsAppWebhookService(AppDbContext context, ILogger<WhatsAppWebhookService> logger)
//        {
//            _context = context;
//            _logger = logger;
//        }
//        public async Task ProcessStatusUpdateAsync(JsonElement payload)
//        {
//            _logger.LogInformation("üì¶ Processing Webhook Status:\n" +
//                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));

//            if (!payload.TryGetProperty("entry", out var entries))
//            {
//                _logger.LogWarning("‚ö†Ô∏è Payload missing 'entry' property.");
//                return;
//            }

//            foreach (var entry in entries.EnumerateArray())
//            {
//                if (!entry.TryGetProperty("changes", out var changes)) continue;

//                foreach (var change in changes.EnumerateArray())
//                {
//                    if (!change.TryGetProperty("value", out var value)) continue;

//                    if (!value.TryGetProperty("statuses", out var statuses)) continue;

//                    foreach (var status in statuses.EnumerateArray())
//                    {
//                        string? messageId = status.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
//                        string? statusText = status.TryGetProperty("status", out var statusProp) ? statusProp.GetString() : null;
//                        long timestamp = status.TryGetProperty("timestamp", out var tsProp) && tsProp.ValueKind == JsonValueKind.String
//                                         && long.TryParse(tsProp.GetString(), out var parsedTs)
//                                         ? parsedTs
//                                         : (tsProp.ValueKind == JsonValueKind.Number ? tsProp.GetInt64() : 0);

//                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))
//                        {
//                            _logger.LogWarning("‚ö†Ô∏è Missing messageId or statusText in webhook payload.");
//                            continue;
//                        }

//                        var log = await _context.CampaignSendLogs
//                            //.AsNoTracking()
//                            .FirstOrDefaultAsync(l => l.MessageId == messageId);

//                        if (log != null)
//                        {
//                            var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;

//                            //log.SendStatus = statusText switch
//                            //{
//                            //    "sent" => "Sent",
//                            //    "delivered" => "Delivered",
//                            //    "read" => "Read",
//                            //    _ => log.SendStatus
//                            //};

//                            //if (statusText == "delivered") log.DeliveredAt = time;
//                            //if (statusText == "read") log.ReadAt = time;

//                            //await _context.SaveChangesAsync();
//                            // üîÅ Avoid redundant updates
//                            var newStatus = statusText switch
//                            {
//                                "sent" => "Sent",
//                                "delivered" => "Delivered",
//                                "read" => "Read",
//                                _ => null
//                            };

//                            bool isUpdated = false;

//                            if (!string.IsNullOrEmpty(newStatus) && log.SendStatus != newStatus)
//                            {
//                                log.SendStatus = newStatus;
//                                isUpdated = true;
//                            }

//                            if (statusText == "delivered" && log.DeliveredAt == null)
//                            {
//                                log.DeliveredAt = time;
//                                isUpdated = true;
//                            }

//                            if (statusText == "read" && log.ReadAt == null)
//                            {
//                                log.ReadAt = time;
//                                isUpdated = true;
//                            }

//                            if (isUpdated)
//                            {
//                                await _context.SaveChangesAsync();
//                                _logger.LogInformation($"‚úÖ Log updated for MessageId: {messageId} ‚Üí {newStatus}");
//                            }
//                            else
//                            {
//                                _logger.LogInformation($"üîÅ Duplicate status '{statusText}' skipped for MessageId: {messageId}");
//                            }

//                            _logger.LogInformation($"‚úÖ Log updated for MessageId: {messageId} ‚Üí {statusText}");
//                        }
//                        else
//                        {
//                            _logger.LogWarning($"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}");
//                        }
//                    }
//                }
//            }
//        }

//    }
//}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\ClickWebhookProcessor.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.IO.Pipelines;
using System.Text.Json;
using System.Threading.Tasks;
using xbytechat.api;
using xbytechat.api.DTOs.Messages;
using xbytechat.api.Features.CampaignTracking.Models;
using xbytechat.api.Features.CTAFlowBuilder.Models;
using xbytechat.api.Features.CTAFlowBuilder.Services;
using xbytechat.api.Features.MessagesEngine.DTOs;
using xbytechat.api.Features.MessagesEngine.Services;
using xbytechat.api.Features.Tracking.DTOs;
using xbytechat.api.Features.Tracking.Models;
using xbytechat.api.Features.Tracking.Services;
using xbytechat.api.Features.Webhooks.Services.Resolvers;
using xbytechat.api.Helpers;
using xbytechat.api.Shared.TrackingUtils;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class ClickWebhookProcessor : IClickWebhookProcessor
    {
        private readonly ILogger<ClickWebhookProcessor> _logger;
        private readonly IMessageIdResolver _messageIdResolver;
        private readonly ITrackingService _trackingService;
        private readonly AppDbContext _context;
        private readonly IMessageEngineService _messageEngine;
        private readonly ICTAFlowService _flowService;
        private readonly IFlowRuntimeService _flowRuntime;
        public ClickWebhookProcessor(
            ILogger<ClickWebhookProcessor> logger,
            IMessageIdResolver messageIdResolver,
            ITrackingService trackingService,
            AppDbContext context,
            IMessageEngineService messageEngine,
            ICTAFlowService flowService,
                        IFlowRuntimeService flowRuntime
            )
        {
            _logger = logger;
            _messageIdResolver = messageIdResolver;
            _trackingService = trackingService;
            _context = context;
            _messageEngine = messageEngine;
            _flowService = flowService;
            _flowRuntime = flowRuntime;

        }


        #region Comeneted to add campignsendLogId
        #endregion
        //public async Task ProcessClickAsync(JsonElement value)
        //{
        //    _logger.LogWarning("üì• [ENTERED CLICK PROCESSOR]");

        //    try
        //    {
        //        if (!value.TryGetProperty("messages", out var messages) || messages.GetArrayLength() == 0)
        //            return;

        //        static string Norm(string? s)
        //        {
        //            if (string.IsNullOrWhiteSpace(s)) return string.Empty;
        //            return string.Join(' ', s.Split(new[] { ' ', '\t', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
        //                         .Trim()
        //                         .ToLowerInvariant();
        //        }

        //        foreach (var msg in messages.EnumerateArray())
        //        {
        //            if (!msg.TryGetProperty("type", out var typeProp))
        //                continue;

        //            var type = typeProp.GetString();

        //            string? clickMessageId = msg.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
        //            string? originalMessageId = msg.TryGetProperty("context", out var ctx) && ctx.TryGetProperty("id", out var ctxId)
        //                ? ctxId.GetString()
        //                : null;
        //            string from = msg.TryGetProperty("from", out var fromProp) ? (fromProp.GetString() ?? "") : "";

        //            // ‚Äî‚Äî‚Äî button label extraction
        //            string? buttonText = null;
        //            if (type == "button")
        //            {
        //                buttonText = msg.TryGetProperty("button", out var btn) &&
        //                             btn.TryGetProperty("text", out var textProp)
        //                               ? textProp.GetString()?.Trim()
        //                               : null;
        //            }
        //            else if (type == "interactive" && msg.TryGetProperty("interactive", out var interactive))
        //            {
        //                if (interactive.TryGetProperty("type", out var intrType) &&
        //                    string.Equals(intrType.GetString(), "button_reply", StringComparison.OrdinalIgnoreCase) &&
        //                    interactive.TryGetProperty("button_reply", out var br) &&
        //                    br.TryGetProperty("title", out var titleProp))
        //                {
        //                    buttonText = titleProp.GetString()?.Trim();
        //                }
        //                else if (interactive.TryGetProperty("list_reply", out var lr) &&
        //                         lr.TryGetProperty("title", out var listTitleProp))
        //                {
        //                    buttonText = listTitleProp.GetString()?.Trim();
        //                }
        //            }

        //            if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))
        //            {
        //                _logger.LogDebug("‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}", type);
        //                continue;
        //            }

        //            _logger.LogInformation("üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}",
        //                from, clickMessageId, originalMessageId, buttonText);

        //            // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)
        //            var origin = await _context.MessageLogs
        //                .AsNoTracking()
        //                .FirstOrDefaultAsync(m =>
        //                    m.MessageId == originalMessageId &&
        //                    m.CTAFlowConfigId != null &&
        //                    m.CTAFlowStepId != null);

        //            Guid businessId;
        //            Guid flowId;
        //            Guid stepId;
        //            string? bundleJson = null;
        //            int? flowVersion = null;

        //            if (origin != null)
        //            {
        //                businessId = origin.BusinessId;
        //                flowId = origin.CTAFlowConfigId!.Value;
        //                stepId = origin.CTAFlowStepId!.Value;
        //                bundleJson = origin.ButtonBundleJson;
        //                flowVersion = origin.FlowVersion;
        //            }
        //            else
        //            {
        //                // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)
        //                var sendLog = await _context.CampaignSendLogs
        //                    .Include(sl => sl.Campaign)
        //                    .AsNoTracking()
        //                    .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);

        //                if (sendLog == null)
        //                {
        //                    _logger.LogWarning("‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                businessId = sendLog.BusinessId != Guid.Empty
        //                    ? sendLog.BusinessId
        //                    : (sendLog.Campaign?.BusinessId ?? Guid.Empty);

        //                if (businessId == Guid.Empty)
        //                {
        //                    _logger.LogWarning("‚ùå Could not resolve BusinessId for WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)
        //                {
        //                    flowId = sendLog.CTAFlowConfigId.Value;
        //                    stepId = sendLog.CTAFlowStepId.Value;
        //                }
        //                else if (sendLog.Campaign?.CTAFlowConfigId != null)
        //                {
        //                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;

        //                    var entry = await _context.CTAFlowSteps
        //                        .Where(s => s.CTAFlowConfigId == flowId)
        //                        .OrderBy(s => s.StepOrder)
        //                        .Select(s => s.Id)
        //                        .FirstOrDefaultAsync();

        //                    if (entry == Guid.Empty)
        //                    {
        //                        _logger.LogWarning("‚ùå No entry step found for flow {Flow}", flowId);
        //                        continue;
        //                    }

        //                    stepId = entry;
        //                }
        //                else
        //                {
        //                    _logger.LogWarning("‚ùå No flow context on CampaignSendLog for WAMID {Orig}", originalMessageId);
        //                    continue;
        //                }

        //                bundleJson = sendLog.ButtonBundleJson;
        //            }

        //            // ‚Äî‚Äî Map clicked text -> button index via bundle
        //            short? buttonIndex = null;
        //            FlowBtnBundleNode? hit = null;

        //            if (!string.IsNullOrWhiteSpace(bundleJson))
        //            {
        //                try
        //                {
        //                    var nodes = System.Text.Json.JsonSerializer
        //                        .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();

        //                    hit = nodes.FirstOrDefault(n =>
        //                        string.Equals(n.t ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
        //                        ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));

        //                    if (hit != null)
        //                        buttonIndex = (short)hit.i;
        //                }
        //                catch (Exception ex)
        //                {
        //                    _logger.LogWarning(ex, "‚ö†Ô∏è Failed to parse ButtonBundleJson");
        //                }
        //            }

        //            // ‚Äî‚Äî Fallback: find link by TEXT for this step
        //            FlowButtonLink? linkMatchedByText = null;
        //            if (buttonIndex == null)
        //            {
        //                var stepLinks = await _context.FlowButtonLinks
        //                    .Where(l => l.CTAFlowStepId == stepId)
        //                    .OrderBy(l => l.ButtonIndex)
        //                    .ToListAsync();

        //                if (stepLinks.Count > 0)
        //                {
        //                    linkMatchedByText = stepLinks.FirstOrDefault(l =>
        //                        string.Equals(l.ButtonText ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
        //                        ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));

        //                    if (linkMatchedByText == null && stepLinks.Count == 1)
        //                    {
        //                        linkMatchedByText = stepLinks[0];
        //                        _logger.LogInformation("üü® Falling back to single available link for step {Step}", stepId);
        //                    }

        //                    if (linkMatchedByText != null)
        //                    {
        //                        buttonIndex = (short?)linkMatchedByText.ButtonIndex;
        //                        _logger.LogInformation("‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})",
        //                            buttonIndex, flowId, stepId);
        //                    }
        //                }
        //            }

        //            if (buttonIndex == null)
        //            {
        //                _logger.LogInformation("üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'",
        //                    originalMessageId, buttonText);
        //                continue;
        //            }

        //            // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link
        //            var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)
        //                       ?? linkMatchedByText;

        //            if (link == null)
        //            {
        //                _logger.LogInformation("üü° No button link for (flow={Flow}, step={Step}, idx={Idx})",
        //                    flowId, stepId, buttonIndex);
        //                continue;
        //            }

        //            // ‚Äî‚Äî SAFETY: resolve index type
        //            short linkIdx = link.ButtonIndex is short si ? si : Convert.ToInt16(link.ButtonIndex);
        //            short resolvedIndex = buttonIndex ?? linkIdx;

        //            // ‚Äî‚Äî If this is a terminal/URL button with no next step, DO NOT call the runtime
        //            if (link.NextStepId == null)
        //            {
        //                _logger.LogInformation("üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'",
        //                    flowId, stepId, resolvedIndex, link.ButtonText);

        //                // (optional) If you want to trigger URL redirect tracking here, call your tracker.
        //                // await _urlTracker.TrackAsync(...);

        //                continue;
        //            }

        //            if (_flowRuntime == null)
        //            {
        //                _logger.LogError("‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}", flowId, stepId, resolvedIndex);
        //                continue;
        //            }

        //            // ‚Äî‚Äî Execute next
        //            var ctxObj = new NextStepContext
        //            {
        //                BusinessId = businessId,
        //                FlowId = flowId,
        //                Version = flowVersion ?? 1,
        //                SourceStepId = stepId,
        //                TargetStepId = link.NextStepId,   // not null here
        //                ButtonIndex = resolvedIndex,
        //                MessageLogId = origin?.Id ?? Guid.Empty,
        //                ContactPhone = from,
        //                RequestId = Guid.NewGuid(),
        //                ClickedButton = link
        //            };

        //            try
        //            {
        //                var result = await _flowRuntime.ExecuteNextAsync(ctxObj);

        //                if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))
        //                {
        //                    _logger.LogInformation("üîó URL button redirect (logical): {Url}", result.RedirectUrl);
        //                }
        //            }
        //            catch (Exception exRun)
        //            {
        //                _logger.LogError(exRun,
        //                    "‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'",
        //                    ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, from, originalMessageId, buttonText);
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "‚ùå Failed to process CTA button click.");
        //    }
        //}

        // matches the compact bundle we store (i,t,ty,v,ns)

        public async Task ProcessClickAsync(JsonElement value)
        {
            _logger.LogWarning("üì• [ENTERED CLICK PROCESSOR]");

            try
            {
                if (!value.TryGetProperty("messages", out var messages) || messages.GetArrayLength() == 0)
                    return;

                static string Norm(string? s)
                {
                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;
                    return string.Join(' ', s.Split(new[] { ' ', '\t', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                                 .Trim()
                                 .ToLowerInvariant();
                }

                static string NormalizePhone(string? raw)
                {
                    if (string.IsNullOrWhiteSpace(raw)) return "";
                    var p = raw.Trim();
                    return p.StartsWith("+") ? p.Substring(1) : p; // store digits-only (or pick one convention)
                }

                foreach (var msg in messages.EnumerateArray())
                {
                    if (!msg.TryGetProperty("type", out var typeProp))
                        continue;

                    var type = typeProp.GetString();

                    string? clickMessageId = msg.TryGetProperty("id", out var idProp) ? idProp.GetString() : null;
                    string? originalMessageId = msg.TryGetProperty("context", out var ctx) && ctx.TryGetProperty("id", out var ctxId)
                        ? ctxId.GetString()
                        : null;
                    string from = msg.TryGetProperty("from", out var fromProp) ? (fromProp.GetString() ?? "") : "";

                    // ‚Äî‚Äî‚Äî button label extraction
                    string? buttonText = null;
                    if (type == "button")
                    {
                        buttonText = msg.TryGetProperty("button", out var btn) &&
                                     btn.TryGetProperty("text", out var textProp)
                                       ? textProp.GetString()?.Trim()
                                       : null;
                    }
                    else if (type == "interactive" && msg.TryGetProperty("interactive", out var interactive))
                    {
                        if (interactive.TryGetProperty("type", out var intrType) &&
                            string.Equals(intrType.GetString(), "button_reply", StringComparison.OrdinalIgnoreCase) &&
                            interactive.TryGetProperty("button_reply", out var br) &&
                            br.TryGetProperty("title", out var titleProp))
                        {
                            buttonText = titleProp.GetString()?.Trim();
                        }
                        else if (interactive.TryGetProperty("list_reply", out var lr) &&
                                 lr.TryGetProperty("title", out var listTitleProp))
                        {
                            buttonText = listTitleProp.GetString()?.Trim();
                        }
                    }

                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))
                    {
                        _logger.LogDebug("‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}", type);
                        continue;
                    }

                    _logger.LogInformation("üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}",
                        from, clickMessageId, originalMessageId, buttonText);

                    // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)
                    var origin = await _context.MessageLogs
                        .AsNoTracking()
                        .FirstOrDefaultAsync(m =>
                            m.MessageId == originalMessageId &&
                            m.CTAFlowConfigId != null &&
                            m.CTAFlowStepId != null);

                    Guid businessId;
                    Guid flowId;
                    Guid stepId;
                    string? bundleJson = null;
                    int? flowVersion = null;

                    Guid? campaignSendLogId = null; // üëà we will always try to set this
                    Guid? runId = null;             // üëà NEW: will copy from the parent CSL

                    if (origin != null)
                    {
                        businessId = origin.BusinessId;
                        flowId = origin.CTAFlowConfigId!.Value;
                        stepId = origin.CTAFlowStepId!.Value;
                        bundleJson = origin.ButtonBundleJson;
                        flowVersion = origin.FlowVersion;

                        // map back to CSL via MessageLogId or WAMID and fetch RunId
                        var cslInfo = await _context.CampaignSendLogs
                            .AsNoTracking()
                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))
                            .OrderByDescending(csl => csl.CreatedAt)
                            .Select(csl => new { csl.Id, csl.RunId })
                            .FirstOrDefaultAsync();

                        campaignSendLogId = cslInfo?.Id;
                        runId = cslInfo?.RunId;
                    }
                    else
                    {
                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)
                        var sendLog = await _context.CampaignSendLogs
                            .Include(sl => sl.Campaign)
                            .AsNoTracking()
                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);

                        if (sendLog == null)
                        {
                            _logger.LogWarning("‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        businessId = sendLog.BusinessId != Guid.Empty
                            ? sendLog.BusinessId
                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);

                        if (businessId == Guid.Empty)
                        {
                            _logger.LogWarning("‚ùå Could not resolve BusinessId for WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        campaignSendLogId = sendLog.Id; // üëà link the click to this send
                        runId = sendLog.RunId;          // üëà NEW: capture the run id

                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)
                        {
                            flowId = sendLog.CTAFlowConfigId.Value;
                            stepId = sendLog.CTAFlowStepId.Value;
                        }
                        else if (sendLog.Campaign?.CTAFlowConfigId != null)
                        {
                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;

                            var entry = await _context.CTAFlowSteps
                                .Where(s => s.CTAFlowConfigId == flowId)
                                .OrderBy(s => s.StepOrder)
                                .Select(s => s.Id)
                                .FirstOrDefaultAsync();

                            if (entry == Guid.Empty)
                            {
                                _logger.LogWarning("‚ùå No entry step found for flow {Flow}", flowId);
                                continue;
                            }

                            stepId = entry;
                        }
                        else
                        {
                            _logger.LogWarning("‚ùå No flow context on CampaignSendLog for WAMID {Orig}", originalMessageId);
                            continue;
                        }

                        bundleJson = sendLog.ButtonBundleJson;
                    }

                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle
                    short? buttonIndex = null;
                    FlowBtnBundleNode? hit = null;

                    if (!string.IsNullOrWhiteSpace(bundleJson))
                    {
                        try
                        {
                            var nodes = System.Text.Json.JsonSerializer
                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();

                            hit = nodes.FirstOrDefault(n =>
                                string.Equals(n.t ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
                                ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));

                            if (hit != null)
                                buttonIndex = (short)hit.i;
                        }
                        catch (Exception ex)
                        {
                            _logger.LogWarning(ex, "‚ö†Ô∏è Failed to parse ButtonBundleJson");
                        }
                    }

                    // ‚Äî‚Äî Fallback: find link by TEXT for this step
                    FlowButtonLink? linkMatchedByText = null;
                    if (buttonIndex == null)
                    {
                        var stepLinks = await _context.FlowButtonLinks
                            .Where(l => l.CTAFlowStepId == stepId)
                            .OrderBy(l => l.ButtonIndex)
                            .ToListAsync();

                        if (stepLinks.Count > 0)
                        {
                            linkMatchedByText = stepLinks.FirstOrDefault(l =>
                                string.Equals(l.ButtonText ?? "", buttonText, StringComparison.OrdinalIgnoreCase))
                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));

                            if (linkMatchedByText == null && stepLinks.Count == 1)
                            {
                                linkMatchedByText = stepLinks[0];
                                _logger.LogInformation("üü® Falling back to single available link for step {Step}", stepId);
                            }

                            if (linkMatchedByText != null)
                            {
                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;
                                _logger.LogInformation("‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})",
                                    buttonIndex, flowId, stepId);
                            }
                        }
                    }

                    if (buttonIndex == null)
                    {
                        _logger.LogInformation("üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'",
                            originalMessageId, buttonText);
                        continue;
                    }

                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link
                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)
                               ?? linkMatchedByText;

                    if (link == null)
                    {
                        _logger.LogInformation("üü° No button link for (flow={Flow}, step={Step}, idx={Idx})",
                            flowId, stepId, buttonIndex);
                        continue;
                    }

                    // ‚Äî‚Äî Resolve index + step name (for logging)
                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);
                    var stepName = await _context.CTAFlowSteps
                        .Where(s => s.Id == stepId)
                        .Select(s => s.TemplateToSend)
                        .FirstOrDefaultAsync() ?? string.Empty;

                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
                    // üìù WRITE CLICK LOG (always, even if terminal)
                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
                    try
                    {
                        var clickExec = new FlowExecutionLog
                        {
                            Id = Guid.NewGuid(),
                            BusinessId = businessId,
                            FlowId = flowId,
                            StepId = stepId,
                            StepName = stepName,
                            CampaignSendLogId = campaignSendLogId,  // links this click to the shown message
                            MessageLogId = origin?.Id,
                            ContactPhone = NormalizePhone(from),
                            ButtonIndex = resolvedIndex,
                            TriggeredByButton = buttonText,
                            TemplateName = null,                    // will be set by runtime on send (if you also log sends)
                            TemplateType = "quick_reply",
                            Success = true,
                            ExecutedAt = DateTime.UtcNow,
                            RequestId = Guid.NewGuid(),
                            RunId = runId                           // üëà NEW: copy parent CSL's RunId
                        };

                        _context.FlowExecutionLogs.Add(clickExec);
                        await _context.SaveChangesAsync();
                    }
                    catch (Exception exSave)
                    {
                        _logger.LogWarning(exSave, "‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶");
                    }

                    // ‚Äî‚Äî If terminal/URL button: we already logged the click; optionally log CampaignClickLog here
                    if (link.NextStepId == null)
                    {
                        _logger.LogInformation("üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'",
                            flowId, stepId, resolvedIndex, link.ButtonText);

                        // OPTIONAL: if you log URL clicks here (instead of your redirect endpoint), include RunId too:
                        // _context.CampaignClickLogs.Add(new CampaignClickLog {
                        //     Id = Guid.NewGuid(),
                        //     CampaignSendLogId = campaignSendLogId!.Value,
                        //     ButtonIndex = resolvedIndex,
                        //     ButtonTitle = buttonText,
                        //     Destination = "<resolved-url-if-known>",
                        //     ClickedAt = DateTime.UtcNow,
                        //     RunId = runId                               // üëà include
                        // });
                        // await _context.SaveChangesAsync();

                        continue;
                    }

                    if (_flowRuntime == null)
                    {
                        _logger.LogError("‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}", flowId, stepId, resolvedIndex);
                        continue;
                    }

                    // ‚Äî‚Äî Execute next
                    var ctxObj = new NextStepContext
                    {
                        BusinessId = businessId,
                        FlowId = flowId,
                        Version = flowVersion ?? 1,
                        SourceStepId = stepId,
                        TargetStepId = link.NextStepId,   // not null here
                        ButtonIndex = resolvedIndex,
                        MessageLogId = origin?.Id ?? Guid.Empty,
                        ContactPhone = from,
                        RequestId = Guid.NewGuid(),
                        ClickedButton = link
                        // If your NextStepContext supports it, also pass RunId = runId
                    };

                    try
                    {
                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);

                        // ‚ö†Ô∏è Make sure your flow send path copies the parent CSL.RunId
                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))
                        {
                            _logger.LogInformation("üîó URL button redirect (logical): {Url}", result.RedirectUrl);
                        }
                    }
                    catch (Exception exRun)
                    {
                        _logger.LogError(exRun,
                            "‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'",
                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, from, originalMessageId, buttonText);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process CTA button click.");
            }
        }

        private sealed class FlowBtnBundleNode
        {
            public int i { get; init; }
            public string? t { get; init; }   // button text/title
            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)
            public string? v { get; init; }   // value/payload (e.g., URL)
            public Guid? ns { get; init; }    // next step id
        }


        // matches the compact bundle structure saved in MessageLog.ButtonBundleJson


    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IClickWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IClickWebhookProcessor
    {
        Task ProcessClickAsync(JsonElement value);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IInboundMessageProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IInboundMessageProcessor
    {
        Task ProcessChatAsync(JsonElement value);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\InboundMessageProcessor.cs 
====================================================== 
 
Ôªøusing System;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using xbytechat.api;
using xbytechat.api.Features.Inbox.DTOs;
using xbytechat.api.CRM.Models;
using xbytechat.api.Features.Inbox.Hubs;
using Microsoft.Extensions.DependencyInjection;
using xbytechat.api.CRM.Interfaces;
using xbytechat.api.Features.AutoReplyBuilder.Services;
using xbytechat.api.Features.Inbox.Services;
using xbytechat.api.Features.MessagesEngine.DTOs;
using xbytechat.api.Features.MessagesEngine.Services;
using xbytechat.api.CRM.Services;
using xbytechat.api.Features.Automation.Services;


namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class InboundMessageProcessor : IInboundMessageProcessor
    {
        private readonly AppDbContext _context;
        private readonly IHubContext<InboxHub> _hubContext;
        private readonly ILogger<InboundMessageProcessor> _logger;
        private readonly IInboxService _inboxService;
        private readonly IServiceScopeFactory _serviceScopeFactory;
        public InboundMessageProcessor(
            AppDbContext context,
            IHubContext<InboxHub> hubContext,
            ILogger<InboundMessageProcessor> logger,
            IInboxService inboxService,
            IServiceScopeFactory serviceScopeFactory)
        {
            _context = context;
            _hubContext = hubContext;
            _logger = logger;
            _inboxService = inboxService;
            _serviceScopeFactory = serviceScopeFactory;
        }



        
        public async Task ProcessChatAsync(JsonElement value)
        {
            try
            {
                using var scope = _serviceScopeFactory.CreateScope();
                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();
                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();
                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();
                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();

                // ‚úÖ 1. Extract WhatsApp metadata and message
                var msg = value.GetProperty("messages")[0];
                var contactPhone = msg.GetProperty("from").GetString()!;
                var content = msg.GetProperty("text").GetProperty("body").GetString();
                var businessNumber = value.GetProperty("metadata").GetProperty("display_phone_number").GetString()!;

                // ‚úÖ 2. Resolve business by WhatsApp number
                var business = await db.Businesses
                    .Include(b => b.WhatsAppSettings)
                    .FirstOrDefaultAsync(b => b.WhatsAppSettings.WhatsAppBusinessNumber == businessNumber);

                if (business == null)
                {
                    logger.LogWarning("‚ùå Business not found for WhatsApp number: {Number}", businessNumber);
                    return;
                }

                var businessId = business.Id;

                // ‚úÖ 3. Find or create contact
                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);
                if (contact == null)
                {
                    logger.LogWarning("‚ùå Could not resolve contact for phone: {Phone}", contactPhone);
                    return;
                }

                // ‚úÖ 4. Check chat mode (skip inbox sync if not agent)
                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);
                var isAgentMode = mode == "agent";

                // ‚úÖ 5. Log incoming message
                var messageLog = new MessageLog
                {
                    Id = Guid.NewGuid(),
                    BusinessId = businessId,
                    ContactId = contact.Id,
                    RecipientNumber = contactPhone,
                    MessageContent = content,
                    Status = "received",
                    CreatedAt = DateTime.UtcNow,
                    SentAt = DateTime.UtcNow,
                    IsIncoming = true
                };

                db.MessageLogs.Add(messageLog);
                await db.SaveChangesAsync();

                // ‚úÖ 6. Try to trigger automation by keyword
                try
                {
                    var triggerKeyword = content.Trim().ToLower();
                    var handled = await automationService.TryRunFlowByKeywordAsync(
                        businessId,
                        triggerKeyword,
                        contact.PhoneNumber,
                        sourceChannel: "whatsapp",
                        industryTag: "default"
                    );

                    if (!handled)
                    {
                        logger.LogInformation("üïµÔ∏è No automation flow matched keyword: {Keyword}", triggerKeyword);
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "‚ùå Automation flow execution failed.");
                }

                // ‚úÖ 7. Only sync to inbox if chat mode is agent
                if (isAgentMode)
                {
                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();
                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto
                    {
                        BusinessId = businessId,
                        ContactId = contact.Id,
                        RecipientPhone = contact.PhoneNumber,
                        MessageBody = messageLog.MessageContent,
                        IsIncoming = true,
                        Status = messageLog.Status,
                        SentAt = messageLog.CreatedAt
                    });

                    logger.LogInformation("üì• Message synced to inbox for contact {Phone}", contactPhone);
                }
                else
                {
                    logger.LogInformation("üö´ Skipping inbox sync: chat mode is not 'agent'");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process inbound WhatsApp chat.");
            }
        }


    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\IStatusWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface IStatusWebhookProcessor
    {
        Task ProcessStatusUpdateAsync(JsonElement payload);

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\ITemplateWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System.Text.Json;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public interface ITemplateWebhookProcessor
    {
        Task ProcessTemplateUpdateAsync(JsonElement payload);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\StatusWebhookProcessor.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Text.Json;
using System.Threading.Tasks;

// üëá where your AppDbContext lives
using xbytechat.api;

using xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog
using xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog
using xbytechat.api.Features.Webhooks.Services.Resolvers;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    /// <summary>
    /// Legacy status processor (back-compat).
    /// - Extracts statuses from the payload
    /// - Resolves CampaignSendLog via IMessageIdResolver when possible
    /// - Updates CampaignSendLog / MessageLog idempotently
    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.
    /// </summary>
    public class StatusWebhookProcessor : IStatusWebhookProcessor
    {
        private readonly AppDbContext _context;
        private readonly ILogger<StatusWebhookProcessor> _logger;
        private readonly IMessageIdResolver _messageIdResolver;

        public StatusWebhookProcessor(
            AppDbContext context,
            ILogger<StatusWebhookProcessor> logger,
            IMessageIdResolver messageIdResolver)
        {
            _context = context;
            _logger = logger;
            _messageIdResolver = messageIdResolver;
        }

        /// <summary>
        /// Entry point from dispatcher (legacy path).
        /// Normalizes Meta envelope to a "value" object, then processes.
        /// </summary>
        public async Task ProcessStatusUpdateAsync(JsonElement payload)
        {
            _logger.LogDebug("status_webhook_in (legacy) \n{Payload}", payload.ToString());

            // 1) Envelope ‚Üí value
            if (TryExtractValue(payload, out var value))
            {
                await ProcessAsync(value);
                return;
            }

            // 2) Already value-like (adapter flattened)
            if (payload.ValueKind == JsonValueKind.Object &&
                (payload.TryGetProperty("statuses", out _) || payload.TryGetProperty("messages", out _)))
            {
                await ProcessAsync(payload);
                return;
            }

            _logger.LogWarning("Unrecognized status payload shape (legacy path).");
        }

        /// <summary>
        /// Extract statuses from a Meta-like "value" object and update DB.
        /// </summary>
        public async Task ProcessAsync(JsonElement value)
        {
            if (!value.TryGetProperty("statuses", out var statuses) || statuses.ValueKind != JsonValueKind.Array)
            {
                _logger.LogWarning("‚ö†Ô∏è 'statuses' array missing in webhook payload (legacy path).");
                return;
            }

            foreach (var status in statuses.EnumerateArray())
            {
                if (status.ValueKind != JsonValueKind.Object) continue;

                // message id (WAMID)
                var messageId = status.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String
                    ? idEl.GetString()
                    : null;

                // status text
                var statusText = status.TryGetProperty("status", out var stEl) && stEl.ValueKind == JsonValueKind.String
                    ? stEl.GetString()
                    : null;

                if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))
                {
                    _logger.LogWarning("‚ö†Ô∏è Missing messageId or status in webhook payload (legacy path).");
                    continue;
                }

                // timestamp (string or number)
                DateTime? eventTime = null;
                if (status.TryGetProperty("timestamp", out var tsEl))
                {
                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))
                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;
                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))
                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;
                }

                _logger.LogDebug("üïì Parsed timestamp: {Time} (raw kind={Kind})",
                    eventTime?.ToString("o") ?? "n/a", status.TryGetProperty("timestamp", out var tsDbg) ? tsDbg.ValueKind.ToString() : "n/a");

                // ‚úÖ First try resolving a CampaignSendLog row via resolver
                Guid? sendLogId = null;
                try
                {
                    sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "MessageId resolver failed for {MessageId}", messageId);
                }

                if (sendLogId is Guid sid)
                {
                    var log = await _context.Set<CampaignSendLog>()
                                            .FirstOrDefaultAsync(l => l.Id == sid);

                    if (log != null)
                    {
                        bool changed = false;

                        var newStatus = MapMetaStatus(statusText);
                        if (!string.IsNullOrEmpty(newStatus) &&
                            !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))
                        {
                            log.SendStatus = newStatus;
                            changed = true;
                        }

                        if (statusText == "sent" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)
                        {
                            log.SentAt = eventTime.Value;
                            changed = true;
                        }
                        if (statusText == "delivered" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)
                        {
                            log.DeliveredAt = eventTime.Value;
                            changed = true;
                        }
                        if (statusText == "read" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)
                        {
                            log.ReadAt = eventTime.Value;
                            changed = true;
                        }

                        if (changed)
                        {
                            await _context.SaveChangesAsync();
                            _logger.LogInformation("‚úÖ CampaignSendLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}", messageId, newStatus ?? statusText);
                        }
                        else
                        {
                            _logger.LogInformation("üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)", statusText, messageId);
                        }

                        continue; // done with this status item
                    }
                }

                // üîÅ Fallback: update MessageLog when there‚Äôs no CampaignSendLog
                var msg = await _context.Set<MessageLog>()
                                        .FirstOrDefaultAsync(m => m.MessageId == messageId);

                if (msg != null)
                {
                    bool changed = false;

                    switch (statusText)
                    {
                        case "sent":
                            if (!EqualsIgnoreCase(msg.Status, "Sent"))
                            {
                                msg.Status = "Sent";
                                changed = true;
                            }
                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
                            {
                                msg.SentAt = eventTime.Value;
                                changed = true;
                            }
                            break;

                        case "delivered":
                            // no DeliveredAt column on MessageLog; just progression
                            if (!EqualsIgnoreCase(msg.Status, "Read") &&
                                !EqualsIgnoreCase(msg.Status, "Delivered"))
                            {
                                msg.Status = "Delivered";
                                changed = true;
                            }
                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
                            {
                                msg.SentAt = eventTime.Value; // ensure SentAt eventually set
                                changed = true;
                            }
                            break;

                        case "read":
                            if (!EqualsIgnoreCase(msg.Status, "Read"))
                            {
                                msg.Status = "Read";
                                changed = true;
                            }
                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)
                            {
                                msg.SentAt = eventTime.Value;
                                changed = true;
                            }
                            break;

                        default:
                            // leave as-is for unknown statuses
                            break;
                    }

                    if (changed)
                    {
                        await _context.SaveChangesAsync();
                        _logger.LogInformation("‚ÑπÔ∏è MessageLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}", messageId, msg.Status);
                    }
                    else
                    {
                        _logger.LogInformation("üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)", statusText, messageId);
                    }
                }
                else
                {
                    // lower severity; common when a send failed before obtaining a message id
                    _logger.LogInformation("‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)", messageId);
                }
            }
        }

        // ----------------- helpers -----------------

        private static bool TryExtractValue(JsonElement payload, out JsonElement value)
        {
            value = default;
            if (payload.ValueKind != JsonValueKind.Object) return false;
            if (!payload.TryGetProperty("entry", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;

            var e0 = entry[0];
            if (!e0.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;

            var c0 = changes[0];
            if (!c0.TryGetProperty("value", out var v) || v.ValueKind != JsonValueKind.Object) return false;

            value = v;
            return true;
        }

        private static string? MapMetaStatus(string? s) =>
            (s ?? "").ToLowerInvariant() switch
            {
                "sent" => "Sent",
                "delivered" => "Delivered",
                "read" => "Read",
                "failed" => "Failed",
                "deleted" => "Deleted",
                _ => null
            };

        private static bool EqualsIgnoreCase(string? a, string? b) =>
            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
    }
}


//using Microsoft.EntityFrameworkCore;
//using Microsoft.Extensions.Logging;
//using System;
//using System.Text.Json;
//using System.Threading.Tasks;
//using xbytechat.api.Features.CampaignTracking.Models;
//using xbytechat.api.Features.Webhooks.Services.Resolvers;

//namespace xbytechat.api.Features.Webhooks.Services.Processors
//{
//    public class StatusWebhookProcessor : IStatusWebhookProcessor
//    {
//        private readonly AppDbContext _context;
//        private readonly ILogger<StatusWebhookProcessor> _logger;
//        private readonly IMessageIdResolver _messageIdResolver;

//        public StatusWebhookProcessor(
//            AppDbContext context,
//            ILogger<StatusWebhookProcessor> logger,
//            IMessageIdResolver messageIdResolver)
//        {
//            _context = context;
//            _logger = logger;
//            _messageIdResolver = messageIdResolver;
//        }

//        // üîÑ Extract statuses from the payload and route them to log resolver
//        public async Task ProcessAsync(JsonElement value)
//        {
//            if (!value.TryGetProperty("statuses", out var statuses))
//            {
//                _logger.LogWarning("‚ö†Ô∏è 'statuses' field missing in webhook payload.");
//                return;
//            }

//            foreach (var status in statuses.EnumerateArray())
//            {
//                var messageId = status.GetProperty("id").GetString();
//                var statusText = status.GetProperty("status").GetString();

//                // timestamp parsing (works for string or number)
//                long unix = 0;
//                JsonValueKind? tsKind = null;
//                if (status.TryGetProperty("timestamp", out var ts))
//                {
//                    tsKind = ts.ValueKind;
//                    if (ts.ValueKind == JsonValueKind.String && long.TryParse(ts.GetString(), out var parsed))
//                        unix = parsed;
//                    else if (ts.ValueKind == JsonValueKind.Number)
//                        unix = ts.GetInt64();
//                }
//                var time = unix > 0
//                    ? DateTimeOffset.FromUnixTimeSeconds(unix).UtcDateTime
//                    : DateTime.UtcNow;

//                _logger.LogDebug("üïì Parsed timestamp(s): {Unix} kind={Kind}", unix, tsKind?.ToString() ?? "n/a");

//                // ‚úÖ First try resolving a CampaignSendLog row via resolver
//                var logId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);

//                if (logId != null)
//                {
//                    var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId.Value);
//                    if (log != null)
//                    {
//                        // Normalize statuses to your app's values
//                        log.SendStatus = statusText switch
//                        {
//                            "sent" => "Sent",
//                            "delivered" => "Delivered",
//                            "read" => "Read",
//                            _ => log.SendStatus
//                        };

//                        if (statusText == "delivered") log.DeliveredAt = time;
//                        if (statusText == "read") log.ReadAt = time;
//                        // If provider reports "sent" late and we missed SentAt, keep it consistent
//                        if (statusText == "sent" && log.SentAt == null) log.SentAt = time;

//                        await _context.SaveChangesAsync();
//                        _logger.LogInformation("‚úÖ CampaignSendLog updated for MessageId: {MessageId} ‚Üí {Status}", messageId, statusText);
//                        continue; // done with this status item
//                    }
//                }

//                // üîÅ Fallback: update MessageLogs (flow-driven sends) when there's no CampaignSendLog
//                var msg = await _context.MessageLogs.FirstOrDefaultAsync(m => m.MessageId == messageId);
//                if (msg != null)
//                {
//                    switch (statusText)
//                    {
//                        case "sent":
//                            msg.Status = "Sent";
//                            msg.SentAt ??= time;
//                            break;
//                        case "delivered":
//                            msg.Status = "Delivered";
//                            // keep SentAt if it was not set for some reason
//                            msg.SentAt ??= time;
//                            break;
//                        case "read":
//                            msg.Status = "Read";
//                            msg.SentAt ??= time;
//                            break;
//                        default:
//                            // leave as-is for unknown statuses
//                            break;
//                    }

//                    await _context.SaveChangesAsync();
//                    _logger.LogInformation("‚ÑπÔ∏è MessageLog updated for MessageId: {MessageId} ‚Üí {Status}", messageId, statusText);
//                }
//                else
//                {
//                    // lower severity; common when a send failed before obtaining a message id
//                    _logger.LogInformation("‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId}", messageId);
//                }
//            }
//        }


//        //public async Task ProcessStatusUpdateAsync(JsonElement payload)
//        //{
//        //    _logger.LogDebug("status_webhook_in");

//        //    if (payload.ValueKind == JsonValueKind.Object &&
//        //        payload.TryGetProperty("entry", out var entry) &&
//        //        entry.ValueKind == JsonValueKind.Array && entry.GetArrayLength() > 0 &&
//        //        entry[0].TryGetProperty("changes", out var changes) &&
//        //        changes.ValueKind == JsonValueKind.Array && changes.GetArrayLength() > 0 &&
//        //        changes[0].TryGetProperty("value", out var valueFromEnvelope) &&
//        //        valueFromEnvelope.ValueKind == JsonValueKind.Object)
//        //    {
//        //        await ProcessAsync(valueFromEnvelope);
//        //        return;
//        //    }

//        //    if (payload.ValueKind == JsonValueKind.Object &&
//        //        (payload.TryGetProperty("statuses", out _) || payload.TryGetProperty("messages", out _)))
//        //    {
//        //        await ProcessAsync(payload);
//        //        return;
//        //    }

//        //    _logger.LogWarning("Unrecognized status payload shape.");
//        //}

//        public async Task ProcessStatusUpdateAsync(JsonElement payload)
//        {
//            _logger.LogDebug("status_webhook_in");

//            // 1) Normalize to "value" object when envelope present
//            if (TryExtractValue(payload, out var value))
//            {
//                // If there are statuses and we can resolve tenant+provider, use the unified updater
//                if (value.TryGetProperty("statuses", out var statuses) && statuses.ValueKind == JsonValueKind.Array)
//                {
//                    if (await TryResolveProviderAndBusinessIdAsync(payload, value) is (string provider, Guid businessId))
//                    {
//                        await HandleStatusesWithUpdaterAsync(businessId, provider, statuses);
//                        return; // handled via unified updater; clicks/messages remain unchanged below
//                    }
//                }

//                // Fallback to your existing handler (non-breaking)
//                await ProcessAsync(value);
//                return;
//            }

//            // 2) Already a value-like object (adapter might have provided directly)
//            if (payload.ValueKind == JsonValueKind.Object &&
//                (payload.TryGetProperty("statuses", out _) || payload.TryGetProperty("messages", out _)))
//            {
//                // Same attempt: updater first when possible
//                if (payload.TryGetProperty("statuses", out var statuses2) && statuses2.ValueKind == JsonValueKind.Array)
//                {
//                    if (await TryResolveProviderAndBusinessIdAsync(payload, payload) is (string provider2, Guid biz2))
//                    {
//                        await HandleStatusesWithUpdaterAsync(biz2, provider2, statuses2);
//                        return;
//                    }
//                }

//                // Fallback to existing behavior
//                await ProcessAsync(payload);
//                return;
//            }

//            _logger.LogWarning("Unrecognized status payload shape.");
//        }

//        #region helpers (local to this class)

//        private static bool TryExtractValue(JsonElement payload, out JsonElement value)
//        {
//            value = default;
//            if (payload.ValueKind != JsonValueKind.Object) return false;
//            if (!payload.TryGetProperty("entry", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;
//            var e0 = entry[0];
//            if (!e0.TryGetProperty("changes", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;
//            var c0 = changes[0];
//            if (!c0.TryGetProperty("value", out var v) || v.ValueKind != JsonValueKind.Object) return false;
//            value = v;
//            return true;
//        }

//        /// <summary>
//        /// Best-effort provider + tenant resolution:
//        /// - Meta: from value.metadata.phone_number_id (uses IMetaTenantResolver)
//        /// - Pinnacle: if adapter stamped provider, or if account fields exist (optional future hook)
//        /// Returns (provider, businessId) when resolvable; else null.
//        /// </summary>
//        private async Task<(string provider, Guid businessId)?> TryResolveProviderAndBusinessIdAsync(JsonElement envelopeOrValue, JsonElement value)
//        {
//            // Heuristic #1: Meta envelope => provider = meta_cloud
//            if (value.TryGetProperty("metadata", out var md) && md.ValueKind == JsonValueKind.Object &&
//                md.TryGetProperty("phone_number_id", out var pnEl) && pnEl.ValueKind == JsonValueKind.String)
//            {
//                var provider = "meta_cloud";
//                var phoneNumberId = pnEl.GetString();
//                try
//                {
//                    if (!string.IsNullOrWhiteSpace(phoneNumberId) && _metaTenantResolver != null)
//                    {
//                        var biz = await _metaTenantResolver.ResolveBusinessIdAsync(envelopeOrValue);
//                        if (biz.HasValue) return (provider, biz.Value);
//                    }
//                }
//                catch (Exception ex)
//                {
//                    _logger.LogWarning(ex, "Tenant resolve failed for Meta phone_number_id.");
//                }
//            }

//            // Heuristic #2: Adapter stamped provider (optional; add this in your adapter if not present)
//            // e.g., payload["provider"] = "pinnacle" or value["provider"] = "pinnacle"
//            string? providerHint = null;
//            if (envelopeOrValue.TryGetProperty("provider", out var prov1) && prov1.ValueKind == JsonValueKind.String)
//                providerHint = prov1.GetString();
//            else if (value.TryGetProperty("provider", out var prov2) && prov2.ValueKind == JsonValueKind.String)
//                providerHint = prov2.GetString();

//            if (!string.IsNullOrWhiteSpace(providerHint))
//            {
//                // If you have a Pinnacle tenant resolver, plug it here (account/sender id ‚Üí BusinessId).
//                // Without a resolver, return null to fall back.
//                // Example (pseudo):
//                // if (string.Equals(providerHint, "pinnacle", StringComparison.OrdinalIgnoreCase))
//                // {
//                //     var accountId = TryExtractAccountId(value);
//                //     var biz = await _pinnacleTenantResolver.ResolveAsync(accountId);
//                //     if (biz.HasValue) return ("pinnacle", biz.Value);
//                // }
//            }

//            return null;
//        }

//        private async Task HandleStatusesWithUpdaterAsync(Guid businessId, string provider, JsonElement statuses)
//        {
//            for (int i = 0; i < statuses.GetArrayLength(); i++)
//            {
//                var s = statuses[i];
//                if (s.ValueKind != JsonValueKind.Object) continue;

//                // id (provider message id)
//                string? msgId = null;
//                if (s.TryGetProperty("id", out var idEl) && idEl.ValueKind == JsonValueKind.String)
//                    msgId = idEl.GetString();

//                // status (string)
//                string? rawStatus = null;
//                if (s.TryGetProperty("status", out var stEl) && stEl.ValueKind == JsonValueKind.String)
//                    rawStatus = stEl.GetString();

//                // timestamp (epoch seconds in string commonly)
//                DateTimeOffset? eventTime = null;
//                if (s.TryGetProperty("timestamp", out var tsEl))
//                {
//                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epoch))
//                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epoch);
//                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochNum))
//                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochNum);
//                }

//                if (string.IsNullOrWhiteSpace(msgId) || string.IsNullOrWhiteSpace(rawStatus))
//                    continue;

//                await _statusUpdater.UpdateAsync(new xbytechat.api.Features.Webhooks.Status.UpdateMessageStatusRequest
//                {
//                    BusinessId = businessId,
//                    Provider = provider,
//                    MessageId = msgId!,
//                    RawStatus = rawStatus!,
//                    EventTime = eventTime,
//                    RawPayloadJson = s.GetRawText()
//                });
//            }
//        }

//        #endregion


//    }
//}


////using Microsoft.EntityFrameworkCore;
////using Microsoft.Extensions.Logging;
////using System;
////using System.Text.Json;
////using System.Threading.Tasks;
////using xbytechat.api.Features.CampaignTracking.Models;
////using xbytechat.api.Features.Webhooks.Services.Resolvers;

////namespace xbytechat.api.Features.Webhooks.Services.Processors
////{
////    public class StatusWebhookProcessor : IStatusWebhookProcessor
////    {
////        private readonly AppDbContext _context;
////        private readonly ILogger<StatusWebhookProcessor> _logger;
////        private readonly IMessageIdResolver _messageIdResolver; // ‚úÖ Injected resolver

////        public StatusWebhookProcessor(
////            AppDbContext context,
////            ILogger<StatusWebhookProcessor> logger,
////            IMessageIdResolver messageIdResolver) // ‚úÖ Accept resolver in constructor
////        {
////            _context = context;
////            _logger = logger;
////            _messageIdResolver = messageIdResolver;
////        }

////        // üîÑ Extract statuses from the payload and route them to log resolver
////        public async Task ProcessAsync(JsonElement value)
////        {
////            if (!value.TryGetProperty("statuses", out var statuses))
////            {
////                _logger.LogWarning("‚ö†Ô∏è 'statuses' field missing in webhook payload.");
////                return;
////            }

////            foreach (var status in statuses.EnumerateArray())
////            {
////                var messageId = status.GetProperty("id").GetString();
////                var statusText = status.GetProperty("status").GetString();
////                //var timestamp = status.TryGetProperty("timestamp", out var ts) ? ts.GetInt64() : 0;
////                //var timestamp = status.TryGetProperty("timestamp", out var ts) ? ts.GetInt64() : 0;

////                long timestamp = 0;

////                if (status.TryGetProperty("timestamp", out var ts))
////                {
////                    if (ts.ValueKind == JsonValueKind.String && long.TryParse(ts.GetString(), out var parsed))
////                    {
////                        timestamp = parsed;
////                    }
////                    else if (ts.ValueKind == JsonValueKind.Number)
////                    {
////                        timestamp = ts.GetInt64();
////                    }
////                }

////                var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;
////                _logger.LogDebug("üïì Parsed timestamp: {0} from raw type: {1}", timestamp, ts.ValueKind);
////                // ‚úÖ Resolve the correct CampaignSendLog ID using the new resolver
////                var logId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);

////                if (logId == null)
////                {
////                    _logger.LogWarning($"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}");
////                    continue;
////                }

////                // üîç Now load the row by resolved ID
////                var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId.Value);
////                if (log != null)
////                {
////                    log.SendStatus = statusText switch
////                    {
////                        "sent" => "Sent",
////                        "delivered" => "Delivered",
////                        "read" => "Read",
////                        _ => log.SendStatus
////                    };

////                    if (statusText == "delivered") log.DeliveredAt = time;
////                    if (statusText == "read") log.ReadAt = time;

////                    await _context.SaveChangesAsync();
////                    _logger.LogInformation($"‚úÖ CampaignSendLog updated for MessageId: {messageId} ‚Üí {statusText}");
////                }
////            }
////        }

////        // üîÅ Entry point from webhook dispatcher
////        public async Task ProcessStatusUpdateAsync(JsonElement payload)
////        {
////            _logger.LogWarning("üîç Incoming timestamp raw value: {0}", payload.ToString());
////            var entry = payload.GetProperty("entry")[0];
////            var changes = entry.GetProperty("changes")[0];
////            var value = changes.GetProperty("value");

////            await ProcessAsync(value); // ‚úÖ Unified internal call
////        }
////    }
////}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Processors\TemplateWebhookProcessor.cs 
====================================================== 
 
Ôªøusing System;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace xbytechat.api.Features.Webhooks.Services.Processors
{
    public class TemplateWebhookProcessor : ITemplateWebhookProcessor
    {
        private readonly ILogger<TemplateWebhookProcessor> _logger;

        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)
        {
            _logger = logger;
        }

        public async Task ProcessTemplateUpdateAsync(JsonElement payload)
        {
            try
            {
                var entry = payload.GetProperty("entry")[0];
                var changes = entry.GetProperty("changes")[0];
                var value = changes.GetProperty("value");

                var eventType = value.GetProperty("event").GetString();
                var templateId = value.TryGetProperty("message_template_id", out var idProp)
                                 ? idProp.GetString() : "(unknown)";

                _logger.LogInformation($"üßæ Template Event Received: {eventType} for ID: {templateId}");

                // üß† You can store in DB or show in admin logs in the future

                await Task.CompletedTask;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to process template webhook update.");
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Resolvers\IMessageIdResolver.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Services.Resolvers
{
    public interface IMessageIdResolver
    {
        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);
        Task<Guid?> ResolveMessageLogIdAsync(string messageId);
        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Services\Resolvers\MessageIdResolver.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Threading.Tasks;
using xbytechat.api;

namespace xbytechat.api.Features.Webhooks.Services.Resolvers
{
    public class MessageIdResolver : IMessageIdResolver
    {
        private readonly AppDbContext _context;
        private readonly ILogger<MessageIdResolver> _logger;

        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)
        {
            var log = await _context.CampaignSendLogs
                                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.Id;
        }

        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)
        {
            var log = await _context.MessageLogs
                .AsNoTracking()
                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.Id;
        }

        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)
        {
            var log = await _context.MessageLogs
                .AsNoTracking()
                .FirstOrDefaultAsync(l => l.MessageId == messageId);

            if (log == null)
            {
                _logger.LogWarning("‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}", messageId);
                return null;
            }

            return log.BusinessId;
        }

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\IMessageStatusUpdater.cs 
====================================================== 
 
Ôªøusing System;
using System.Threading;
using System.Threading.Tasks;

namespace xbytechat.api.Features.Webhooks.Status
{
    /// <summary>
    /// Provider-agnostic updater for delivery/read/fail transitions.
    /// Must be idempotent (safe under retries / duplicates).
    /// </summary>
    public interface IMessageStatusUpdater
    {
        Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);
    }

    /// <summary>
    /// Normalized status event parsed from any provider payload.
    /// </summary>
    public sealed class StatusEvent
    {
        public Guid BusinessId { get; init; }
        public string Provider { get; init; } = "";          // "meta" | "pinnacle"

        // Provider message id (Meta "id", Pinnacle equivalent) ‚Üí maps to MessageId in your DB
        public string ProviderMessageId { get; init; } = "";

        // Optional hints (not required in your current lookups)
        public Guid? CampaignSendLogId { get; init; }
        public string? RecipientWaId { get; init; }

        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted
        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available

        public string? ErrorCode { get; init; }
        public string? ErrorMessage { get; init; }
        public string? ConversationId { get; init; }
    }

    public enum MessageDeliveryState
    {
        Sent,
        Delivered,
        Read,
        Failed,
        Deleted
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\MessageStatusContracts.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.Webhooks.Status
{
    public class MessageStatusContracts
    {
        public enum CanonicalMessageStatus
        {
            Unknown = 0,
            Submitted,   // API accepted (optional)
            Sent,        // provider accepted / sent
            Delivered,
            Read,
            Failed
        }
        public sealed class UpdateMessageStatusRequest
        {
            public Guid BusinessId { get; set; }
            public string Provider { get; set; } = "";              // "meta_cloud" | "pinnacle" | etc.
            public string MessageId { get; set; } = "";             // provider message id (WAMID / id)
            public string RawStatus { get; set; } = "";             // provider-specific (e.g., "sent", "delivered")
            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any

            public string? RecipientNumber { get; set; }            // optional sanity context
            public string? ErrorCode { get; set; }                  // optional error info
            public string? ErrorMessage { get; set; }               // optional error info
            public string? RawPayloadJson { get; set; }             // optional audit/debug
        }

        public interface IMessageStatusUpdater
        {
            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\Webhooks\Status\MessageStatusUpdater.cs 
====================================================== 
 
Ôªøusing System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

// üëá make sure this is where your AppDbContext lives
using xbytechat.api;

using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog
using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)
using xbytechat.api.CRM.Models;                       // Contact (nav)
using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog

namespace xbytechat.api.Features.Webhooks.Status
{
    /// <summary>
    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.
    /// </summary>
    public class MessageStatusUpdater : IMessageStatusUpdater
    {
        private readonly AppDbContext _db;
        private readonly ILogger<MessageStatusUpdater> _log;

        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)
        {
            _db = db;
            _log = log;
        }

        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)
        {
            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably
            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))
            {
                _log.LogWarning("Status update missing key fields (BusinessId or ProviderMessageId). Skip.");
                return;
            }

            // 1) Pull candidates (scoped to business + WAMID)
            var sendLogQ = _db.Set<CampaignSendLog>()
                              .AsTracking()
                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);

            var msgLogQ = _db.Set<MessageLog>()
                             .AsTracking()
                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);

            // If caller passed a specific CampaignSendLogId, narrow further
            if (ev.CampaignSendLogId is Guid sid)
                sendLogQ = sendLogQ.Where(s => s.Id == sid);

            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);
            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);

            // 2) Apply transition (idempotent)
            var changed = ApplyTransition(sendLog, msgLog, ev);

            // 3) Persist only if something actually changed
            if (changed > 0)
                await _db.SaveChangesAsync(ct);
        }

        /// <summary>Returns number of entities modified.</summary>
        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)
        {
            int modified = 0;

            // --- CampaignSendLog updates ---
            if (sendLog != null)
            {
                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
                {
                    sendLog.MessageId = ev.ProviderMessageId;
                    modified++;
                }

                switch (ev.State)
                {
                    case MessageDeliveryState.Sent:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Sent"))
                        {
                            sendLog.SendStatus = "Sent";
                            modified++;
                        }
                        if (sendLog.SentAt == null || sendLog.SentAt == default)
                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Delivered:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read") &&
                            !EqualsIgnoreCase(sendLog.SendStatus, "Delivered"))
                        {
                            sendLog.SendStatus = "Delivered";
                            modified++;
                        }
                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)
                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Read:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Read"))
                        {
                            sendLog.SendStatus = "Read";
                            modified++;
                        }
                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)
                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Failed:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Failed"))
                        {
                            sendLog.SendStatus = "Failed";
                            modified++;
                        }
                        if (sendLog.ErrorMessage != ev.ErrorMessage)
                        {
                            sendLog.ErrorMessage = ev.ErrorMessage;
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Deleted:
                        if (!EqualsIgnoreCase(sendLog.SendStatus, "Deleted"))
                        {
                            sendLog.SendStatus = "Deleted";
                            modified++;
                        }
                        break;
                }
            }

            // --- MessageLog updates ---
            if (msgLog != null)
            {
                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))
                {
                    msgLog.MessageId = ev.ProviderMessageId;
                    modified++;
                }

                switch (ev.State)
                {
                    case MessageDeliveryState.Sent:
                        if (!EqualsIgnoreCase(msgLog.Status, "Sent"))
                        {
                            msgLog.Status = "Sent";
                            modified++;
                        }
                        if (msgLog.SentAt == null || msgLog.SentAt == default)
                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;
                        break;

                    case MessageDeliveryState.Delivered:
                        if (!EqualsIgnoreCase(msgLog.Status, "Read") &&
                            !EqualsIgnoreCase(msgLog.Status, "Delivered"))
                        {
                            msgLog.Status = "Delivered";
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Read:
                        if (!EqualsIgnoreCase(msgLog.Status, "Read"))
                        {
                            msgLog.Status = "Read";
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Failed:
                        if (!EqualsIgnoreCase(msgLog.Status, "Failed"))
                        {
                            msgLog.Status = "Failed";
                            modified++;
                        }
                        if (msgLog.ErrorMessage != ev.ErrorMessage)
                        {
                            msgLog.ErrorMessage = ev.ErrorMessage;
                            modified++;
                        }
                        break;

                    case MessageDeliveryState.Deleted:
                        if (!EqualsIgnoreCase(msgLog.Status, "Deleted"))
                        {
                            msgLog.Status = "Deleted";
                            modified++;
                        }
                        break;
                }
            }

            if (sendLog == null && msgLog == null)
            {
                _log.LogWarning("No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}",
                    ev.BusinessId, ev.ProviderMessageId, ev.State);
            }

            return modified;
        }

        private static bool EqualsIgnoreCase(string? a, string? b) =>
            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
    }
}
 
 
