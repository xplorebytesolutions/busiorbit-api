{
  "name": "xbytechat-api",
  "part": 2,
  "of": 11,
  "generatedAt": "2025-09-05 11:57:45 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignSendLog.cs",
      "sha256": "992f4eece720ed4be3c8532d2ac23d45c3a04252cd5347f74eac5c1de4c8ac54",
      "language": "csharp",
      "size": 2957,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Models\n{\n    public class CampaignSendLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        public string? MessageId { get; set; } // Unique WAMID from WhatsApp\n        // üîó Foreign Keys\n        [Required]\n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public Guid RecipientId { get; set; }\n\n        // üì© Message Info\n        [Required]\n        public string MessageBody { get; set; } = \"\";\n\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // üåê Metadata\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n        public string? SourceChannel { get; set; }\n\n        // ‚úÖ UX-Derived\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üìä Click Tracking\n        public bool IsClicked { get; set; } = false;\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // üîÅ Retry Tracking (üí° New)\n        public int RetryCount { get; set; } = 0;                 // Number of retry attempts\n        public DateTime? LastRetryAt { get; set; }               // When retry last happened\n        public string? LastRetryStatus { get; set; }             // Success / Failed\n        public bool AllowRetry { get; set; } = true;             // Flag to enable/disable retry\n\n        // üëÅ Navigation\n      \n        public Contact? Contact { get; set; }\n        public CampaignRecipient? Recipient { get; set; }\n\n\n        // üîó MessageLog reference (optional)\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        // üÜï Flow context snapshot for deterministic click resolution\n        public Guid? CTAFlowConfigId { get; set; }   // which flow this send belongs to (optional)\n        public Guid? CTAFlowStepId { get; set; }     // the entry step id (optional)\n\n        [Column(TypeName = \"text\")]\n        public string? ButtonBundleJson { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignAnalyticsService.cs",
      "sha256": "93a5dbda2d06118a7c3384bd9306b6de7eaf6979d499ca8cc97eacfe6c7f4251",
      "language": "csharp",
      "size": 3079,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n\n\n    public class CampaignAnalyticsService : ICampaignAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n            //_context = context;\n        }\n\n        public async Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId)\n        {\n            var logs = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .ToListAsync();\n\n            if (!logs.Any()) return null;\n\n            return new CampaignStatusDashboardDto\n            {\n                CampaignId = campaignId,\n                TotalRecipients = logs.Count,\n                SentCount = logs.Count(l => l.SendStatus == \"Sent\"),\n                DeliveredCount = logs.Count(l => l.SendStatus == \"Delivered\"),\n                ReadCount = logs.Count(l => l.SendStatus == \"Read\"),\n                FailedCount = logs.Count(l => l.SendStatus == \"Failed\"),\n                FirstSentAt = logs.Min(l => l.SentAt),\n                LastSentAt = logs.Max(l => l.SentAt),\n                FirstReadAt = logs.Min(l => l.ReadAt),\n                LastReadAt = logs.Max(l => l.ReadAt)\n            };\n        }\n\n        public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        {\n            var campaignStats = await _context.CampaignSendLogs\n                .Where(log => log.BusinessId == businessId)\n                .GroupBy(log => log.CampaignId)\n                .Select(group => new\n                {\n                    CampaignId = group.Key,\n                    TotalSent = group.Count(),\n                    TotalRead = group.Count(l => l.ReadAt != null),\n                    TotalClicked = group.Count(l => l.ClickedAt != null)\n                })\n                .Where(s => s.TotalSent > 0)\n                .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent)\n                .Take(count)\n                .ToListAsync();\n\n            if (!campaignStats.Any())\n            {\n                return new List<TopCampaignDto>();\n            }\n\n            var campaignIds = campaignStats.Select(s => s.CampaignId).ToList();\n            var campaigns = await _context.Campaigns\n                .Where(c => campaignIds.Contains(c.Id))\n                .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n            return campaignStats.Select(s => new TopCampaignDto\n            {\n                CampaignId = s.CampaignId,\n                CampaignName = campaigns.GetValueOrDefault(s.CampaignId, \"Unnamed Campaign\"),\n                ReadRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalRead / s.TotalSent) * 100, 2) : 0,\n                ClickThroughRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalClicked / s.TotalSent) * 100, 2) : 0\n            });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignRetryService.cs",
      "sha256": "c006d284f3bc500e9eb4d5b0191ac34ccdd5643bc4742c18b5af20ec13334116",
      "language": "csharp",
      "size": 2911,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignRetryService : ICampaignRetryService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignRetryService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Public method: Retry a single failed log\n        public async Task<bool> RetrySingleAsync(Guid logId)\n        {\n            return await RetrySendLogAsync(logId);\n        }\n\n        // ‚úÖ Public method: Retry all failed logs in a campaign\n        public async Task<int> RetryFailedInCampaignAsync(Guid campaignId)\n        {\n            return await RetryAllFailedInCampaignAsync(campaignId);\n        }\n\n        // üîÅ Private: Retry a specific log\n        private async Task<bool> RetrySendLogAsync(Guid logId)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (log == null || log.SendStatus != \"Failed\" || !log.AllowRetry)\n                return false;\n\n            // üîÑ Simulate re-send (replace with actual IMessageService.SendAsync later)\n            bool sent = SimulateSendMessage(log);\n\n            log.RetryCount += 1;\n            log.LastRetryAt = DateTime.UtcNow;\n            log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n            log.SendStatus = sent ? \"Sent\" : \"Failed\";\n            log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n            await _context.SaveChangesAsync();\n            return sent;\n        }\n\n        // üîÅ Private: Retry all failed logs in a given campaign\n        private async Task<int> RetryAllFailedInCampaignAsync(Guid campaignId)\n        {\n            var failedLogs = await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.SendStatus == \"Failed\" && log.AllowRetry)\n                .ToListAsync();\n\n            int successCount = 0;\n\n            foreach (var log in failedLogs)\n            {\n                bool sent = SimulateSendMessage(log);\n\n                log.RetryCount += 1;\n                log.LastRetryAt = DateTime.UtcNow;\n                log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n                log.SendStatus = sent ? \"Sent\" : \"Failed\";\n                log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n                if (sent) successCount++;\n            }\n\n            await _context.SaveChangesAsync();\n            return successCount;\n        }\n\n        // üîß Simulated send (replace with actual WhatsApp message logic)\n        private bool SimulateSendMessage(CampaignSendLog log)\n        {\n            return new Random().NextDouble() < 0.9; // 90% success rate\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogEnricher.cs",
      "sha256": "6d1155127869663e221b9c1a80e5dce49dd32c3d57d218d8157691ed3bc8edeb",
      "language": "csharp",
      "size": 872,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogEnricher : ICampaignSendLogEnricher\n    {\n        public async Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress)\n        {\n            // üß† Device Detection (simplified for now)\n            log.DeviceInfo = userAgent;\n\n            // üåç IP Lookup - Mocked for now\n            if (!string.IsNullOrWhiteSpace(ipAddress))\n            {\n                log.IpAddress = ipAddress;\n                log.SourceChannel = \"API\"; // Example: mark origin\n                // Future: Use IPinfo or GeoLite2 for full location enrichment\n            }\n\n            // ‚åõ Simulate async task for compatibility\n            await Task.CompletedTask;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogService.cs",
      "sha256": "b6b85401c517bea5cb1eee0bd5a1030b7f3e7c4b8820dfa3ba653f7cd372f768",
      "language": "csharp",
      "size": 8341,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogService : ICampaignSendLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ICampaignSendLogEnricher _enricher;\n\n\n        public CampaignSendLogService(AppDbContext context, ICampaignSendLogEnricher enricher)\n        {\n            _context = context;\n            _enricher = enricher;\n        }\n\n        public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(Guid campaignId, string? status, string? search, int page, int pageSize)\n        {\n            var query = _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId)\n                .Include(log => log.Contact)\n                .AsNoTracking();\n\n            // Apply filters to the database query\n            if (!string.IsNullOrEmpty(status))\n            {\n                query = query.Where(log => log.SendStatus == status);\n            }\n\n            if (!string.IsNullOrEmpty(search))\n            {\n                var keyword = search.ToLower();\n                query = query.Where(log =>\n                    (log.Contact != null && log.Contact.Name.ToLower().Contains(keyword)) ||\n                    (log.Contact != null && log.Contact.PhoneNumber.Contains(keyword)));\n            }\n\n            var totalCount = await query.CountAsync();\n\n            var logs = await query\n                .OrderByDescending(log => log.CreatedAt)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,\n                    ContactName = log.Contact != null ? log.Contact.Name : \"N/A\",\n                    ContactPhone = log.Contact != null ? log.Contact.PhoneNumber : \"-\",\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n                    SourceChannel = log.SourceChannel,\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType\n                })\n                .ToListAsync();\n\n            return new PagedResult<CampaignSendLogDto>\n            {\n                Items = logs,\n                TotalCount = totalCount,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n        public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        {\n            return await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.ContactId == contactId)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n                    IpAddress = log.IpAddress,\n                    DeviceInfo = log.DeviceInfo,\n                    MacAddress = log.MacAddress,\n                    SourceChannel = log.SourceChannel,\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType\n                })\n                .ToListAsync();\n        }\n\n        // üÜï Create a new send log (with enrichment)\n        public async Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent)\n        {\n            var log = new CampaignSendLog\n            {\n                Id = Guid.NewGuid(),\n                CampaignId = dto.CampaignId,\n                ContactId = dto.ContactId,\n                MessageBody = dto.MessageBody,\n                TemplateId = dto.TemplateId,\n                SendStatus = dto.SendStatus,\n                ErrorMessage = dto.ErrorMessage,\n                CreatedAt = DateTime.UtcNow,\n                SentAt = dto.SentAt,\n                DeliveredAt = dto.DeliveredAt,\n                ReadAt = dto.ReadAt,\n                SourceChannel = dto.SourceChannel,\n                IsClicked = dto.IsClicked,\n                ClickedAt = dto.ClickedAt,\n                ClickType = dto.ClickType,\n                RecipientId = dto.RecipientId\n            };\n\n            // ‚úÖ Use enrichment service\n            await _enricher.EnrichAsync(log, userAgent, ipAddress);\n\n            _context.CampaignSendLogs.Add(log);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // üì® Update delivery or read status\n        public async Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.SendStatus = status;\n            log.DeliveredAt = deliveredAt ?? log.DeliveredAt;\n            log.ReadAt = readAt ?? log.ReadAt;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // üìà Track click (CTA)\n        public async Task<bool> TrackClickAsync(Guid logId, string clickType)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.IsClicked = true;\n            log.ClickedAt = DateTime.UtcNow;\n            log.ClickType = clickType;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n        public async Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId)\n        {\n            // This single, efficient query calculates all stats directly in the database.\n            var summary = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .GroupBy(l => 1) // Group by a constant to aggregate all results\n                .Select(g => new\n                {\n                    TotalRecipients = g.Count(),\n\n                    // CORRECTED LOGIC: A message is \"Sent\" if its status is NOT \"Failed\".\n                    // This correctly includes messages that are \"Sent\", \"Delivered\", or \"Read\".\n                    SentCount = g.Count(l => l.SendStatus != \"Failed\"),\n\n                    FailedCount = g.Count(l => l.SendStatus == \"Failed\"),\n                    ClickedCount = g.Count(l => l.IsClicked),\n                    DeliveredCount = g.Count(l => l.DeliveredAt != null),\n                    ReadCount = g.Count(l => l.ReadAt != null),\n                    LastSentAt = g.Max(l => l.SentAt)\n                })\n                .FirstOrDefaultAsync();\n\n            if (summary == null)\n            {\n                // Return an empty DTO if no logs are found for the campaign\n                return new CampaignLogSummaryDto();\n            }\n\n            return new CampaignLogSummaryDto\n            {\n                TotalSent = summary.TotalRecipients,\n                Sent = summary.SentCount,\n                FailedCount = summary.FailedCount,\n                ClickedCount = summary.ClickedCount,\n                Delivered = summary.DeliveredCount,\n                Read = summary.ReadCount,\n                LastSentAt = summary.LastSentAt\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// üìÑ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignRetryService.cs",
      "sha256": "1211609bf9f58a20712fb625fd9e5691ba959d0f12ddde94e3d869cdf1cd9088",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "092d86318ec5e38dcb7baef591d1796d1f6942335e39f850aec69e7a5e870407",
      "language": "csharp",
      "size": 1267,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        // This is the NEW signature that matches your updated service and controller\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n        // üìç Get logs for a specific contact in a campaign\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        // üÜï Add a new send log entry with enrichment (IP, User-Agent)\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        // üì® Update delivery or read status\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        // üìà Track CTA click (e.g., BuyNow, ViewDetails)\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n        // üìä Get summary of campaign logs\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogDashboardController.cs",
      "sha256": "f9186d5de3a12145a3d7a2411736c6510ca02a7b70409ebdcaaa0de5172c0370",
      "language": "csharp",
      "size": 1708,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-dashboard\")]\n    public class CatalogDashboardController : ControllerBase\n    {\n        private readonly ICatalogDashboardService _dashboardService;\n\n        public CatalogDashboardController(ICatalogDashboardService dashboardService)\n        {\n            _dashboardService = dashboardService;\n        }\n\n        [HttpGet(\"summary\")]\n        public async Task<ActionResult<CatalogDashboardSummaryDto>> GetSummary([FromQuery] Guid businessId)\n        {\n            var summary = await _dashboardService.GetDashboardSummaryAsync(businessId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"top-products\")]\n        public async Task<IActionResult> GetTopClickedProducts([FromQuery] Guid businessId, [FromQuery] int topN = 5)\n        {\n            var topProducts = await _dashboardService.GetTopClickedProductsAsync(businessId, topN);\n            return Ok(topProducts);\n        }\n        [HttpGet(\"cta-summary\")]\n        public async Task<IActionResult> GetCtaJourneySummary([FromQuery] Guid businessId)\n        {\n            var stats = await _dashboardService.GetCtaJourneyStatsAsync(businessId);\n            return Ok(stats);\n        }\n        [HttpGet(\"product-cta-breakdown\")]\n        public async Task<IActionResult> GetProductCtaBreakdown([FromQuery] Guid businessId)\n        {\n            var breakdown = await _dashboardService.GetProductCtaBreakdownAsync(businessId);\n            return Ok(breakdown);\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogTrackingController.cs",
      "sha256": "85581ce69ed9dbbad069ca060c3e8a2c356ec348d74d860ed2ed1905c46f9514",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-tracking\")]\n    public class CatalogTrackingController : ControllerBase\n    {\n        private readonly ICatalogTrackingService _trackingService;\n        private readonly ILogger<CatalogTrackingController> _logger;\n\n        public CatalogTrackingController(\n            ICatalogTrackingService trackingService,\n            ILogger<CatalogTrackingController> logger)\n        {\n            _trackingService = trackingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"log-click\")]\n        public async Task<IActionResult> LogClick([FromBody] CatalogClickLogDto dto)\n        {\n            var result = await _trackingService.LogClickAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"‚ùå Catalog click log failed: {Msg}\", result.Message);\n                return BadRequest(result);\n            }\n\n            return StatusCode(201, result);\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 5)\n        {\n            var result = await _trackingService.GetRecentLogsAsync(limit);\n\n            if (!result.Success)\n            {\n                _logger.LogError(\"‚ùå Failed to fetch recent logs: {Error}\", result.ErrorMessage);\n                return StatusCode(500, result);\n            }\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/ProductController.cs",
      "sha256": "96a44de270bbb3d5a3b88cc161908c14045b78ca5adab88fb776640f55de1a1b",
      "language": "csharp",
      "size": 3021,
      "content": "// üìÑ File: Features/Catalog/Controllers/ProductController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Middleware.Attributes;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductService _productService;\n\n        public ProductController(IProductService productService)\n        {\n            _productService = productService;\n        }\n\n        // ‚úÖ GET /api/product?businessId=...\n        [HttpGet]\n        [RequirePermission(\"ViewCatalog\")]\n        public async Task<IActionResult> GetAll([FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.GetProductsByBusinessIdAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ POST /api/product\n        [HttpPost]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Create([FromBody] CreateProductDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                var errorString = string.Join(\"; \", errors);\n                return BadRequest(ResponseResult.ErrorInfo(\"Invalid product data.\", errorString));\n            }\n\n            var result = await _productService.AddProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return StatusCode(201, result);\n        }\n\n        // ‚úÖ DELETE /api/product/{id}?businessId=...\n        [HttpDelete(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Delete(Guid id, [FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.RemoveProductAsync(id, businessId);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // ‚úÖ PUT /api/product/{id}\n        [HttpPut(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpdateProductDto dto)\n        {\n            if (id != dto.Id)\n                return BadRequest(ResponseResult.ErrorInfo(\"ID mismatch between route and body.\"));\n\n            var result = await _productService.UpdateProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogClickLogDto.cs",
      "sha256": "901cea612e459695f97b806841df45393d04066624affedbfd85cc9d7d3899ce",
      "language": "csharp",
      "size": 979,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogClickLogDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid? ContactId { get; set; }  // ‚úÖ Add this\n        public Guid? ProductId { get; set; }\n\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        public string? BotId { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public string? CTAJourney { get; set; }\n        public Guid? MessageLogId { get; set; }      // ‚úÖ ADD THIS FIELD\n        public string? RefMessageId { get; set; }\n\n        public string TemplateId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üß† Optional: Used for A/B tracking and analytics\n        public string? PlanSnapshot { get; set; }\n\n        public string? Source { get; set; } // ‚úÖ Add this\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogDashboardSummaryDto.cs",
      "sha256": "31e171cf2d8c5bc006b770f4be2a968db3300aaad51072555faecd119e0e0e07",
      "language": "csharp",
      "size": 698,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogDashboardSummaryDto\n    {\n        // Engagement Metrics\n        public int TotalMessagesSent { get; set; }\n        public int? UniqueCustomersMessaged { get; set; }\n        public int? ProductClicks { get; set; }\n\n        // Catalog Overview\n        public int? ActiveProducts { get; set; }\n        public int? ProductsSharedViaWhatsApp { get; set; }\n\n        // Lead Intelligence\n        public int? RepeatClickers { get; set; }\n        public int? NewClickersToday { get; set; }\n\n        // Timestamps\n        public DateTime? LastCatalogClickAt { get; set; }\n        public DateTime? LastMessageSentAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CreateProductDto.cs",
      "sha256": "8605a9900a0537d7cec14264a91a4a4432debcdaafb06cff99b177460bd47233",
      "language": "csharp",
      "size": 472,
      "content": "// File: Features/Catalog/DTOs/CreateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CreateProductDto\n    {\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CtaJourneyStatsDto.cs",
      "sha256": "ca4efb6e222da04add4d8f9892be95a16ae180b34e53eec32d300c471ea503bd",
      "language": "csharp",
      "size": 188,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CtaJourneyStatsDto\n    {\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductCtaBreakdownDto.cs",
      "sha256": "a94adfe171430503ede80ebb733fc9983f3fe1eae04b4a5a4ed6eb14d354bc10",
      "language": "csharp",
      "size": 284,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductCtaBreakdownDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductDto.cs",
      "sha256": "9351e6b36ce1f707bd46bb92652331f1751b150a9d062ecfd31572a0998d59b7",
      "language": "csharp",
      "size": 549,
      "content": "// File: Features/Catalog/DTOs/ProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/TopProductDto.cs",
      "sha256": "464918c2b2d66c5710042f7d26d7b64fc8f4fb0380f12e7c756a0d248e613684",
      "language": "csharp",
      "size": 228,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class TopProductDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/UpdateProductDto.cs",
      "sha256": "3d2fa63b4ce50da54504b1efa60375305ee53bd12498eb5c359bec2f13aeb11c",
      "language": "csharp",
      "size": 511,
      "content": "// File: Features/Catalog/DTOs/UpdateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class UpdateProductDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/CatalogClickLog.cs",
      "sha256": "04b5faf86ec274241aa075f5ba6309899ae07f9c0074d1a34285b4f7c96b437d",
      "language": "csharp",
      "size": 1636,
      "content": "namespace xbytechat.api.Features.Catalog.Models\n{\n    public class CatalogClickLog\n    {\n        public Guid Id { get; set; }\n\n        // üîó Business & Product Info\n        public Guid BusinessId { get; set; }\n        public Guid? ProductId { get; set; }\n\n        // üë§ Customer Info\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        // ü§ñ Bot / Messaging Context\n        public string? BotId { get; set; }\n\n        // üõçÔ∏è Browsing Context\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n\n        // üîò CTA Clicked\n        public string? CTAJourney { get; set; }\n        public string TemplateId { get; set; }\n        public string RefMessageId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üïí Meta\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n\n        // ‚úÖ CRM / Campaign / Analytics\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? ContactId { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public string? PlanSnapshot { get; set; }\n\n        // üÜï [New Additions for CTA Campaign Tracking]\n        public Guid? CtaId { get; set; }             // Link to CTA definition\n        public Guid? CampaignId { get; set; }        // Link to campaign (if any)\n        public string Source { get; set; } = \"catalog\"; // \"catalog\", \"campaign\", \"auto-reply\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/Product.cs",
      "sha256": "428554206c02d4602a873704a1e49c995a274f4633e0f32d8c0991c4eea72a31",
      "language": "csharp",
      "size": 1062,
      "content": "// File: Features/Catalog/Models/Product.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.Catalog.Models\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n\n        // üîó Foreign Key - Business/Owner\n        public Guid BusinessId { get; set; }\n\n        // üì¶ Core Product Info\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n\n        // ‚úÖ Visibility & State\n        public bool IsActive { get; set; } = true;\n\n        // üìÖ Metadata\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public int TotalClicks { get; set; } = 0; // Total CTA clicks tracked\n        public DateTime? LastClickedAt { get; set; } // Last time a user clicked CTA for this product\n        public string? MostClickedCTA { get; set; } // Button text with highest click count (e.g., \"Buy Now\")\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogDashboardService.cs",
      "sha256": "3303616ebf70e99e2e646759834c707405060cc1b22ceb5f743dfa1d8af50198",
      "language": "csharp",
      "size": 6538,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting.Server;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogDashboardService : ICatalogDashboardService\n    {\n        private readonly AppDbContext _context;\n\n        public CatalogDashboardService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n       \n        public async Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalMessagesSent = await _context.MessageLogs\n                .CountAsync(m => m.BusinessId == businessId);\n\n            var uniqueCustomersMessaged = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .Select(m => m.RecipientNumber)\n                .Distinct()\n                .CountAsync();\n\n            var productClicks = await _context.CatalogClickLogs\n                .CountAsync(c => c.BusinessId == businessId && c.ProductId != null);\n\n            var activeProducts = await _context.Products\n                .CountAsync(p => p.BusinessId == businessId);\n\n            var productsSharedViaWhatsapp = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .Select(c => c.ProductId)\n                .Distinct()\n                .CountAsync();\n\n            var repeatClickers = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.UserPhone)\n                .CountAsync(g => g.Count() > 1);\n\n            var newClickersToday = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ClickedAt.Value.Date == today)\n                .Select(c => c.UserPhone)\n                .Distinct()\n                .CountAsync();\n            //        var newClickersToday = _context.CatalogClickLogs\n            //.Where(c => c.BusinessId == businessId)\n            //.ToList() // now it's LINQ to Objects\n            //        .Where(c => c.ClickedAt?.Date == today)\n            //        .Select(c => c.UserPhone)\n            //        .Distinct()\n            //.Count();\n            //        But if your data is large, the first(server-side filtering) is the better choice.\n\n            var lastCatalogClickAt = await _context.CatalogClickLogs\n    .Where(c => c.BusinessId == businessId)\n    .MaxAsync(c => (DateTime?)c.ClickedAt);\n\n            var lastMessageSentAt = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .MaxAsync(m => (DateTime?)m.SentAt);\n\n            return new CatalogDashboardSummaryDto\n            {\n                TotalMessagesSent = totalMessagesSent,\n                UniqueCustomersMessaged = uniqueCustomersMessaged,\n                ProductClicks = productClicks,\n                ActiveProducts = activeProducts,\n                ProductsSharedViaWhatsApp = productsSharedViaWhatsapp,\n                RepeatClickers = repeatClickers,\n                NewClickersToday = newClickersToday,\n                LastCatalogClickAt = lastCatalogClickAt,\n                LastMessageSentAt = lastMessageSentAt\n            };\n        }\n\n        public async Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5)\n        {\n            var topProducts = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .GroupBy(c => c.ProductId)\n                .Select(g => new\n                {\n                    ProductId = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .Take(topN)\n                .ToListAsync();\n\n            // Now fetch product names to join with clicks\n            var productIds = topProducts.Select(x => x.ProductId).ToList();\n\n            var products = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            return topProducts.Select(x => new TopProductDto\n            {\n                ProductId = x.ProductId.Value,\n                ProductName = products.ContainsKey(x.ProductId.Value) ? products[x.ProductId.Value] : \"Unknown\",\n                ClickCount = x.ClickCount\n            }).ToList();\n        }\n        public async Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId)\n        {\n            var stats = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => c.CTAJourney)\n                .Select(g => new CtaJourneyStatsDto\n                {\n                    CTAJourney = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .ToListAsync();\n\n            return stats;\n        }\n        public async Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId)\n        {\n            var groupedClicks = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => new { c.ProductId, c.CTAJourney })\n                .Select(g => new\n                {\n                    ProductId = g.Key.ProductId.Value,\n                    CTAJourney = g.Key.CTAJourney,\n                    ClickCount = g.Count()\n                })\n                .ToListAsync();\n\n            // Fetch product names for all involved productIds\n            var productIds = groupedClicks.Select(g => g.ProductId).Distinct().ToList();\n\n            var productNames = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            var result = groupedClicks.Select(g => new ProductCtaBreakdownDto\n            {\n                ProductId = g.ProductId,\n                ProductName = productNames.ContainsKey(g.ProductId) ? productNames[g.ProductId] : \"Unknown\",\n                CTAJourney = g.CTAJourney,\n                ClickCount = g.ClickCount\n            }).ToList();\n\n            return result;\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogTrackingService.cs",
      "sha256": "79e5e44c45d327c3c4f281e9f60fe09baac547c05995c848a954edd66d3f349d",
      "language": "csharp",
      "size": 6359,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.xbTimeline.Services;\nusing xbytechat.api.Features.PlanManagement.Models;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogTrackingService : ICatalogTrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public CatalogTrackingService(\n            AppDbContext context,\n            IMessageService messageService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _context = context;\n            _messageService = messageService;\n            _leadTimelineService = leadTimelineService;\n        }\n\n        public async Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto)\n        {\n            if (dto == null || dto.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(dto.UserPhone))\n            {\n                Log.Warning(\"‚ùå Invalid catalog click log attempt: missing businessId or userPhone.\");\n                return ResponseResult.ErrorInfo(\"Required fields are missing (businessId, userPhone).\");\n            }\n\n            try\n            {\n                Guid? campaignSendLogId = null;\n                Guid? contactId = null;\n                bool followUpSent = false;\n\n                // STEP 1: Link campaign log via RefMessageId if available\n                if (!string.IsNullOrWhiteSpace(dto.RefMessageId))\n                {\n                    var sendLog = await _context.CampaignSendLogs\n                        .FirstOrDefaultAsync(x => x.MessageId == dto.RefMessageId);\n\n                    if (sendLog != null)\n                    {\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = DateTime.UtcNow;\n                        sendLog.ClickType = dto.CTAJourney ?? dto.ButtonText;\n                        campaignSendLogId = sendLog.Id;\n                    }\n                }\n\n                // STEP 2: Link or Create CRM Contact\n                if (!string.IsNullOrWhiteSpace(dto.UserPhone))\n                {\n                    var contact = await _context.Contacts\n                        .FirstOrDefaultAsync(c => c.PhoneNumber == dto.UserPhone && c.BusinessId == dto.BusinessId);\n\n                    if (contact == null)\n                    {\n                        contact = new Contact\n                        {\n                            Id = Guid.NewGuid(),\n                            Name = dto.UserName ?? \"Lead\",\n                            PhoneNumber = dto.UserPhone,\n                            BusinessId = dto.BusinessId,\n                            CreatedAt = DateTime.UtcNow\n                        };\n                        _context.Contacts.Add(contact);\n                        await _context.SaveChangesAsync();\n                    }\n\n                    contactId = contact.Id;\n\n                    // STEP 3: Auto follow-up if plan allows\n                    var business = await _context.Businesses\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(b => b.Id == dto.BusinessId);\n\n                    if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                    {\n                        var message = $\"Hi {contact.Name ?? \"there\"}, how can I help you?\";\n                        await _messageService.SendFollowUpAsync(contact.PhoneNumber, message);\n                        followUpSent = true;\n                    }\n                }\n\n                // STEP 4: Save the click with all linked data\n                var log = new CatalogClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ProductId = dto.ProductId,\n                    UserId = dto.UserId,\n                    UserName = dto.UserName,\n                    UserPhone = dto.UserPhone,\n                    BotId = dto.BotId,\n                    CategoryBrowsed = dto.CategoryBrowsed,\n                    ProductBrowsed = dto.ProductBrowsed,\n                    CTAJourney = dto.CTAJourney,\n                    TemplateId = dto.TemplateId,\n                    ButtonText = dto.ButtonText,\n                    RefMessageId = dto.RefMessageId,\n                    ClickedAt = DateTime.UtcNow,\n                    CampaignSendLogId = campaignSendLogId,\n                    ContactId = contactId,\n                    FollowUpSent = followUpSent,\n                    LastInteractionType = \"Clicked\",\n                    PlanSnapshot = dto.PlanSnapshot\n                };\n\n                _context.CatalogClickLogs.Add(log);\n                await _context.SaveChangesAsync();\n\n                // STEP 5: Save into LeadTimeline (no await error)\n                await _leadTimelineService.AddFromCatalogClickAsync(log);\n\n                Log.Information(\"üìä Catalog click tracked: {BusinessId}, {UserPhone}, {CTA}\", dto.BusinessId, dto.UserPhone, dto.CTAJourney);\n                return ResponseResult.SuccessInfo(\"‚úÖ Click tracked successfully.\", log.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log catalog click\");\n                return ResponseResult.ErrorInfo(\"‚ùå Error while tracking catalog click.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetRecentLogsAsync(int limit)\n        {\n            try\n            {\n                var logs = await _context.CatalogClickLogs\n                    .OrderByDescending(x => x.ClickedAt)\n                    .Take(limit)\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Recent logs fetched.\", logs);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch recent catalog click logs\");\n                return ResponseResult.ErrorInfo(\"Failed to fetch logs.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogDashboardService.cs",
      "sha256": "9cac16574ec18c7343c13d49a28395b9ab04bf296e8d7b910b05d1cc88378a7d",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogDashboardService\n    {\n        Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId);\n        Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5);\n        Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId);\n        Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId);\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogTrackingService.cs",
      "sha256": "b9ea119f807697f7e52cbea8b7c3aa4320c2ffe23326d076d1d1f0f9a2f12310",
      "language": "csharp",
      "size": 342,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogTrackingService\n    {\n        Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto);\n        Task<ResponseResult> GetRecentLogsAsync(int limit);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/IProductService.cs",
      "sha256": "23245f8c5da029c4146e515732f03b3e815636c1fddfec0f38a3a26355bdc1b1",
      "language": "csharp",
      "size": 510,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface IProductService\n    {\n        Task<ResponseResult> AddProductAsync(CreateProductDto dto);\n        Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId);\n        Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto);\n        Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ProductService.cs",
      "sha256": "b42253a9398257b4f84555e31c4423127d843bd60b73560f7730b71433d17fd0",
      "language": "csharp",
      "size": 5527,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class ProductService : IProductService\n    {\n        private readonly AppDbContext _context;\n\n        public ProductService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<ResponseResult> AddProductAsync(CreateProductDto dto)\n        {\n            try\n            {\n                var exists = await _context.Products\n                    .AnyAsync(p => p.BusinessId == dto.BusinessId && p.Name == dto.Name);\n\n                if (exists)\n                {\n                    Log.Warning(\"‚ùå Duplicate product add attempt: {ProductName} for BusinessId: {BusinessId}\", dto.Name, dto.BusinessId);\n                    return ResponseResult.ErrorInfo(\"Product with this name already exists.\");\n                }\n\n                var newProduct = new Product\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    Price = dto.Price,\n                    Currency = dto.Currency,\n                    ImageUrl = dto.ImageUrl,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _context.Products.AddAsync(newProduct);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product created: {ProductName} ({ProductId})\", dto.Name, newProduct.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product added successfully.\", newProduct.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add product: {ProductName}\", dto.Name);\n                return ResponseResult.ErrorInfo(\"Failed to add product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == id && p.BusinessId == businessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to delete non-existent product: {ProductId}\", id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                _context.Products.Remove(product);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üóëÔ∏è Product deleted: {ProductId}\", id);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Product deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to delete product: {ProductId}\", id);\n                return ResponseResult.ErrorInfo(\"Failed to delete product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == dto.Id && p.BusinessId == dto.BusinessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to update non-existent product: {ProductId}\", dto.Id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                product.Name = dto.Name;\n                product.Description = dto.Description;\n                product.Price = dto.Price;\n                product.Currency = dto.Currency;\n                product.ImageUrl = dto.ImageUrl;\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product updated: {ProductId}\", dto.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to update product: {ProductId}\", dto.Id);\n                return ResponseResult.ErrorInfo(\"Failed to update product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId)\n        {\n            try\n            {\n                var products = await _context.Products\n                    .Where(p => p.BusinessId == businessId && p.IsActive)\n                    .Select(p => new ProductDto\n                    {\n                        Id = p.Id,\n                        BusinessId = p.BusinessId,\n                        Name = p.Name,\n                        Description = p.Description,\n                        Price = p.Price,\n                        Currency = p.Currency,\n                        ImageUrl = p.ImageUrl,\n                        IsActive = p.IsActive\n                    })\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Products fetched.\", products);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch products for BusinessId: {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"Failed to fetch products.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Controllers/CrmAnalyticsController.cs",
      "sha256": "9148ea0201bfa24665b2fc92339cec7f58019baa66443aba80189bc1a4c9c833",
      "language": "csharp",
      "size": 1948,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.Services;\nusing xbytechat.api.Shared;\nusing System.Security.Claims;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Controllers\n{\n    /// <summary>\n    /// Handles CRM analytics summary and trends.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public class CrmAnalyticsController : ControllerBase\n    {\n        private readonly ICrmAnalyticsService _crmAnalyticsService;\n\n        public CrmAnalyticsController(ICrmAnalyticsService crmAnalyticsService)\n        {\n            _crmAnalyticsService = crmAnalyticsService;\n        }\n\n        /// <summary>\n        /// Returns dashboard summary stats for the CRM.\n        /// </summary>\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetSummaryAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìä CRM analytics loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Returns contacts-added-over-time trend for graph.\n        /// </summary>\n        [HttpGet(\"trends/contacts\")]\n        public async Task<IActionResult> GetContactTrends()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetContactTrendsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìà Contact trends loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Extracts the businessId (Guid) from current user claims.\n        /// </summary>\n        private Guid GetBusinessIdFromContext()\n        {\n            return Guid.TryParse(HttpContext.User.FindFirst(\"BusinessId\")?.Value, out var id)\n                ? id\n                : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/ContactTrendsDto.cs",
      "sha256": "132d9271e14f9c3f2a65c9241917f67bc8129c91c7050c86a67df545c68419bc",
      "language": "csharp",
      "size": 362,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    /// <summary>\n    /// Represents the number of contacts added on a specific date.\n    /// Used for trend charting on the CRM dashboard.\n    /// </summary>\n    public class ContactTrendsDto\n    {\n        public string Date { get; set; } // Format: yyyy-MM-dd\n        public int Count { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/CrmAnalyticsSummaryDto.cs",
      "sha256": "73027ff6ddc0b680b03714267bbf642053cdc28f2d97c16b593a3321186ab9d9",
      "language": "csharp",
      "size": 619,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    public class CrmAnalyticsSummaryDto\n    {\n        public int TotalContacts { get; set; }\n        public int TaggedContacts { get; set; }\n        public int ActiveReminders { get; set; }\n        public int CompletedReminders { get; set; }\n        public int TotalNotes { get; set; }\n        public int LeadsWithTimeline { get; set; }\n        public int NewContactsToday { get; set; }\n        public int NotesAddedToday { get; set; }\n        public DateTime? LastContactAddedAt { get; set; }\n        public DateTime? LastReminderCompletedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/CrmAnalyticsService.cs",
      "sha256": "8fae1f725576dc5f6402559df557282ba8991f65bb324b614a65b4e9225167c5",
      "language": "csharp",
      "size": 4014,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\nusing xbytechat.api.Features.CrmAnalytics.Services;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Provides implementation for CRM analytics calculations.\n    /// Gathers contact, tag, note, and reminder metrics for the dashboard.\n    /// </summary>\n    public class CrmAnalyticsService : ICrmAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CrmAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        /// <summary>\n        /// Generates a summarized snapshot of CRM data for the given business.\n        /// </summary>\n        /// <param name=\"businessId\">The unique ID of the business</param>\n        /// <returns>CrmAnalyticsSummaryDto containing insights</returns>\n        public async Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalContacts = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId);\n\n            var taggedContacts = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && c.Tags.Any())\n                .CountAsync();\n\n            var activeReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Pending\");\n\n            var completedReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Completed\");\n\n            var totalNotes = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId);\n\n            var leadsWithTimeline = await _context.LeadTimelines\n                .Where(t => t.BusinessId == businessId)\n                .Select(t => t.ContactId)\n                .Distinct()\n                .CountAsync();\n\n            var newContactsToday = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId && c.CreatedAt.Date == today);\n\n            var notesAddedToday = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId && n.CreatedAt.Date == today);\n\n            var lastContactAddedAt = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => (DateTime?)c.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            var lastReminderCompletedAt = await _context.Reminders\n                .Where(r => r.BusinessId == businessId && r.Status == \"Completed\")\n                .OrderByDescending(r => r.CompletedAt)\n                .Select(r => (DateTime?)r.CompletedAt)\n                .FirstOrDefaultAsync();\n\n            return new CrmAnalyticsSummaryDto\n            {\n                TotalContacts = totalContacts,\n                TaggedContacts = taggedContacts,\n                ActiveReminders = activeReminders,\n                CompletedReminders = completedReminders,\n                TotalNotes = totalNotes,\n                LeadsWithTimeline = leadsWithTimeline,\n                NewContactsToday = newContactsToday,\n                NotesAddedToday = notesAddedToday,\n                LastContactAddedAt = lastContactAddedAt,\n                LastReminderCompletedAt = lastReminderCompletedAt\n            };\n        }\n        public async Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId)\n        {\n            var trends = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.CreatedAt.Date)\n                .OrderBy(g => g.Key)\n                .Select(g => new ContactTrendsDto\n                {\n                    Date = g.Key.ToString(\"yyyy-MM-dd\"),\n                    Count = g.Count()\n                })\n                .ToListAsync();\n\n            return trends;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/ICrmAnalyticsService.cs",
      "sha256": "24d70810ed26415792ab48592900090d8d1b7682d926e46f4bdc4595b24c5659",
      "language": "csharp",
      "size": 895,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Defines the contract for CRM Analytics services.\n    /// Handles lead-level analytics, summary metrics, and dashboard insights.\n    /// </summary>\n    public interface ICrmAnalyticsService\n    {\n        /// <summary>\n        /// Returns a summarized view of CRM statistics for a specific business.\n        /// This is used to power the CRM analytics dashboard.\n        /// </summary>\n        /// <param name=\"businessId\">The unique identifier of the business (tenant).</param>\n        /// <returns>A summary DTO containing contact, tag, note, and reminder insights.</returns>\n        Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId);\n        Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "f5084d9a24f2667d21707e1893b4a3c8a09a3e5b14aceb728043514a7b5d8261",
      "language": "csharp",
      "size": 9864,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Controllers/CTAFlowController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Helpers;\n\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly ITrackingService _trackingService;\n        public CTAFlowController(ICTAFlowService flowService, IMessageEngineService messageEngineService, ITrackingService trackingService)\n        {\n            _flowService = flowService;\n            _messageEngineService = messageEngineService;\n            _trackingService = trackingService;\n        }\n\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> CreateFlow([FromBody] CreateFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n            var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n            return Ok(new { flowId = id });\n        }\n\n        [HttpPost(\"publish\")]\n        public async Task<IActionResult> PublishFlow([FromBody] List<FlowStepDto> steps)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n            var result = await _flowService.PublishFlowAsync(businessId, steps, createdBy);\n            if (!result.Success)\n                return BadRequest(result.Message);\n\n            return Ok(\"‚úÖ Flow published successfully.\");\n        }\n\n        [HttpGet(\"current\")]\n        public async Task<IActionResult> GetFlow()\n        {\n            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdHeader, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing BusinessId header.\");\n\n            var flow = await _flowService.GetFlowByBusinessAsync(businessId);\n\n            // ‚úÖ Always return 200 even if flow is null\n            return Ok(flow);\n        }\n\n        [HttpGet(\"draft\")]\n        public async Task<IActionResult> GetDraftFlow()\n        {\n            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdHeader, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing BusinessId header.\");\n\n            var draft = await _flowService.GetDraftFlowByBusinessAsync(businessId);\n            if (draft == null)\n                return NotFound(\"‚ùå No draft flow found.\");\n\n            return Ok(draft);\n        }\n\n        [HttpGet(\"by-id/{id}\")]\n        public async Task<IActionResult> GetFlowById(Guid id)\n        {\n            var flow = await _flowService.GetVisualFlowByIdAsync(id);\n            if (flow == null) return NotFound(\"‚ùå Flow not found\");\n            return Ok(flow);\n        }\n\n        //[HttpGet(\"match\")]\n        //public async Task<IActionResult> MatchButton([FromQuery] string text, [FromQuery] string type)\n        //{\n        //    var businessId = Guid.Parse(User.FindFirst(\"businessId\")?.Value);\n\n        //    var step = await _flowService.MatchStepByButtonAsync(businessId, text, type, currentTemplateName,);\n        //    if (step == null)\n        //        return NotFound(\"‚ùå No matching step found.\");\n\n        //    return Ok(new\n        //    {\n        //        step.TemplateToSend,\n        //        step.TriggerButtonText,\n        //        step.TriggerButtonType\n        //    });\n        //}\n\n        [HttpGet(\"match\")]\n        public async Task<IActionResult> MatchButton(\n    [FromQuery] string text,\n    [FromQuery] string type,\n    [FromQuery] string currentTemplateName,\n    [FromQuery] Guid? campaignId) // Optional\n        {\n            var businessId = Guid.Parse(User.FindFirst(\"businessId\")?.Value!);\n\n            var step = await _flowService.MatchStepByButtonAsync(\n                businessId,\n                text,\n                type,\n                currentTemplateName,\n                campaignId\n            );\n\n            if (step == null)\n                return NotFound(\"‚ùå No matching step found.\");\n\n            return Ok(new\n            {\n                step.TemplateToSend,\n                step.TriggerButtonText,\n                step.TriggerButtonType\n            });\n        }\n\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                Log.Error(\"‚ùå Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n                return StatusCode(500, new\n                {\n                    message = \"‚ùå Failed to save flow\",\n                    error = result.ErrorMessage,\n                    // skipped = result.SkippedNodes ?? 0\n                });\n            }\n\n            return Ok(new\n            {\n                message = \"‚úÖ Flow saved successfully\"\n            });\n        }\n\n        [HttpDelete(\"delete/{id}\")]\n        public async Task<IActionResult> DeleteFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId);\n\n            return result.Success\n                ? Ok(new { message = result.Message })\n                : BadRequest(new { message = result.Message });\n        }\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // üìÑ File: D:\\...\\Features\\CTAFlowBuilder\\Controllers\\CTAFlowController.cs\n\n        [HttpPost(\"execute-visual\")]\n        public async Task<IActionResult> ExecuteVisualFlowAsync(\n            [FromQuery] Guid nextStepId,\n            [FromQuery] Guid trackingLogId,\n            // ‚úÖ 1. ADD the new optional parameter to the endpoint\n            [FromQuery] Guid? campaignSendLogId = null)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            // ‚úÖ 2. PASS the new parameter to the service call\n            var result = await _flowService.ExecuteVisualFlowAsync(businessId, nextStepId, trackingLogId, campaignSendLogId);\n\n            if (result.Success)\n                return Ok(result);\n            else\n                return BadRequest(result);\n        }\n\n        [HttpPost(\"create-config\")]\n        public async Task<IActionResult> CreateConfigFlow([FromBody] CreateFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n            try\n            {\n                var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n\n                return Ok(new\n                {\n                    flowId = id,\n                    message = \"‚úÖ Flow config created successfully.\"\n                });\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, new\n                {\n                    error = \"‚ùå Failed to create flow config.\",\n                    details = ex.Message\n                });\n            }\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// üìÑ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // üîí Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null ‚Üí terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // üÜï Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "5b1f9625b329b229575e5859cfacacaa1520238bff1573e6a34b34c4c85120b3",
      "language": "csharp",
      "size": 1118,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // ‚úÖ e.g., \"image_template\", \"text_template\"\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        //(for flow trigger mapping)\n        // ‚úÖ NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // üî• e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // üî• e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // üî• the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // üîÑ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // ‚úÖ Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "3f05a1457051adfc7e66c759040348f1288066c7abcf4c570c0b2fd5c98da19e",
      "language": "csharp",
      "size": 1123,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // ‚úÖ Add this line\n\n        // üîÅ Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "1469836c27765675fb8f7ea910ffabd76fdc9ec583c0e3e3c0f9a986f6fb83db",
      "language": "csharp",
      "size": 1352,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // üîÄ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // ‚úÖ NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "3288e0095ae888c5f42e669c9bd44c204cec5d167c37a928862137eaa5276988",
      "language": "csharp",
      "size": 1426,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CTAFlowService.cs",
      "sha256": "f62aa8e7e41961f339b02dcd003a4234c7207c3ae71b6919063665343dbf52fe",
      "language": "csharp",
      "size": 34515,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Services/CTAFlowService.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class CTAFlowService : ICTAFlowService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        public CTAFlowService(AppDbContext context, IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService\n            )\n        {\n            _context = context;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        public async Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy)\n        {\n            var flow = new CTAFlowConfig\n            {\n                Id = Guid.NewGuid(),\n                FlowName = dto.FlowName,\n                BusinessId = businessId,\n                CreatedAt = DateTime.UtcNow,\n                CreatedBy = createdBy,\n                IsPublished = dto.IsPublished\n            };\n\n            foreach (var stepDto in dto.Steps)\n            {\n                var step = new CTAFlowStep\n                {\n                    Id = Guid.NewGuid(),\n                    CTAFlowConfigId = flow.Id,\n                    TriggerButtonText = stepDto.TriggerButtonText,\n                    TriggerButtonType = stepDto.TriggerButtonType,\n                    TemplateToSend = stepDto.TemplateToSend,\n                    StepOrder = stepDto.StepOrder,\n                    ButtonLinks = stepDto.ButtonLinks?.Select(link => new FlowButtonLink\n                    {\n                        ButtonText = link.ButtonText,\n                        NextStepId = link.NextStepId\n                    }).ToList() ?? new List<FlowButtonLink>()\n                };\n\n                flow.Steps.Add(step);\n            }\n\n            _context.CTAFlowConfigs.Add(flow);\n            await _context.SaveChangesAsync();\n\n            return flow.Id;\n        }\n\n        public async Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Include(f => f.Steps.OrderBy(s => s.StepOrder))\n                .Where(f => f.BusinessId == businessId && f.IsActive && f.IsPublished)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .Where(f => f.BusinessId == businessId && f.IsPublished == false)\n                .OrderByDescending(f => f.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n\n\n        public async Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId)\n        {\n            return await _context.CTAFlowSteps\n                .Where(s => s.CTAFlowConfigId == flowId)\n                .OrderBy(s => s.StepOrder)\n                .ToListAsync();\n        }\n\n        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n            Guid businessId,\n            string buttonText,\n            string buttonType,\n            string TemplateName,\n            Guid? campaignId = null)\n        {\n            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n            var normalizedTemplateName = TemplateName?.Trim().ToLower() ?? \"\";\n\n            // 1Ô∏è‚É£ Try campaign-specific override\n            if (campaignId.HasValue)\n            {\n                var overrideStep = await _context.CampaignFlowOverrides\n                    .Where(o =>\n                        o.CampaignId == campaignId &&\n                        o.ButtonText.ToLower() == normalizedButtonText &&\n                        o.TemplateName.ToLower() == normalizedTemplateName)\n                    .FirstOrDefaultAsync();\n\n                if (overrideStep != null)\n                {\n                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n\n                    var matched = await _context.CTAFlowSteps\n                        .Include(s => s.Flow)\n                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n\n                    if (matched != null)\n                    {\n                        Log.Information(\"üîÅ Override matched: Template '{Template}' ‚Üí Step '{StepId}'\", overrideStep.OverrideNextTemplate, matched.Id);\n                        return matched;\n                    }\n\n                    Log.Warning(\"‚ö†Ô∏è Override found for button '{Button}' but no matching step for template '{Template}'\", normalizedButtonText, overrideStep.OverrideNextTemplate);\n                }\n\n                else\n                {\n                    Log.Information(\"üü° No campaign override found for button '{Button}' on template '{Template}'\", normalizedButtonText, normalizedTemplateName);\n                }\n            }\n\n            // 2Ô∏è‚É£ Fallback to standard flow logic\n            var fallbackStep = await _context.CTAFlowSteps\n                .Include(s => s.Flow)\n                .Where(s =>\n                    s.Flow.BusinessId == businessId &&\n                    s.Flow.IsActive &&\n                    s.Flow.IsPublished &&\n                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n                .FirstOrDefaultAsync();\n\n            if (fallbackStep != null)\n            {\n                Log.Information(\"‚úÖ Fallback flow step matched: StepId = {StepId}, Flow = {FlowName}\", fallbackStep.Id, fallbackStep.Flow?.FlowName);\n            }\n            else\n            {\n                Log.Warning(\"‚ùå No fallback step matched for button '{ButtonText}' of type '{ButtonType}' in BusinessId: {BusinessId}\", normalizedButtonText, normalizedButtonType, businessId);\n            }\n\n            return fallbackStep;\n        }\n\n\n\n        public async Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy)\n        {\n            try\n            {\n                // üî• 1. Remove existing published flow for this business\n                var existingFlows = await _context.CTAFlowConfigs\n                    .Where(f => f.BusinessId == businessId && f.IsPublished)\n                    .ToListAsync();\n\n                if (existingFlows.Any())\n                {\n                    _context.CTAFlowConfigs.RemoveRange(existingFlows);\n                }\n\n                // üå± 2. Create new flow config\n                var flowConfig = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = \"Published Flow - \" + DateTime.UtcNow.ToString(\"yyyyMMdd-HHmm\"),\n                    IsPublished = true,\n                    IsActive = true,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    Steps = new List<CTAFlowStep>()\n                };\n\n                // üîÅ 3. Convert each step DTO to model\n                foreach (var stepDto in steps)\n                {\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flowConfig.Id,\n                        TriggerButtonText = stepDto.TriggerButtonText,\n                        TriggerButtonType = stepDto.TriggerButtonType,\n                        TemplateToSend = stepDto.TemplateToSend,\n                        StepOrder = stepDto.StepOrder,\n                        ButtonLinks = stepDto.ButtonLinks.Select(bl => new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            ButtonText = bl.ButtonText,\n                            NextStepId = bl.NextStepId,\n                        }).ToList()\n                    };\n\n                    flowConfig.Steps.Add(step);\n                }\n\n                // üíæ 4. Save to DB\n                await _context.CTAFlowConfigs.AddAsync(flowConfig);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Flow published successfully.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error while publishing CTA flow.\");\n                return ResponseResult.ErrorInfo(\"‚ùå Could not publish flow.\");\n            }\n        }\n\n        public async Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy)\n        {\n            try\n            {\n                Log.Information(\"üß† SaveVisualFlow started | FlowName: {FlowName} | BusinessId: {BusinessId}\", dto.FlowName, businessId);\n\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                {\n                    Log.Warning(\"‚ùå No nodes found in flow. Aborting save.\");\n                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n                }\n\n                // 1) Upsert FlowConfig\n                var flow = await _context.CTAFlowConfigs\n                    .FirstOrDefaultAsync(f => f.FlowName == dto.FlowName && f.BusinessId == businessId);\n\n                if (flow == null)\n                {\n                    flow = new CTAFlowConfig\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        FlowName = dto.FlowName,\n                        CreatedBy = createdBy,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow,\n                        IsActive = true,\n                        IsPublished = dto.IsPublished\n                    };\n                    _context.CTAFlowConfigs.Add(flow);\n                    Log.Information(\"‚úÖ New FlowConfig created with ID: {Id}\", flow.Id);\n                }\n                else\n                {\n                    // wipe old steps+links for a clean replace\n                    var oldSteps = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == flow.Id)\n                        .Include(s => s.ButtonLinks)\n                        .ToListAsync();\n\n                    foreach (var step in oldSteps)\n                        _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n                    _context.CTAFlowSteps.RemoveRange(oldSteps);\n\n                    flow.IsPublished = dto.IsPublished;\n                    flow.UpdatedAt = DateTime.UtcNow;\n                }\n\n                // 2) Build Steps (map by incoming node.Id string)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n\n                foreach (var (node, index) in dto.Nodes.Select((n, i) => (n, i)))\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id))\n                        continue;\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = index,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // 3) Build Links PER NODE using buttons order (with Index), not per-edge blindly\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    // outgoing edges from this node\n                    var outEdges = dto.Edges?.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList()\n                                   ?? new List<FlowEdgeDto>();\n\n                    // dedupe by button text to avoid ambiguous routing\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n                    // stable ordering: by provided Index (0..N), then by Text\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text))\n                            continue;\n\n                        if (!seenTexts.Add(text))\n                        {\n                            Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; keeping first, skipping duplicates.\", text, node.Id);\n                            continue;\n                        }\n\n                        // match edge by SourceHandle == button text (how ReactFlow wires handles)\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null)\n                        {\n                            // no wire from this button ‚Üí skip link creation but keep button metadata in UI on reload\n                            continue;\n                        }\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep))\n                            continue;\n\n                        // final index: prefer incoming payload Index; else fallback to a sequential counter\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex // üîë persist the index\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // propagate trigger info on the target step for convenience\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Flow '{Flow}' saved | Steps: {StepCount} | Links: {LinkCount}\",\n                    dto.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Flow saved successfully.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while saving flow\");\n                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n            }\n        }\n\n        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(c => c.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(c => c.Id == flowId && c.IsActive);\n\n            if (flow == null) return null;\n\n            var businessId = flow.BusinessId;\n\n            // ‚úÖ Pre-fetch templates from Meta\n            var templateMap = new Dictionary<string, TemplateMetadataDto>();\n\n            foreach (var step in flow.Steps)\n            {\n                if (!string.IsNullOrWhiteSpace(step.TemplateToSend) && !templateMap.ContainsKey(step.TemplateToSend))\n                {\n                    try\n                    {\n                        var template = await _templateFetcherService.GetTemplateByNameAsync(\n                            businessId,\n                            step.TemplateToSend,\n                            includeButtons: true\n                        );\n\n                        if (template != null)\n                            templateMap[step.TemplateToSend] = template;\n                    }\n                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from Meta for {Template}\", step.TemplateToSend);\n                    }\n                }\n            }\n\n            // ‚úÖ Map into ReactFlow-compatible structure\n            var nodes = flow.Steps.Select(step =>\n            {\n                var template = templateMap.GetValueOrDefault(step.TemplateToSend);\n\n                return new FlowNodeDto\n                {\n                    Id = step.Id.ToString(),\n                    TemplateName = step.TemplateToSend,\n                    MessageBody = template?.Body ?? \"Message body preview...\",\n                    TriggerButtonText = step.TriggerButtonText,\n                    TriggerButtonType = step.TriggerButtonType,\n                    PositionX = step.PositionX ?? 100,\n                    PositionY = step.PositionY ?? 100,\n\n                    // ‚úÖ NEW: Include conditional logic\n                    RequiredTag = step.RequiredTag,\n                    RequiredSource = step.RequiredSource,\n\n                    //Buttons = step.ButtonLinks.Select(link => new LinkButtonDto\n                    //{\n                    //    Text = link.ButtonText,\n                    //    TargetNodeId = link.NextStepId.ToString()\n                    //}).ToList()\n                    Buttons = step.ButtonLinks.Select(link => new LinkButtonDto\n                    {\n                        Text = link.ButtonText,\n                        Type = link.ButtonType,\n                        SubType = link.ButtonSubType,\n                        Value = link.ButtonValue,\n                        TargetNodeId = link.NextStepId?.ToString()\n                    }).ToList()\n\n                             .Concat((template?.ButtonParams ?? new List<ButtonMetadataDto>())\n                                 .Where(btn => !step.ButtonLinks.Any(bl => bl.ButtonText == btn.Text))\n                                 .Select(btn => new LinkButtonDto\n                                 {\n                                     Text = btn.Text,\n                                     TargetNodeId = null\n                                 })).ToList()\n                };\n\n            }).ToList();\n\n            return new SaveVisualFlowDto\n            {\n                FlowName = flow.FlowName,\n                IsPublished = flow.IsPublished,\n                Nodes = nodes,\n                Edges = flow.Steps\n                        .SelectMany(step =>\n                            step.ButtonLinks.Select(link => new FlowEdgeDto\n                            {\n                                FromNodeId = step.Id.ToString(),\n                                ToNodeId = link.NextStepId.ToString(),\n                                SourceHandle = link.ButtonText // ‚úÖ important\n                            })\n                        ).ToList()\n\n            };\n        }\n\n\n        public async Task<ResponseResult> DeleteFlowAsync(Guid id, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Where(f => f.Id == id && f.BusinessId == businessId)\n                .FirstOrDefaultAsync();\n\n            if (flow == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n            _context.CTAFlowConfigs.Remove(flow);\n            await _context.SaveChangesAsync();\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted successfully.\");\n        }\n        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && f.IsPublished)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    CreatedAt = f.CreatedAt,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n\n        public async Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber)\n        {\n            // Log.Information(\"üöÄ Executing follow-up for BusinessId: {BusinessId}, CurrentStepId: {StepId}\", businessId);\n            if (currentStep == null)\n            {\n                Log.Warning(\"‚ö†Ô∏è Cannot execute follow-up. Current step is null.\");\n                return ResponseResult.ErrorInfo(\"Current step not found.\");\n            }\n\n            // üß† Step: Look through all button links for a valid NextStepId\n            var nextLink = currentStep.ButtonLinks.FirstOrDefault(link => link.NextStepId != null);\n\n            if (nextLink == null)\n            {\n                Log.Information(\"‚ÑπÔ∏è No NextStepId defined in any ButtonLinks for StepId: {StepId}\", currentStep.Id);\n                return ResponseResult.SuccessInfo(\"No follow-up step to execute.\");\n            }\n\n            // üîç Fetch the next step using new logic (via CTAFlowConfig + Steps)\n            // 1Ô∏è‚É£ Try to resolve with smart condition check\n            var followUpStep = await GetChainedStepAsync(businessId, nextLink.NextStepId, null, null);\n\n            if (followUpStep == null)\n            {\n                Log.Warning(\"‚ùå Follow-up step skipped due to condition mismatch ‚Üí StepId: {StepId}\", nextLink.NextStepId);\n\n                // 2Ô∏è‚É£ Optional fallback: Try same flow ‚Üí Any step without conditions\n                var flow = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.IsPublished);\n\n                followUpStep = flow?.Steps\n                    .Where(s => string.IsNullOrEmpty(s.RequiredTag) && string.IsNullOrEmpty(s.RequiredSource))\n                    .OrderBy(s => s.StepOrder)\n                    .FirstOrDefault();\n\n                if (followUpStep != null)\n                {\n                    Log.Information(\"üîÅ Fallback step selected ‚Üí StepId: {StepId}, Template: {Template}\",\n                        followUpStep.Id, followUpStep.TemplateToSend);\n                }\n                else\n                {\n                    Log.Warning(\"üö´ No suitable fallback found in flow. Skipping follow-up.\");\n                    return ResponseResult.SuccessInfo(\"No matching follow-up step based on user context.\");\n                }\n            }\n\n\n            // üì® Send the follow-up message using the TemplateToSend field\n            try\n            {\n                var template = followUpStep.TemplateToSend;\n\n                Log.Information(\"üì§ Sending follow-up message ‚Üí Template: {Template}, To: {Recipient}\", template, recipientNumber);\n\n                // üß™ Replace this with actual message engine call\n                var sendDto = new SimpleTemplateMessageDto\n                {\n                    RecipientNumber = recipientNumber,\n                    TemplateName = template,\n                    TemplateParameters = new List<string>() // Add dynamic params later if needed\n                };\n\n                var sendResult = await _messageEngineService\n     .SendTemplateMessageSimpleAsync(businessId, sendDto);\n\n                if (!sendResult.Success)\n                {\n                    Log.Warning(\"‚ùå Follow-up message send failed ‚Üí {Template}\", template);\n                    return ResponseResult.ErrorInfo(\"Follow-up send failed.\", sendResult.ErrorMessage);\n                }\n\n\n                return ResponseResult.SuccessInfo($\"Follow-up message sent using template: {template}\", null, sendResult.RawResponse);\n\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error sending follow-up message for StepId: {StepId}\", followUpStep.Id);\n                return ResponseResult.ErrorInfo(\"Failed to send follow-up.\");\n            }\n        }\n        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n        {\n            return GetChainedStepAsync(businessId, nextStepId, null, null); // Forward to full logic\n        }\n\n        // ‚úÖ Extended logic with condition check (Tag + Source)\n        public async Task<CTAFlowStep?> GetChainedStepAsync(\n            Guid businessId,\n            Guid? nextStepId,\n            TrackingLog? trackingLog = null,\n            Contact? contact = null)\n        {\n            if (nextStepId == null)\n            {\n                Log.Information(\"‚ÑπÔ∏è No NextStepId provided ‚Äî skipping follow-up.\");\n                return null;\n            }\n\n            try\n            {\n                var flow = await _context.CTAFlowConfigs\n                    .Include(f => f.Steps)\n                    .FirstOrDefaultAsync(f =>\n                        f.BusinessId == businessId &&\n                        f.Steps.Any(s => s.Id == nextStepId));\n\n                if (flow == null)\n                {\n                    Log.Warning(\"‚ö†Ô∏è No flow found containing NextStepId: {NextStepId} for business: {BusinessId}\", nextStepId, businessId);\n                    return null;\n                }\n\n                var followUpStep = flow.Steps.FirstOrDefault(s => s.Id == nextStepId);\n\n                if (followUpStep == null)\n                {\n                    Log.Warning(\"‚ùå Step matched in flow but not found in step list: {NextStepId}\", nextStepId);\n                    return null;\n                }\n\n                // ‚úÖ Check RequiredTag / Source match\n                if (trackingLog != null)\n                {\n                    var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n\n                    if (!isMatch)\n                    {\n                        Log.Information(\"üö´ Step {StepId} skipped due to condition mismatch [Tag: {Tag}, Source: {Source}]\",\n                            followUpStep.Id, followUpStep.RequiredTag, followUpStep.RequiredSource);\n                        return null;\n                    }\n                }\n\n                Log.Information(\"‚úÖ Follow-up step found and matched ‚Üí StepId: {StepId}, Template: {Template}\",\n                    followUpStep.Id, followUpStep.TemplateToSend);\n\n                return followUpStep;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while fetching chained step for NextStepId: {NextStepId}\", nextStepId);\n                throw;\n            }\n        }\n\n        // ‚úÖ Optional helper for resolving from TrackingLogId\n        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(\n            Guid businessId,\n            Guid? nextStepId,\n            Guid? trackingLogId)\n        {\n            var log = await _context.TrackingLogs\n                .Include(l => l.Contact)\n                    .ThenInclude(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n        }\n       \n        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n        {\n            try\n            {\n                Log.Information(\"üö¶ Executing Visual Flow ‚Üí StepId: {StepId} | TrackingLogId: {TrackingLogId}\", startStepId, trackingLogId);\n\n                var log = await _context.TrackingLogs\n                    .Include(l => l.Contact)\n                        .ThenInclude(c => c.ContactTags)\n                            .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n                if (log == null)\n                {\n                    Log.Warning(\"‚ùå TrackingLog not found for ID: {TrackingLogId}\", trackingLogId);\n                    return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n                }\n\n                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n\n                if (step == null)\n                {\n                    Log.Warning(\"‚ùå No flow step matched or conditions failed ‚Üí StepId: {StepId}\", startStepId);\n                    return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n                }\n\n                ResponseResult sendResult;\n\n                // This switch block remains unchanged\n                switch (step.TemplateType?.ToLower())\n                {\n                    case \"image_template\":\n                        var imageDto = new ImageTemplateMessageDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            LanguageCode = \"en_US\"\n                        };\n                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n                        break;\n\n                    case \"text_template\":\n                    default:\n                        var textDto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            TemplateParameters = new()\n                        };\n                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n                        break;\n                }\n\n                // ‚úÖ 2. SAVE the new ID to the log\n                var executionLog = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    StepId = step.Id,\n                    FlowId = step.CTAFlowConfigId,\n                    CampaignSendLogId = campaignSendLogId, // <-- THE NEW VALUE IS SAVED HERE\n                    TrackingLogId = trackingLogId,\n                    ContactPhone = log.ContactPhone,\n                    TriggeredByButton = step.TriggerButtonText,\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow\n                };\n\n                _context.FlowExecutionLogs.Add(executionLog);\n                await _context.SaveChangesAsync();\n\n                if (sendResult.Success)\n                {\n                    Log.Information(\"‚úÖ Flow step executed ‚Üí Template: {Template} sent to {To}\", step.TemplateToSend, log.ContactPhone);\n                }\n                else\n                {\n                    Log.Warning(\"‚ùå Failed to send template from flow ‚Üí {Reason}\", sendResult.ErrorMessage);\n                }\n\n                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n            }\n        }\n\n        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n        {\n            return await _context.FlowButtonLinks\n     .Where(l => l.CTAFlowStepId == sourceStepId\n              && l.NextStepId != null\n              && l.Step.CTAFlowConfigId == flowId\n              && l.ButtonIndex == buttonIndex)\n     .SingleOrDefaultAsync();\n\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowRuntimeService.cs",
      "sha256": "da8d52ff8e4ae751bc8096a74f74d271cd7fe2b585955a9a669b564b5aa2fa2d",
      "language": "csharp",
      "size": 9059,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat_api.WhatsAppSettings.Services; \n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class FlowRuntimeService : IFlowRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        \n        public FlowRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService)\n        {\n            _dbContext = dbContext;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        {\n            try\n            {\n                // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n                if (context.ClickedButton != null &&\n                    context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = context.SourceStepId,\n                        StepName = \"URL_REDIRECT\",\n                        MessageLogId = context.MessageLogId,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = true,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult\n                    {\n                        Success = true,\n                        RedirectUrl = context.ClickedButton.ButtonValue\n                    };\n                }\n\n                // 2) Load next step in the same flow\n                var targetStep = await _dbContext.CTAFlowSteps\n                    .Include(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n                                              s.CTAFlowConfigId == context.FlowId);\n\n                if (targetStep == null)\n                    return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n                if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n                    return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n                var templateName = targetStep.TemplateToSend.Trim();\n\n                // 3) ‚úÖ Preflight the template to pick the correct language and catch 132001 early\n                var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                    context.BusinessId, templateName, includeButtons: true);\n\n                if (meta == null)\n                {\n                    // log a failed flow execution (no WA call attempted)\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = targetStep.Id,\n                        StepName = templateName,\n                        MessageLogId = null,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = false,\n                        ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n                        RawResponse = null,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult\n                    {\n                        Success = false,\n                        Error = $\"Template '{templateName}' not found or not approved.\"\n                    };\n                }\n\n                // prefer the template‚Äôs actual language over hard-coding \"en_US\"\n                var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n                // (Optional) build body/button components here if your step needs params.\n                // Quick-reply buttons require NO components; dynamic URL buttons would.\n                var components = new List<object>();\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = context.ContactPhone,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = templateName,\n                        language = new { code = languageCode },\n                        components\n                    }\n                };\n\n                var sendResult = await _messageEngineService.SendPayloadAsync(context.BusinessId, payload);\n\n                // 4) Snapshot buttons for robust click mapping later\n                string? buttonBundleJson = null;\n                if (targetStep.ButtonLinks?.Count > 0)\n                {\n                    var bundle = targetStep.ButtonLinks\n                        .OrderBy(b => b.ButtonIndex)\n                        .Select(b => new\n                        {\n                            i = b.ButtonIndex,\n                            t = b.ButtonText ?? \"\",\n                            ty = b.ButtonType ?? \"QUICK_REPLY\",\n                            v = b.ButtonValue ?? \"\",\n                            ns = b.NextStepId\n                        })\n                        .ToList();\n\n                    buttonBundleJson = JsonSerializer.Serialize(bundle);\n                }\n\n                // 5) ‚úÖ Write MessageLog with NON-NULL MessageContent and sensible timestamps\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    RecipientNumber = context.ContactPhone,\n                    CTAFlowConfigId = context.FlowId,\n                    CTAFlowStepId = targetStep.Id,\n                    FlowVersion = context.Version,\n                    Source = \"flow\",\n                    RefMessageId = context.MessageLogId, // correlate to the parent WA msg (if any)\n                    CreatedAt = DateTime.UtcNow,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    MessageId = sendResult.MessageId,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ButtonBundleJson = buttonBundleJson,\n\n                    // üî¥ This was missing before ‚Üí caused NOT NULL violation\n                    MessageContent = templateName,\n\n                    // good hygiene: stamp SentAt on success\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null,\n                };\n\n                _dbContext.MessageLogs.Add(messageLog);\n\n                // 6) Flow execution audit row\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = targetStep.Id,\n                    StepName = templateName,\n                    MessageLogId = messageLog.Id,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId,\n\n                    // Optional (only if your entity has these columns):\n                    // TemplateName = templateName,\n                    // TemplateType = targetStep.TemplateType,\n                });\n\n                await _dbContext.SaveChangesAsync();\n\n                return new NextStepResult\n                {\n                    Success = sendResult.Success,\n                    Error = sendResult.ErrorMessage,\n                    RedirectUrl = null\n                };\n            }\n            catch (Exception ex)\n            {\n                return new NextStepResult { Success = false, Error = ex.Message };\n            }\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICTAFlowService.cs",
      "sha256": "12d6c4050a662826cb8281e72efb15cc621bb2b6e26b04981f6ca819603d7644",
      "language": "csharp",
      "size": 2166,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface ICTAFlowService\n    {\n        // ‚úÖ Used for flow creation and saving\n        Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy);\n        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n        // ‚úÖ Load flows\n        Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId);\n        Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n        // ‚úÖ Load and manage flow steps\n        Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId);\n\n      \n        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText,string buttonType,string currentTemplateName,Guid? campaignId = null);\n\n\n        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n        // ‚úÖ Runtime logic\n        Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber);\n\n        // ‚úÖ Flow management\n        Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy);\n        Task<ResponseResult> DeleteFlowAsync(Guid id, Guid businessId);\n\n        // ‚úÖ Editor loading (visual builder)\n        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid id);\n\n      \n        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n        public interface IFlowRuntimeService\n        {\n            Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowRuntimeService.cs",
      "sha256": "302d771fe1f82a2dc8291fd65dcc3ccd58ab0c29af0220409d04db3f7b85020a",
      "language": "csharp",
      "size": 951,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface IFlowRuntimeService\n    {\n        Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n\n    }\n    public record NextStepContext\n    {\n        public Guid BusinessId { get; set; }\n        public Guid FlowId { get; set; }\n        public int Version { get; set; }\n        public Guid SourceStepId { get; set; }\n        public Guid? TargetStepId { get; set; }\n        public short ButtonIndex { get; set; }\n        public Guid MessageLogId { get; set; }\n        public string ContactPhone { get; set; } = string.Empty;\n        public Guid RequestId { get; set; }\n\n        public FlowButtonLink? ClickedButton { get; set; }\n    }\n\n    public record NextStepResult\n    {\n        public bool Success { get; set; }\n        public string? Error { get; set; }\n        public string? RedirectUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/StepMatchingHelper.cs",
      "sha256": "3353c5195c81af5b7a26a5a7f648e6dc4504f54633d408220670d2dba65a5888",
      "language": "csharp",
      "size": 1818,
      "content": "using Serilog;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public static class StepMatchingHelper\n    {\n        public static bool IsStepMatched(CTAFlowStep step, TrackingLog log, Contact? contact)\n        {\n            if (!string.IsNullOrWhiteSpace(step.RequiredSource) &&\n                !string.Equals(step.RequiredSource, log.SourceType, StringComparison.OrdinalIgnoreCase))\n            {\n                Log.Information(\"üö´ Step [{StepId}] skipped: RequiredSource '{Required}' ‚â† ClickedSource '{Actual}'\",\n                    step.Id, step.RequiredSource, log.SourceType);\n                return false;\n            }\n\n            if (!string.IsNullOrWhiteSpace(step.RequiredTag))\n            {\n                if (contact == null || contact.ContactTags == null || !contact.ContactTags.Any())\n                {\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact or Tags missing (RequiredTag: {RequiredTag})\",\n                        step.Id, step.RequiredTag);\n                    return false;\n                }\n\n                var hasTag = contact.ContactTags.Any(ct =>\n                    string.Equals(ct.Tag.Name, step.RequiredTag, StringComparison.OrdinalIgnoreCase));\n\n                if (!hasTag)\n                {\n                    var contactTags = string.Join(\", \", contact.ContactTags.Select(ct => ct.Tag.Name));\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact tags [{Tags}] do not include RequiredTag '{Required}'\",\n                        step.Id, contactTags, step.RequiredTag);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Controllers/CTAManagementController.cs",
      "sha256": "3d06022ca06d6b4e214bf6e571b79d311da0902eeadebddc1f7d48c18a1ecb99",
      "language": "csharp",
      "size": 2535,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Services;\n\nnamespace xbytechat.api.Features.CTAManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/ctamanagement\")]\n    [Authorize] // ‚úÖ Ensures only authenticated users can access\n    public class CTAManagementController : ControllerBase\n    {\n        private readonly ICTAManagementService _ctaService;\n\n        public CTAManagementController(ICTAManagementService ctaService)\n        {\n            _ctaService = ctaService;\n        }\n\n        // ‚úÖ GET: api/ctamanagement/get-all\n        [HttpGet(\"get-all\")]\n        public async Task<IActionResult> GetAll()\n        {\n            var data = await _ctaService.GetAllAsync();\n            return Ok(data);\n        }\n\n        // üìå GET: api/ctamanagement/get/{id}\n        [HttpGet(\"get/{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var result = await _ctaService.GetByIdAsync(id);\n            return result == null ? NotFound(\"CTA not found\") : Ok(result);\n        }\n\n        // ‚úÖ POST: api/ctamanagement/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> Create([FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.AddAsync(dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA created.\" })\n                : StatusCode(500, \"‚ùå Failed to create CTA.\");\n        }\n\n        // ‚úèÔ∏è PUT: api/ctamanagement/update/{id}\n        [HttpPut(\"update/{id}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.UpdateAsync(id, dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA updated.\" })\n                : NotFound(\"CTA not found or update failed.\");\n        }\n\n        // üóëÔ∏è DELETE: api/ctamanagement/delete/{id}\n        [HttpDelete(\"delete/{id}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var success = await _ctaService.DeleteAsync(id);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA deleted (soft).\" })\n                : NotFound(\"CTA not found or delete failed.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/DTOs/CTADefinitionDto.cs",
      "sha256": "1472d3694a4cebf363c3a632675fe61b8646f610f7a96a2687286bfb47d8eacf",
      "language": "csharp",
      "size": 707,
      "content": "namespace xbytechat.api.Features.CTAManagement.DTOs\n{\n    public class CTADefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label (e.g., \"Buy Now\")\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label (e.g., \"Buy Now\")\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Expected values: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Redirect or action target\n\n        public string? Description { get; set; } // üìù Optional description (for context/tooltip)\n\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Models/CTADefinition.cs",
      "sha256": "96216798bd31e2098b9a2ba43dac62e067f7062f5e5c36bb318a8dab2f74da38",
      "language": "csharp",
      "size": 913,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAManagement.Models\n{\n    public class CTADefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; } // üîó Business that owns this CTA\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label/title, e.g., \"Buy Now\"\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Options: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Action URL or value (depending on type)\n\n        public string Description { get; set; } = string.Empty; // üìù Optional additional context\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/CTAManagementService.cs",
      "sha256": "a9388986726208c45f05afa2bd4ed3c74b33d7d79eb0e5863b7256e061ba4081",
      "language": "csharp",
      "size": 4621,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Models;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public class CTAManagementService : ICTAManagementService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CTAManagementService(AppDbContext dbContext, IHttpContextAccessor httpContextAccessor)\n        {\n            _dbContext = dbContext;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        // üîÑ Get all active CTAs for the current business\n        public async Task<List<CTADefinitionDto>> GetAllAsync()\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            return await _dbContext.CTADefinitions\n                .Where(c => c.IsActive && c.BusinessId == businessId)\n                .Select(c => new CTADefinitionDto\n                {\n                    Id = c.Id,\n                    Title = c.Title,\n                    ButtonText = c.ButtonText,\n                    ButtonType = c.ButtonType,\n                    TargetUrl = c.TargetUrl,\n                    Description = c.Description,\n                    IsActive = c.IsActive\n                }).ToListAsync();\n        }\n\n        // ‚úÖ Add new CTA\n        public async Task<bool> AddAsync(CTADefinitionDto dto)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = new CTADefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Title = dto.Title,\n                ButtonText = dto.ButtonText,\n                ButtonType = dto.ButtonType,\n                TargetUrl = dto.TargetUrl,\n                Description = dto.Description ?? \"\",\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            await _dbContext.CTADefinitions.AddAsync(cta);\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üìå Get CTA by ID\n        public async Task<CTADefinitionDto?> GetByIdAsync(Guid id)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = await _dbContext.CTADefinitions\n                .FirstOrDefaultAsync(c => c.Id == id && c.IsActive && c.BusinessId == businessId);\n\n            if (cta == null) return null;\n\n            return new CTADefinitionDto\n            {\n                Id = cta.Id,\n                Title = cta.Title,\n                ButtonText = cta.ButtonText,\n                ButtonType = cta.ButtonType,\n                TargetUrl = cta.TargetUrl,\n                Description = cta.Description,\n                IsActive = cta.IsActive\n            };\n        }\n\n\n        // ‚úèÔ∏è Update CTA\n        public async Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to modify this CTA.\");\n\n            cta.Title = dto.Title;\n            cta.ButtonText = dto.ButtonText;\n            cta.ButtonType = dto.ButtonType;\n            cta.TargetUrl = dto.TargetUrl;\n            cta.Description = dto.Description ?? \"\";\n            cta.IsActive = dto.IsActive;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üóëÔ∏è Soft Delete CTA\n        public async Task<bool> DeleteAsync(Guid id)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to delete this CTA.\");\n\n            cta.IsActive = false;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üîê Reusable method to extract BusinessId\n        private Guid GetBusinessIdFromClaims()\n        {\n            var claim = _httpContextAccessor.HttpContext?.User?.FindFirst(\"businessId\");\n            if (claim == null || string.IsNullOrWhiteSpace(claim.Value) || !Guid.TryParse(claim.Value, out var businessId))\n                throw new UnauthorizedAccessException(\"‚ùå Invalid or missing BusinessId claim.\");\n\n            return businessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/ICTAManagementService.cs",
      "sha256": "f05abf40bdd4a593e8c8f8980c288884dc5701a5c9ba29261588816002758bcd",
      "language": "csharp",
      "size": 814,
      "content": "using xbytechat.api.Features.CTAManagement.DTOs;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public interface ICTAManagementService\n    {\n        /// <summary>Returns all active CTAs for the current business.</summary>\n        Task<List<CTADefinitionDto>> GetAllAsync();\n\n        /// <summary>Returns a single CTA by ID (if exists).</summary>\n        Task<CTADefinitionDto?> GetByIdAsync(Guid id);\n\n        /// <summary>Adds a new CTA for the logged-in business.</summary>\n        Task<bool> AddAsync(CTADefinitionDto dto);\n\n        /// <summary>Updates an existing CTA if it belongs to the business.</summary>\n        Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto);\n\n        /// <summary>Soft deletes (deactivates) a CTA entry.</summary>\n        Task<bool> DeleteAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Controllers/FeatureAccessController.cs",
      "sha256": "a22d132286854a629e58eaa52e3ceebc77dcbe65ccb89d849b5c61fbe23f9904",
      "language": "csharp",
      "size": 5482,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\nusing xbytechat.api;\nusing FeatureAccessEntity = xbytechat.api.Features.FeatureAccessModule.Models.FeatureAccess;\n\nusing xbytechat.api.Features.FeatureAccessModule.Models;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/feature-access\")]\n    [Authorize]\n    public class FeatureAccessController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public FeatureAccessController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // DTOs to match your frontend shape\n        public class FeatureMeDto\n        {\n            public string featureCode { get; set; } = \"\";\n            public bool isAvailableInPlan { get; set; }\n            public bool? isOverridden { get; set; } // null = not overridden\n        }\n\n        public class BusinessFeatureDto\n        {\n            public string featureName { get; set; } = \"\";\n            public bool isEnabled { get; set; }\n        }\n\n        /// <summary>\n        /// Returns features for the current user, merged from plan + per-business overrides\n        /// Shape: [{ featureCode, isAvailableInPlan, isOverridden }]\n        /// </summary>\n        [HttpGet(\"me\")]\n        public async Task<IActionResult> GetMyFeatureAccess()\n        {\n            var user = HttpContext.User;\n            if (user?.Identity is not { IsAuthenticated: true })\n                return Unauthorized();\n\n            var role = (user.FindFirst(\"role\")?.Value ?? user.FindFirst(ClaimTypes.Role)?.Value ?? \"business\").ToLower();\n            var plan = (user.FindFirst(\"plan\")?.Value ?? \"basic\").ToLower();\n\n            Guid businessId = Guid.Empty;\n            _ = Guid.TryParse(user.FindFirst(\"businessId\")?.Value, out businessId);\n\n            // Superadmin: grant all known features\n            if (role == \"superadmin\")\n            {\n                var allNames = await _db.FeatureAccess\n                    .AsNoTracking()\n                    .Select(f => f.FeatureName)\n                    .Distinct()\n                    .ToListAsync();\n\n                var super = allNames.Select(name => new FeatureMeDto\n                {\n                    featureCode = name,\n                    isAvailableInPlan = true,\n                    isOverridden = true\n                });\n\n                return Ok(super);\n            }\n\n            // Load plan-level features (same entity type as DbSet)\n            var planRows = await _db.FeatureAccess\n                .AsNoTracking()\n                .Where(f => f.Plan.ToLower() == plan)\n                .ToListAsync();\n\n            // Load business overrides using SAME type; avoid ternary type-mismatch\n            List<FeatureAccessEntity> overrideRows;\n            if (businessId == Guid.Empty)\n            {\n                overrideRows = new();\n            }\n            else\n            {\n                overrideRows = await _db.FeatureAccess\n                    .AsNoTracking()\n                    .Where(f => f.BusinessId == businessId)\n                    .ToListAsync();\n            }\n\n            // Build base from plan, then apply overrides\n            var map = new Dictionary<string, FeatureMeDto>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var p in planRows)\n            {\n                if (!map.ContainsKey(p.FeatureName))\n                {\n                    map[p.FeatureName] = new FeatureMeDto\n                    {\n                        featureCode = p.FeatureName,\n                        isAvailableInPlan = p.IsEnabled,\n                        isOverridden = null\n                    };\n                }\n                else\n                {\n                    map[p.FeatureName].isAvailableInPlan = p.IsEnabled;\n                }\n            }\n\n            foreach (var o in overrideRows)\n            {\n                if (!map.ContainsKey(o.FeatureName))\n                {\n                    map[o.FeatureName] = new FeatureMeDto\n                    {\n                        featureCode = o.FeatureName,\n                        isAvailableInPlan = false,\n                        isOverridden = o.IsEnabled\n                    };\n                }\n                else\n                {\n                    map[o.FeatureName].isOverridden = o.IsEnabled;\n                }\n            }\n\n            return Ok(map.Values.ToArray());\n        }\n\n        /// <summary>\n        /// Returns all features for a business (used by useAllFeatureAccess/useFeatureAccess hooks)\n        /// Shape: [{ featureName, isEnabled }]\n        /// </summary>\n        [HttpGet(\"business/{businessId:guid}\")]\n        public async Task<IActionResult> GetBusinessFeatureAccess([FromRoute] Guid businessId)\n        {\n            // (Optional) enforce tenant isolation:\n            // var currentBiz = HttpContext.User.FindFirst(\"businessId\")?.Value;\n            // if (!Guid.TryParse(currentBiz, out var bizFromToken) || bizFromToken != businessId)\n            //     return Forbid();\n\n            var rows = await _db.FeatureAccess\n                .Where(f => f.BusinessId == businessId)\n                .Select(f => new BusinessFeatureDto\n                {\n                    featureName = f.FeatureName,\n                    isEnabled = f.IsEnabled\n                })\n                .ToListAsync();\n\n            return Ok(rows);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/FeatureAccessDto.cs",
      "sha256": "c418561ae9075f32902a032190e2252c7eab385bbdf1028ddd5748f0190df6de",
      "language": "csharp",
      "size": 409,
      "content": "using System;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.DTOs\n{\n    public class FeatureAccessDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string FeatureName { get; set; } = string.Empty;\n\n        public bool IsEnabled { get; set; }\n\n        public string? Notes { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/FeatureMetadataDto.cs",
      "sha256": "958bb8308ae62a666fd659a66327d6b5cb0a7a66659e4048df206994ea3e9aec",
      "language": "csharp",
      "size": 360,
      "content": "// üìÑ Features/FeatureAccessModule/DTOs/FeatureMetadataDto.cs\nnamespace xbytechat.api.Features.FeatureAccessModule.DTOs\n{\n    public class FeatureMetadataDto\n    {\n        public string FeatureCode { get; set; } = string.Empty;\n        public string Group { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/FeatureStatusDto.cs",
      "sha256": "36dfe2add0ad58f4e5f9e0d572e43bf68a42cc95b17f5654cacb1e7596e9715a",
      "language": "csharp",
      "size": 240,
      "content": "namespace xbytechat.api.Features.FeatureAccess.DTOs;\n\npublic class FeatureStatusDto\n{\n    public string FeatureCode { get; set; } = string.Empty;\n    public bool IsAvailableInPlan { get; set; }\n    public bool? IsOverridden { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/FeatureTogglePatchDto.cs",
      "sha256": "4663d2df320001525fb2b9ff9847b149f77677557a22efbaa7c455ed8ac3c483",
      "language": "csharp",
      "size": 157,
      "content": "namespace xbytechat.api.Features.FeatureAccessModule.DTOs\n{\n    public class FeatureTogglePatchDto\n    {\n        public bool IsEnabled { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/FeatureToggleViewDto.cs",
      "sha256": "cc966666d4e050d9d16f7bab7d10f8c059305fc24a84ea7bd2642eb9a4375e8b",
      "language": "csharp",
      "size": 423,
      "content": "public class FeatureToggleViewDto\n{\n    public string FeatureCode { get; set; } = string.Empty;\n    public string Group { get; set; } = string.Empty;\n    public string Description { get; set; } = string.Empty;\n\n    public bool IsAvailableInPlan { get; set; }     // From PlanManager\n    public bool? IsOverridden { get; set; }         // null if no override\n    public bool IsActive => IsOverridden ?? IsAvailableInPlan;\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/DTOs/UserFeatureAccessDto.cs",
      "sha256": "24a59738ee2f1924903a6e14ecf5ed5a1ce6cbb0269b34013438b37502c2efa9",
      "language": "csharp",
      "size": 520,
      "content": "namespace xbytechat.api.Features.FeatureAccessModule.DTOs\n{\n    public class UserFeatureAccessDto\n    {\n        public Guid Id { get; set; }\n        public string FullName { get; set; } = \"\";\n        public string Email { get; set; } = \"\";\n        public string Role { get; set; } = \"\";\n        public List<FeaturePermissionDto> Permissions { get; set; } = new();\n    }\n\n    public class FeaturePermissionDto\n    {\n        public string FeatureName { get; set; } = \"\";\n        public bool IsEnabled { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Models/FeatureAccess.cs",
      "sha256": "53331121064e4c1559420eb6de1770eb6788b85b404505420f11d5c0bb6b8fe6",
      "language": "csharp",
      "size": 975,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Models\n{\n    [Table(\"FeatureAccess\")]\n    public class FeatureAccess\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(50)]\n        public string FeatureName { get; set; } // e.g. \"CRM\", \"Campaigns\", \"Catalog\"\n        [MaxLength(200)]\n        public string Description { get; set; } = string.Empty;\n        [Required]\n        public bool IsEnabled { get; set; } // ‚úÖ true = allow, false = restrict\n\n        public string? Notes { get; set; } // Optional: reason or context\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        [MaxLength(50)]\n        public string Group { get; set; } = string.Empty;\n        public string? Plan { get; set; } // e.g. \"basic\", \"smart\", \"advanced\"\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Models/FeatureMaster.cs",
      "sha256": "dcf5048b433abe18e2d52542d30fd81664a62f97176fe4ae583ce8218dfb002c",
      "language": "csharp",
      "size": 853,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Models\n{\n    [Table(\"FeatureMaster\")]\n    public class FeatureMaster\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FeatureCode { get; set; } = string.Empty; // e.g. \"crm\", \"catalog\"\n\n        [Required]\n        [MaxLength(100)]\n        public string DisplayName { get; set; } = string.Empty; // e.g. \"CRM\", \"Catalog\"\n\n        [MaxLength(250)]\n        public string Description { get; set; } = string.Empty;\n\n        [MaxLength(50)]\n        public string Group { get; set; } = string.Empty; // Optional grouping like \"CRM\", \"Messaging\"\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Models/UserFeatureAccess.cs",
      "sha256": "894b0a6020dffcbe46247fd5412ef98ab890a641144d089aa7c9c7aa351d0f9b",
      "language": "csharp",
      "size": 778,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Models\n{\n    [Table(\"UserFeatureAccess\")]\n    public class UserFeatureAccess\n    {\n        [Key]\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        [Required]\n        public Guid UserId { get; set; }\n\n        [Required]\n        [MaxLength(50)]\n        public string FeatureName { get; set; } = string.Empty;\n\n        [Required]\n        public bool IsEnabled { get; set; }\n\n        public string? Notes { get; set; }\n\n        public Guid? ModifiedByUserId { get; set; }  // Who applied this override\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Services/FeatureAccessEvaluator.cs",
      "sha256": "b7ad7ecdc58db9f75f5793f8fb207db8b7127f878b4d51a7144c6a71e1c2dd48",
      "language": "csharp",
      "size": 1566,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Services\n{\n    public class FeatureAccessEvaluator : IFeatureAccessEvaluator\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<FeatureAccessEvaluator> _logger;\n\n        public FeatureAccessEvaluator(AppDbContext db, ILogger<FeatureAccessEvaluator> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<bool> CanUseAsync(Guid businessId, string featureCode, Guid? userId)\n        {\n            var business = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null || business.BusinessPlanInfo == null)\n                return false;\n\n            var planEnum = business.BusinessPlanInfo.Plan;\n            var planName = Enum.GetName(typeof(PlanType), planEnum)?.ToLower();\n\n            var planFeatures = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase)\n            {\n                [\"crm\"] = planName == \"smart\" || planName == \"advanced\",\n                [\"campaigns\"] = planName == \"advanced\",\n                [\"catalog\"] = true,\n                [\"automation\"] = planName == \"smart\" || planName == \"advanced\"\n            };\n\n            return planFeatures.TryGetValue(featureCode.ToLower(), out var allowed) && allowed;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Services/FeatureAccessService.cs",
      "sha256": "7968f3a0ef26fa05305fef477338950b8cb824aea9785d56b5d500ef3c376921",
      "language": "csharp",
      "size": 9158,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.FeatureAccess.DTOs;\nusing xbytechat.api.Features.FeatureAccessModule.DTOs;\nusing xbytechat.api.Features.FeatureAccessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Services;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Services\n{\n    public class FeatureAccessService : IFeatureAccessService\n    {\n        private readonly AppDbContext _context;\n        private readonly IPlanManager _planManager;\n        private readonly ILogger<FeatureAccessService> _logger;\n\n        public FeatureAccessService(AppDbContext context, IPlanManager planManager, ILogger<FeatureAccessService> logger)\n        {\n            _context = context;\n            _planManager = planManager;\n            _logger = logger;\n        }\n\n        public async Task<IEnumerable<FeatureAccessDto>> GetAllAsync()\n        {\n            return await _context.FeatureAccess\n                .Select(f => new FeatureAccessDto\n                {\n                    Id = f.Id,\n                    BusinessId = f.BusinessId,\n                    FeatureName = f.FeatureName,\n                    IsEnabled = f.IsEnabled,\n                    Notes = f.Notes,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<IEnumerable<FeatureAccessDto>> GetByBusinessIdAsync(Guid businessId)\n        {\n            return await _context.FeatureAccess\n                .Where(f => f.BusinessId == businessId)\n                .Select(f => new FeatureAccessDto\n                {\n                    Id = f.Id,\n                    BusinessId = f.BusinessId,\n                    FeatureName = f.FeatureName,\n                    IsEnabled = f.IsEnabled,\n                    Notes = f.Notes,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<FeatureAccessDto?> GetAsync(Guid id)\n        {\n            var entity = await _context.FeatureAccess.FindAsync(id);\n            if (entity == null) return null;\n\n            return new FeatureAccessDto\n            {\n                Id = entity.Id,\n                BusinessId = entity.BusinessId,\n                FeatureName = entity.FeatureName,\n                IsEnabled = entity.IsEnabled,\n                Notes = entity.Notes,\n                CreatedAt = entity.CreatedAt\n            };\n        }\n\n        public async Task<FeatureAccessDto> CreateAsync(FeatureAccessDto dto)\n        {\n            var entity = new  xbytechat.api.Features.FeatureAccessModule.Models.FeatureAccess\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n                FeatureName = dto.FeatureName,\n                IsEnabled = dto.IsEnabled,\n                Notes = dto.Notes,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FeatureAccess.Add(entity);\n            await _context.SaveChangesAsync();\n\n            dto.Id = entity.Id;\n            dto.CreatedAt = entity.CreatedAt;\n            return dto;\n        }\n\n        public async Task<FeatureAccessDto> UpdateAsync(Guid id, FeatureAccessDto dto)\n        {\n            var entity = await _context.FeatureAccess.FindAsync(id);\n            if (entity == null)\n                throw new Exception(\"FeatureAccess not found\");\n\n            entity.FeatureName = dto.FeatureName;\n            entity.IsEnabled = dto.IsEnabled;\n            entity.Notes = dto.Notes;\n\n            await _context.SaveChangesAsync();\n\n            return dto;\n        }\n\n        public async Task<bool> DeleteAsync(Guid id)\n        {\n            var entity = await _context.FeatureAccess.FindAsync(id);\n            if (entity == null) return false;\n\n            _context.FeatureAccess.Remove(entity);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<FeatureToggleViewDto>> GetToggleViewAsync(Guid businessId, string plan)\n        {\n            var allFeatures = await _context.FeatureAccess.ToListAsync();\n\n            var planAccessMap = _planManager.GetPlanFeatureMap(plan); // e.g., Dictionary<string, bool>\n\n            var userOverrides = await _context.UserFeatureAccess\n                .Where(x => x.BusinessId == businessId)\n                .ToDictionaryAsync(x => x.FeatureName, x => x.IsEnabled);\n\n            var result = allFeatures.Select(f => new FeatureToggleViewDto\n            {\n                FeatureCode = f.FeatureName,\n                Group = f.Group,\n                Description = f.Description,\n                IsAvailableInPlan = planAccessMap.ContainsKey(f.FeatureName),\n                IsOverridden = userOverrides.TryGetValue(f.FeatureName, out var val) ? val : null\n            }).ToList();\n\n            return result;\n        }\n\n        public async Task ToggleFeatureAsync(Guid businessId, string featureCode, bool isEnabled)\n        {\n            try\n            {\n                var existing = await _context.UserFeatureAccess\n                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.FeatureName == featureCode);\n\n                if (existing != null)\n                {\n                    existing.IsEnabled = isEnabled;\n                    _context.UserFeatureAccess.Update(existing);\n                }\n                else\n                {\n                    var newAccess = new UserFeatureAccess\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        FeatureName = featureCode,\n                        IsEnabled = isEnabled,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    await _context.UserFeatureAccess.AddAsync(newAccess);\n                }\n\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to toggle feature {FeatureCode} for business {BusinessId}\", featureCode, businessId);\n                throw;\n            }\n        }\n\n        public async Task<List<FeatureStatusDto>> GetFeaturesForCurrentUserAsync(Guid businessId)\n        {\n            var business = await _context.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null)\n            {\n                _logger.LogError(\"‚ùå Business not found for feature access: {BusinessId}\", businessId);\n                return new List<FeatureStatusDto>();\n            }\n\n            var planName = business.BusinessPlanInfo?.Plan.ToString() ?? \"basic\"; // Fallback to basic\n            _logger.LogInformation(\"üì¶ Resolved plan for Business {BusinessId}: {Plan}\", businessId, planName);\n\n            var planFeatureMap = _planManager.GetPlanFeatureMap(planName);\n\n            var overrides = await _context.FeatureAccess\n                .Where(f => f.BusinessId == businessId)\n                .ToDictionaryAsync(f => f.FeatureName, f => (bool?)f.IsEnabled);\n            foreach (var kv in overrides)\n                _logger.LogInformation($\"üîß Feature override: {kv.Key} = {kv.Value}\");\n            var allFeatures = planFeatureMap.Keys\n                .Union(overrides.Keys)\n                .Distinct();\n\n            return allFeatures.Select(f => new FeatureStatusDto\n            {\n                FeatureCode = f,\n                IsAvailableInPlan = planFeatureMap.ContainsKey(f),\n                IsOverridden = overrides.ContainsKey(f) ? overrides[f] : null\n            }).ToList();\n        }\n\n        public async Task<List<UserFeatureAccessDto>> GetAllUserPermissionsAsync(Guid businessId)\n        {\n            var users = await _context.Users\n             .Where(u => u.BusinessId == businessId)\n             .Select(u => new UserFeatureAccessDto\n             {\n                 Id = u.Id,\n                 FullName = u.Name, // ‚úÖ Fixed\n                 Email = u.Email,\n                 Role = u.Role.Name, // ‚úÖ Assuming you want role name string\n                 Permissions = _context.UserFeatureAccess\n                     .Where(p => p.BusinessId == businessId && p.UserId == u.Id)\n                     .Select(p => new FeaturePermissionDto\n                     {\n                         FeatureName = p.FeatureName,\n                         IsEnabled = p.IsEnabled\n                     })\n                     .ToList()\n             }).ToListAsync();\n\n\n            return users;\n        }\n        public async Task<Dictionary<string, bool>> GetFeatureMapByBusinessIdAsync(Guid businessId)\n        {\n            return await _context.FeatureAccess\n                .Where(f => f.BusinessId == businessId)\n                .ToDictionaryAsync(f => f.FeatureName.ToLower(), f => f.IsEnabled);\n        }\n        public async Task<Dictionary<string, bool>> GetAllFeatureCodesAsync()\n        {\n            return await _context.FeatureMasters\n                .Select(f => f.FeatureCode.ToLower())\n                .Distinct()\n                .ToDictionaryAsync(k => k, v => true);\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Services/IFeatureAccessEvaluator.cs",
      "sha256": "c469910530df845be90a6d4135c2d39d19993f8abff4b3eefc6e8c05effe373d",
      "language": "csharp",
      "size": 259,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Services\n{\n    public interface IFeatureAccessEvaluator\n    {\n        Task<bool> CanUseAsync(Guid businessId, string featureName, Guid? userId = null);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FeatureAccessModule/Services/IFeatureAccessService.cs",
      "sha256": "6b328b62d7d5356015dc30688fa072e890cac87e55a5c8a12b1e605b05a744f3",
      "language": "csharp",
      "size": 1183,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.FeatureAccess.DTOs;\nusing xbytechat.api.Features.FeatureAccessModule.DTOs;\n\nnamespace xbytechat.api.Features.FeatureAccessModule.Services\n{\n    public interface IFeatureAccessService\n    {\n        Task<IEnumerable<FeatureAccessDto>> GetAllAsync();\n        Task<IEnumerable<FeatureAccessDto>> GetByBusinessIdAsync(Guid businessId);\n        Task<FeatureAccessDto?> GetAsync(Guid id);\n        Task<FeatureAccessDto> CreateAsync(FeatureAccessDto dto);\n        Task<FeatureAccessDto> UpdateAsync(Guid id, FeatureAccessDto dto);\n        Task<bool> DeleteAsync(Guid id);\n\n        Task<List<FeatureToggleViewDto>> GetToggleViewAsync(Guid businessId, string plan);\n        Task ToggleFeatureAsync(Guid businessId, string featureCode, bool isEnabled);\n        Task<List<FeatureStatusDto>> GetFeaturesForCurrentUserAsync(Guid businessId);\n        Task<List<UserFeatureAccessDto>> GetAllUserPermissionsAsync(Guid businessId);\n        Task<Dictionary<string, bool>> GetFeatureMapByBusinessIdAsync(Guid businessId);\n        Task<Dictionary<string, bool>> GetAllFeatureCodesAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Controllers/FlowAnalyticsController.cs",
      "sha256": "18a260235767524c70c33a6a49f8929060e94415ee98ff743590d207242020e3",
      "language": "csharp",
      "size": 2196,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.FlowAnalytics.Services;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Controllers\n{\n    [ApiController]\n    [Route(\"api/flow-analytics\")]\n    public class FlowAnalyticsController : ControllerBase\n    {\n        private readonly IFlowAnalyticsService _analyticsService;\n\n        public FlowAnalyticsController(IFlowAnalyticsService analyticsService)\n        {\n            _analyticsService = analyticsService;\n        }\n\n        // ‚úÖ GET /api/flow-analytics/summary\n        [HttpGet(\"summary\")]\n        [Authorize]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var result = await _analyticsService.GetAnalyticsSummaryAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/most-triggered-steps\n        [HttpGet(\"most-triggered-steps\")]\n        [Authorize]\n        public async Task<IActionResult> GetMostTriggeredSteps()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetMostTriggeredStepsAsync(businessId);\n            return Ok(data);\n        }\n\n        // ‚úÖ GET /api/flow-analytics/step-journey-breakdown?startDate=...&endDate=...\n        [HttpGet(\"step-journey-breakdown\")]\n        [Authorize]\n        public async Task<IActionResult> GetStepJourneyBreakdown([FromQuery] DateTime? startDate, [FromQuery] DateTime? endDate)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid business ID\");\n\n            var data = await _analyticsService.GetStepJourneyBreakdownAsync(businessId, startDate, endDate);\n            return Ok(data);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsStepJourneyDto.cs",
      "sha256": "25c17b6d295eb4faf667e982e2878b32a18af8a759791962286f17eec9163f6f",
      "language": "csharp",
      "size": 889,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsStepJourneyDto\n    {\n        public Guid StepId { get; set; }\n\n        public string TemplateName { get; set; } = string.Empty;\n\n        public int TotalReached { get; set; }\n\n        public int ClickedNext { get; set; }\n\n        public Guid? NextStepId { get; set; }\n\n        // ‚úÖ Auto-calculated: number of users who dropped off at this step\n        public int DropOff => TotalReached - ClickedNext;\n\n        // ‚úÖ Auto-calculated: percentage of users who clicked \"next\"\n        public double ConversionRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)ClickedNext / TotalReached * 100, 2);\n\n        // ‚úÖ Optional: percentage of users who dropped off\n        public double DropOffRate =>\n            TotalReached == 0 ? 0 : Math.Round((double)DropOff / TotalReached * 100, 2);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowAnalyticsSummaryDto.cs",
      "sha256": "5298f0c920ce53f68b8113de057d804750e1a3afd39d3a24e965ae120275118a",
      "language": "csharp",
      "size": 369,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowAnalyticsSummaryDto\n    {\n        public int TotalExecutions { get; set; }\n        public int UniqueContacts { get; set; }\n        public string TopStepTriggered { get; set; } = \"N/A\";\n        public int TopStepCount { get; set; }\n        public DateTime? LastExecutedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/FlowStepAnalyticsDto.cs",
      "sha256": "538b4b71cb5a0a82ee36ec0147c0014d4f6570b635eb2ce711cb7e8de3119a09",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class FlowStepAnalyticsDto\n    {\n        public Guid StepId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public int TotalReached { get; set; }\n        public int ClickedNext { get; set; }\n        public int DropOff => TotalReached - ClickedNext;\n        public Guid? NextStepId { get; set; }\n        public DateTime ExecutedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/DTOs/MostTriggeredStepDto.cs",
      "sha256": "18dc2f8497fae7508358e8556503db073d057061d1892fed2882208fa6653588",
      "language": "csharp",
      "size": 310,
      "content": "namespace xbytechat.api.Features.FlowAnalytics.DTOs\n{\n    public class MostTriggeredStepDto\n    {\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n        public int TriggerCount { get; set; }\n        public DateTime? LastTriggeredAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/FlowAnalyticsService.cs",
      "sha256": "b832767451b9f0161f931082a45a698407bf4cfaa6c5077edef8a2f6d30385cb",
      "language": "csharp",
      "size": 5128,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public class FlowAnalyticsService : IFlowAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public FlowAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ‚úÖ Summary cards (executions, unique contacts, top step)\n        public async Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId)\n        {\n            try\n            {\n                Log.Information(\"üìä Generating Flow Analytics Summary for BusinessId: {BusinessId}\", businessId);\n\n                var recentExecutions = await _context.FlowExecutionLogs\n                    .Where(e => e.BusinessId == businessId)\n                    .ToListAsync();\n\n                var totalExecutions = recentExecutions.Count;\n                var uniqueContacts = recentExecutions.Select(e => e.ContactPhone).Distinct().Count();\n                var mostTriggeredStep = recentExecutions\n                    .GroupBy(e => e.StepName)\n                    .OrderByDescending(g => g.Count())\n                    .Select(g => new { Step = g.Key, Count = g.Count() })\n                    .FirstOrDefault();\n\n                return new FlowAnalyticsSummaryDto\n                {\n                    TotalExecutions = totalExecutions,\n                    UniqueContacts = uniqueContacts,\n                    TopStepTriggered = mostTriggeredStep?.Step ?? \"N/A\",\n                    TopStepCount = mostTriggeredStep?.Count ?? 0,\n                    LastExecutedAt = recentExecutions\n                        .OrderByDescending(e => e.ExecutedAt)\n                        .FirstOrDefault()?.ExecutedAt\n                };\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to generate flow analytics summary\");\n                return new FlowAnalyticsSummaryDto();\n            }\n        }\n\n        // ‚úÖ Top triggered steps leaderboard\n        public async Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId)\n        {\n            return await _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId)\n                .GroupBy(e => new { e.StepId, e.StepName })\n                .Select(g => new MostTriggeredStepDto\n                {\n                    StepId = g.Key.StepId,\n                    StepName = g.Key.StepName,\n                    TriggerCount = g.Count(),\n                    LastTriggeredAt = g.Max(e => e.ExecutedAt)\n                })\n                .OrderByDescending(x => x.TriggerCount)\n                .Take(5)\n                .ToListAsync();\n        }\n\n        // ‚úÖ Step-by-step journey breakdown (with date filter)\n        public async Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate)\n        {\n            var query = _context.FlowExecutionLogs\n                .Where(e => e.BusinessId == businessId);\n\n            if (startDate.HasValue)\n                query = query.Where(e => e.ExecutedAt >= startDate.Value.Date);\n\n            if (endDate.HasValue)\n                query = query.Where(e => e.ExecutedAt <= endDate.Value.Date.AddDays(1).AddTicks(-1));\n\n            var logs = await query.ToListAsync();\n\n            // Group by StepId\n            var grouped = logs\n                .GroupBy(e => new { e.StepId, e.TemplateName, e.TriggeredByButton, e.FlowId })\n                .Select(g => new\n                {\n                    StepId = g.Key.StepId,\n                    TemplateName = g.Key.TemplateName,\n                    TotalReached = g.Count(),\n                    ClickedNext = logs.Count(x =>\n                        x.TriggeredByButton != null &&\n                        x.FlowId == g.Key.FlowId &&\n                        x.StepId != g.Key.StepId &&\n                        x.TriggeredByButton == g.Key.TriggeredByButton\n                    ),\n                    FlowId = g.Key.FlowId,\n                    TriggeredByButton = g.Key.TriggeredByButton\n                })\n                .ToList();\n\n            // Build final breakdown\n            var breakdown = grouped.Select(g => new FlowAnalyticsStepJourneyDto\n            {\n                StepId = g.StepId,\n                TemplateName = g.TemplateName,\n                TotalReached = g.TotalReached,\n                ClickedNext = g.ClickedNext,\n              //  DropOff = g.TotalReached - g.ClickedNext,\n                NextStepId = _context.FlowButtonLinks\n                    .Where(bl =>\n                        bl.CTAFlowStepId == g.StepId &&\n                        bl.ButtonText == g.TriggeredByButton)\n                    .Select(bl => bl.NextStepId)\n                    .FirstOrDefault()\n            }).ToList();\n\n            return breakdown;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/FlowAnalytics/Services/IFlowAnalyticsService.cs",
      "sha256": "65a623c78188e9581eee608e1e5e53404f8431fb317139d50a4caadd86b074ae",
      "language": "csharp",
      "size": 512,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.FlowAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.FlowAnalytics.Services\n{\n    public interface IFlowAnalyticsService\n    {\n        Task<FlowAnalyticsSummaryDto> GetAnalyticsSummaryAsync(Guid businessId);\n        Task<List<MostTriggeredStepDto>> GetMostTriggeredStepsAsync(Guid businessId);\n        Task<List<FlowAnalyticsStepJourneyDto>> GetStepJourneyBreakdownAsync(Guid businessId, DateTime? startDate, DateTime? endDate);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/InboxController.cs",
      "sha256": "309176361f2834ed7c983d99dc96ebb6b7298e35e99a528c40c981257176063a",
      "language": "csharp",
      "size": 3890,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.AspNetCore.Authorization;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/inbox\")]\n    public class InboxController : ControllerBase\n    {\n        private readonly IInboxService _inboxService;\n\n        public InboxController(IInboxService inboxService)\n        {\n            _inboxService = inboxService;\n        }\n\n        /// <summary>\n        /// Send a new message from UI or system.\n        /// </summary>\n        [HttpPost(\"send\")]\n        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Message content is required.\");\n\n            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Receive a message from external source (e.g., WhatsApp webhook).\n        /// </summary>\n        [HttpPost(\"receive\")]\n        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Incoming message content is required.\");\n\n            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Fetch message history between agent and customer using business token + contactId.\n        /// </summary>\n        [HttpGet(\"messages\")]\n        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n            return Ok(messages);\n        }\n\n        /// <summary>\n        /// Fetch full conversation between agent (userPhone) and customer (contactPhone).\n        /// </summary>\n        [HttpGet(\"conversation\")]\n        public async Task<IActionResult> GetConversation(\n            [FromQuery] Guid businessId,\n            [FromQuery] string userPhone,\n            [FromQuery] string contactPhone)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Invalid input.\");\n\n            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n            return Ok(messages);\n        }\n\n        //[HttpGet(\"unread-counts\")]\n        //public async Task<IActionResult> GetUnreadCounts()\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    var counts = await _inboxService.GetUnreadMessageCountsAsync(businessId);\n        //    return Ok(counts);\n        //}\n\n        [HttpPost(\"mark-read\")]\n        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n            return Ok();\n        }\n        [HttpGet(\"unread-counts\")]\n        public async Task<IActionResult> GetUnreadCounts()\n        {\n            var userId = User.GetUserId();\n            var businessId = User.GetBusinessId();\n\n            var counts = await _inboxService.GetUnreadCountsForUserAsync(businessId, userId);\n            return Ok(counts);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/InboxMessageDto.cs",
      "sha256": "aef9beda43a0dc4f1c619514c3289f6c68a6daf10fe5cdd46ad13c474be29c0b",
      "language": "csharp",
      "size": 881,
      "content": "// üìÑ File: Features/Inbox/DTOs/InboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class InboxMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientPhone { get; set; }\n        public string MessageBody { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }       // üÜï To show in chat bubble\n        public string? RenderedBody { get; set; }\n\n        public bool IsIncoming { get; set; }            // üÜï Needed for bubble side\n        public string Status { get; set; }              // üÜï For message ticks\n        public DateTime SentAt { get; set; }            // üÜï For timestamp\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendInboxMessageDto.cs",
      "sha256": "1ad0e0e61748e9f9e1fab32e1fe533c57a6c8d586694e55aa5b531359804de90",
      "language": "csharp",
      "size": 462,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    /// <summary>\n    /// DTO sent from frontend when a user sends a new message.\n    /// </summary>\n    public class SendInboxMessageDto\n    {\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public string MessageBody { get; set; }\n\n        public string? MediaUrl { get; set; } // Optional image or file\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendMessageInputDto.cs",
      "sha256": "3c76bd2b5ce839064134b72aa2114c14c73a98109c680671f5e7c463867f221a",
      "language": "csharp",
      "size": 249,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class SendMessageInputDto\n    {\n        public Guid ContactId { get; set; } // üîÅ REMOVE the \"?\" (nullable) unless needed\n        public string Message { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/TextOnlyMessageSendDto.cs",
      "sha256": "2d322145a5e6410decb150b108c7d74a656201d9be027b99b02d1c261b4ed4fc",
      "language": "csharp",
      "size": 247,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class TextOnlyMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Hubs/InboxHub.cs",
      "sha256": "2457d506ef6f58ed908e2183358c0506f59e9404b1d8fdb8ae97553d266a5206",
      "language": "csharp",
      "size": 6309,
      "content": "// üìÑ xbytechat.api/Features/Inbox/InboxHub.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Hubs\n{\n    [Authorize]\n    public class InboxHub : Hub\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageService;\n\n        public InboxHub(AppDbContext db, IMessageEngineService messageService)\n        {\n            _db = db;\n            _messageService = messageService;\n        }\n\n        public override async Task OnConnectedAsync()\n        {\n            var businessId = Context.User.GetBusinessId();\n            var groupName = $\"business_{businessId}\";\n\n            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n            Console.WriteLine($\"‚úÖ Connected to group: {groupName}\");\n\n            await base.OnConnectedAsync();\n        }\n\n        public async Task SendMessageToContact(SendMessageInputDto dto)\n        {\n            Console.WriteLine(\"üì© Raw DTO payload:\");\n            Console.WriteLine($\"ContactId: {dto.ContactId}, Message: {dto.Message}\");\n\n            if (dto.ContactId == null || string.IsNullOrWhiteSpace(dto.Message))\n            {\n                Console.WriteLine(\"‚ùå Invalid contact or empty message.\");\n                return;\n            }\n\n            var businessId = Context.User.GetBusinessId();\n            var userId = Context.User.GetUserId();\n\n            // ‚úÖ Lookup recipient phone number from Contact table\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n                .FirstOrDefaultAsync();\n\n            if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n            {\n                Console.WriteLine($\"‚ùå Contact not found or missing phone number. ContactId: {dto.ContactId}\");\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                {\n                    contactId = dto.ContactId,\n                    message = dto.Message,\n                    from = userId,\n                    status = \"Failed\",\n                    error = \"Invalid contact\"\n                   \n                });\n                return;\n            }\n\n            // ‚úÖ Prepare DTO for WhatsApp sending\n            var sendDto = new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n                RecipientNumber = contact.PhoneNumber,\n                TextContent = dto.Message\n            };\n\n            // üöÄ Send via WhatsApp API and save to MessageLogs\n            var result = await _messageService.SendTextDirectAsync(sendDto);\n\n            // ‚úÖ Construct unified message payload\n            var inboxMessage = new\n            {\n                contactId = dto.ContactId,\n                message = dto.Message,\n                from = userId,\n                status = result.Success ? \"Sent\" : \"Failed\",\n                sentAt = DateTime.UtcNow,\n                logId = result.LogId,\n                senderId = userId,\n                isIncoming = false\n            };\n\n            // ‚úÖ Notify sender only\n            await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n            // ‚úÖ Notify others in group (for unread update)\n            var groupName = $\"business_{businessId}\";\n            await Clients.GroupExcept(groupName, Context.ConnectionId)\n                .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n        }\n\n   \n        public async Task MarkAsRead(Guid contactId)\n        {\n            Console.WriteLine($\"üü¢ MarkAsRead triggered for ContactId: {contactId}\");\n            var userId = Context.User?.GetUserId();\n            var businessId = Context.User?.GetBusinessId();\n\n            if (userId == null || businessId == null || businessId == Guid.Empty)\n                return;\n\n            var userGuid = userId.Value;\n            var businessGuid = businessId.Value;\n            var now = DateTime.UtcNow;\n\n            // ‚úÖ Insert or Update ContactRead\n            var readEntry = await _db.ContactReads\n                .FirstOrDefaultAsync(r => r.ContactId == contactId && r.UserId == userGuid);\n\n            if (readEntry == null)\n            {\n                Console.WriteLine(\"üì• New ContactRead will be added.\");\n                _db.ContactReads.Add(new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessGuid,\n                    ContactId = contactId,\n                    UserId = userGuid,\n                    LastReadAt = now\n                });\n            }\n            else\n            {\n                Console.WriteLine($\"üîÑ Updating LastReadAt for contact {contactId}\");\n                readEntry.LastReadAt = now;\n            }\n\n            await _db.SaveChangesAsync();\n            Console.WriteLine(\"üíæ ContactReads saved successfully.\");\n            // ‚úÖ Step 1: Get message logs (DB)\n            var allMessages = await _db.MessageLogs\n                .Where(m => m.BusinessId == businessGuid && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            // ‚úÖ Step 2: Get contactReads (DB)\n            var contactReads = await _db.ContactReads\n                .Where(r => r.UserId == userGuid)\n                .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            // ‚úÖ Step 3: Now calculate unread counts in-memory (C# LINQ)\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n            // ‚úÖ Push real-time update to user\n            await Clients.User(userGuid.ToString())\n                .SendAsync(\"UnreadCountChanged\", unreadCounts);\n        }\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ChatSessionState.cs",
      "sha256": "fa6184f30e1715455ee5b84ae75264c5cc2d46ed4f1721014141ed9036dfda64",
      "language": "csharp",
      "size": 500,
      "content": "namespace xbytechat.api.Features.Inbox.Models\n{\n    public class ChatSessionState\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string Mode { get; set; } = \"automation\"; // values: \"automation\" | \"agent\"\n        public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // Optional: track who switched the mode\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ContactRead.cs",
      "sha256": "aa4dd9980bc6485cf1c4981bf7dfff84f32dcfbacc6c9dbc3be4ba0429c065c6",
      "language": "csharp",
      "size": 474,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public class ContactRead\n    {\n        public Guid Id { get; set; }\n\n        // üîó FK to Contact\n        public Guid ContactId { get; set; }\n\n        // üîó FK to User (Agent)\n        public Guid UserId { get; set; }\n\n        // üìÖ Last time this agent opened this contact's chat\n        public DateTime LastReadAt { get; set; } = DateTime.UtcNow;\n\n        public Guid BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/IInboxRepository.cs",
      "sha256": "d057575abdee0fe95972b5dcfafa6e7637884f526bb108c43b06bbb1b2d2a5bd",
      "language": "csharp",
      "size": 839,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public interface IInboxRepository\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone);\n        Task AddMessageAsync(MessageLog message);\n        Task SaveChangesAsync();\n        Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/InboxRepository.cs",
      "sha256": "06153117fc580e3c5239560868ec16dd5f41d963a159eec8ad96f569afa9bb29",
      "language": "csharp",
      "size": 4226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public class InboxRepository : IInboxRepository\n    {\n        private readonly AppDbContext _context;\n\n        public InboxRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(limit)\n                .ToListAsync();\n        }\n\n        public async Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task AddMessageAsync(MessageLog message)\n        {\n            await _context.MessageLogs.AddAsync(message);\n        }\n\n        public async Task SaveChangesAsync()\n        {\n            await _context.SaveChangesAsync();\n        }\n        public async Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId)\n        {\n            return await _context.MessageLogs\n                 .Include(m => m.SourceCampaign)\n                .Where(m => m.BusinessId == businessId && m.ContactId == contactId)\n                .OrderBy(m => m.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\" &&\n                            m.ContactId != null) // ‚úÖ ensure not null\n                .GroupBy(m => m.ContactId!.Value) // ‚úÖ safe cast to Guid\n                .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                .ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            var unreadMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.ContactId == contactId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\")\n                .ToListAsync(); \n            foreach (var msg in unreadMessages)\n                msg.Status = \"Read\";\n\n            await _context.SaveChangesAsync();\n        }\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n                    var contactReads = await _context.ContactReads\n             .Where(r => r.UserId == userId)\n             .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            // üü¢ Fetch from DB first (no logic yet)\n            var allMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            // üß† Now calculate in memory\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n\n            return unreadCounts;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/AgentAssignmentService.cs",
      "sha256": "de9062b213ba63cb8695f407ede5c9e8d52a589e0dc1c7a4c5c79fd243389e4e",
      "language": "csharp",
      "size": 1104,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class AgentAssignmentService : IAgentAssignmentService\n    {\n        private readonly ILogger<AgentAssignmentService> _logger;\n\n        public AgentAssignmentService(ILogger<AgentAssignmentService> logger)\n        {\n            _logger = logger;\n        }\n\n        public Task<bool> IsAgentAvailableAsync(Guid businessId)\n        {\n            // üîß TODO: Replace with real logic based on your agent pool\n            _logger.LogInformation(\"Checking if agent is available for business {BusinessId}\", businessId);\n            return Task.FromResult(true); // Assume always available for MVP\n        }\n\n        public Task AssignAgentToContactAsync(Guid businessId, Guid contactId)\n        {\n            // üîß TODO: Save agent-contact assignment to DB or notify a human agent\n            _logger.LogInformation(\"Assigning agent to contact {ContactId} for business {BusinessId}\", contactId, businessId);\n            return Task.CompletedTask;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/ChatSessionStateService.cs",
      "sha256": "5c6672bd07d87501ca9d46e38085cbec03455bae6cc943c8b8df505a7c73808e",
      "language": "csharp",
      "size": 2964,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class ChatSessionStateService : IChatSessionStateService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatSessionStateService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ‚úÖ Returns current chat mode: \"agent\" or \"auto\"\n        public async Task<string> GetChatModeAsync(Guid businessId, Guid contactId)\n        {\n            var session = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            return session?.Mode ?? \"auto\"; // Default to auto\n        }\n\n        // ‚úÖ Switches to agent mode\n        public async Task SwitchToAgentModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"agent\");\n        }\n\n        // ‚úÖ Switches to automation mode\n        public async Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"auto\");\n        }\n\n        // ‚úÖ Shared logic to insert or update session state\n        private async Task UpsertChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var existing = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (existing != null)\n            {\n                existing.Mode = mode;\n                existing.LastUpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                _db.ChatSessionStates.Add(new ChatSessionState\n                {\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                });\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task SetChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var state = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (state == null)\n            {\n                // Insert new if not exists\n                state = new ChatSessionState\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                };\n                _db.ChatSessionStates.Add(state);\n            }\n            else\n            {\n                state.Mode = mode;\n                state.LastUpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IAgentAssignmentService.cs",
      "sha256": "1eae6f670d61efc4cd6f430a93cf7188c26a6d521ae49cd50ab926aa5bc027ee",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IAgentAssignmentService\n    {\n        Task<bool> IsAgentAvailableAsync(Guid businessId);\n        Task AssignAgentToContactAsync(Guid businessId, Guid contactId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IChatSessionStateService.cs",
      "sha256": "3ade6df9341ebca2e5a478331e57315273317bc803a529a4e068cccc323f1693",
      "language": "csharp",
      "size": 404,
      "content": "namespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IChatSessionStateService\n    {\n        Task<string> GetChatModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAgentModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId);\n        Task SetChatModeAsync(Guid businessId, Guid contactId, string mode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IInboxService.cs",
      "sha256": "58b2b14fb055263d0f08348900a55c5cbd62c16609e1b4ba082beb34a84efc49",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IInboxService\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto);\n        Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto);\n        Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/InboxService.cs",
      "sha256": "8bbfdb66619466ec1c134351db9fc8b8fd32a8d30a45da7c3d142e41f17ae8f7",
      "language": "csharp",
      "size": 3941,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Repositories;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class InboxService : IInboxService\n    {\n        private readonly IInboxRepository _repository;\n\n        public InboxService(IInboxRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _repository.GetConversationAsync(businessId, userPhone, contactPhone, limit);\n        }\n\n        public async Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto)\n        {\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n                IsIncoming = true,\n                CreatedAt = DateTime.UtcNow,\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto)\n        {\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n                IsIncoming = false,\n                CreatedAt = DateTime.UtcNow,\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n   \n        public async Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId)\n        {\n            var messages = await _repository.GetMessagesByContactIdAsync(businessId, contactId);\n\n            return messages.Select(m => new MessageLogDto\n            {\n                Id = m.Id,\n                ContactId = m.ContactId,\n                RecipientNumber = m.RecipientNumber, // ‚úÖ optional but helpful\n                MessageContent = m.MessageContent,\n                CreatedAt = m.CreatedAt,\n                IsIncoming = m.IsIncoming,\n                RenderedBody = m.RenderedBody,\n                CampaignId = m.CampaignId,\n                CampaignName = m.SourceCampaign?.Name, // ‚úÖ ‚úÖ This is crucial\n                CTAFlowConfigId = m.CTAFlowConfigId,\n                CTAFlowStepId = m.CTAFlowStepId\n            }).ToList();\n        }\n\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _repository.GetUnreadMessageCountsAsync(businessId);\n        }\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            await _repository.MarkMessagesAsReadAsync(businessId, contactId);\n        }\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            return await _repository.GetUnreadCountsForUserAsync(businessId, userId);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/SignalR/NameUserIdProvider.cs",
      "sha256": "177581fc6482f75de65f8a7db7a93d17a7d887e148d35eb77ca640d9df0e311f",
      "language": "csharp",
      "size": 336,
      "content": "using Microsoft.AspNetCore.SignalR;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.SignalR\n{\n    public class NameUserIdProvider : IUserIdProvider\n    {\n        public string? GetUserId(HubConnectionContext connection)\n        {\n            return connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Controllers/MessageStatusController.cs",
      "sha256": "b0d7d3e99be2a95698a0e358da794c0d0f53a81c7f38846322df111c19fd0fbb",
      "language": "csharp",
      "size": 3213,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\n\nnamespace xbytechat.api.Features.MessageManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/message-status\")]\n    public class MessageStatusController : ControllerBase\n    {\n        private readonly IMessageStatusService _service;\n        private readonly ILogger<MessageStatusController> _logger;\n        private readonly AppDbContext _context;\n        private readonly IConfiguration _config;\n        public MessageStatusController(\n    IMessageStatusService service,\n    ILogger<MessageStatusController> logger,\n    AppDbContext context,\n    IConfiguration config)\n        {\n            _service = service;\n            _logger = logger;\n            _context = context;\n            _config = config;\n        }\n\n        // ‚úÖ STEP 1: Webhook Verification (GET)\n        [HttpGet(\"webhook\")]\n        public IActionResult VerifyWebhook([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string token,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            //var VERIFY_TOKEN = _config[\"WhatsApp:MetaToken\"]; // ‚úÖ pulled from config\n\n            if (mode == \"subscribe\" && token == \"xbytechat-secret-token\")\n            {\n                _logger.LogInformation(\"‚úÖ Webhook verified.\");\n                return Ok(challenge);\n            }\n\n            _logger.LogWarning(\"‚ùå Webhook verification failed.\");\n            return Forbid();\n        }\n\n\n        // ‚úÖ STEP 2: Webhook Payload (POST)\n        [HttpPost(\"webhook\")]\n        public async Task<IActionResult> ReceiveStatus([FromBody] WebhookStatusDto dto)\n        {\n            if (dto == null || dto.statuses == null || dto.statuses.Count == 0)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Invalid webhook payload received.\");\n                return BadRequest(\"Invalid payload\");\n            }\n\n            await _service.LogWebhookStatusAsync(dto);\n            _logger.LogInformation(\"‚úÖ Webhook status processed successfully.\");\n\n            return Ok(new { success = true });\n        }\n\n        // ‚úÖ STEP 3: Frontend UI (GET Logs)\n        [HttpGet]\n        public async Task<IActionResult> GetStatusLogs([FromQuery] Guid businessId)\n        {\n            var logs = await _context.MessageStatusLogs\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100)\n                .Select(x => new\n                {\n                    x.MessageId,\n                    x.RecipientNumber,\n                    x.Status,\n                    x.SentAt,\n                    x.DeliveredAt,\n                    x.ReadAt,\n                    x.ErrorMessage,\n                    x.TemplateCategory,\n                    x.MessageType\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = logs });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/MessageLogDto.cs",
      "sha256": "c0f207826b70160db8814aaf2e5fcf92174c9b5b7d0904bf27f60163fb2ca516",
      "language": "csharp",
      "size": 643,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageLogDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string MessageContent { get; set; }\n        public bool IsIncoming { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public string? RenderedBody { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/DTOs/WebhookStatusDto.cs",
      "sha256": "aeb1bd281f5cc025fcc6c5a2a924daf3078c9e774d3fad3860626f871caad053",
      "language": "csharp",
      "size": 1324,
      "content": "namespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class WebhookStatusDto\n    {\n        public List<StatusObject> statuses { get; set; }\n    }\n\n    public class StatusObject\n    {\n        public string id { get; set; }                     // Message ID (WAMID)\n        public string status { get; set; }                 // sent, delivered, read, failed\n        public long timestamp { get; set; }                // UNIX timestamp\n        public string recipient_id { get; set; }           // Phone number\n        public ConversationInfo conversation { get; set; }\n        public PricingInfo pricing { get; set; }\n        public List<ErrorInfo>? errors { get; set; }\n    }\n\n    public class ConversationInfo\n    {\n        public string id { get; set; }\n        public Origin origin { get; set; }\n    }\n\n    public class Origin\n    {\n        public string type { get; set; }                   // marketing, utility, etc.\n    }\n\n    public class PricingInfo\n    {\n        public bool billable { get; set; }\n        public string pricing_model { get; set; }\n        public string category { get; set; }               // Template category\n    }\n\n    public class ErrorInfo\n    {\n        public int code { get; set; }\n        public string title { get; set; }\n        public string details { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Models/MessageStatusLog.cs",
      "sha256": "3e0a8a53cdfb329873018f1c8d6d53c03ef5c6be3e10247853ed67761cafbb4f",
      "language": "csharp",
      "size": 1958,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\n\nnamespace xbytechat.api.Features.MessageManagement.DTOs\n{\n    public class MessageStatusLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        // üîó Who is it for\n        public string RecipientNumber { get; set; }\n        public string? CustomerProfileName { get; set; }\n\n        // üì© WhatsApp Message Info\n       // [ForeignKey(nameof(Message))]\n        public string? MessageId { get; set; } // WAMID\n\n       // public MessageLog? Message { get; set; }\n        public string Status { get; set; }\n        public string MessageType { get; set; }\n\n        // üßæ Template Info\n        public string? TemplateName { get; set; }\n        public string? TemplateCategory { get; set; }\n\n        // üß† Analytics/Reporting\n        public string Channel { get; set; } = \"whatsapp\";\n        public bool IsSessionOpen { get; set; }\n        public long? MetaTimestamp { get; set; }\n\n        // üïí Timestamps\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ‚ùå Error Tracking\n        public string? ErrorMessage { get; set; }\n        public int? ErrorCode { get; set; }\n\n        // üîç Raw Log (for audit/debug)\n        public string? RawPayload { get; set; }\n\n        // üîó Foreign Keys\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n        public Guid? BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid? UserId { get; set; }\n        public User? User { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // ‚úÖ Navigation using alternate key (WAMID)\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/IMessageStatusService.cs",
      "sha256": "cca96e16b96ab978d9e4c344d9a12a8377da0c701b18ea3e5e1bb981d1d6578a",
      "language": "csharp",
      "size": 262,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public interface IMessageStatusService\n    {\n        Task LogWebhookStatusAsync(WebhookStatusDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageManagement/Services/MessageStatusService.cs",
      "sha256": "f68c41d4a80e28d1b1de9da188c8b43c756b495494588de6fd11c8275d59a544",
      "language": "csharp",
      "size": 2755,
      "content": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.MessageManagement.Services;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.AuthModule.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageManagement.Services\n{\n    public class MessageStatusService : IMessageStatusService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageStatusService> _logger;\n\n        public MessageStatusService(AppDbContext context, ILogger<MessageStatusService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogWebhookStatusAsync(WebhookStatusDto dto)\n        {\n            foreach (var status in dto.statuses)\n            {\n                var log = new MessageStatusLog\n                {\n                    Id = Guid.NewGuid(),\n                    MessageId = status.id,\n                    Status = status.status.ToLower(),\n                    RecipientNumber = status.recipient_id,\n                    MetaTimestamp = status.timestamp,\n                    TemplateCategory = status?.pricing?.category,\n                    MessageType = status?.conversation?.origin?.type ?? \"session\",\n                    Channel = \"whatsapp\",\n                    CreatedAt = DateTime.UtcNow,\n                    RawPayload = System.Text.Json.JsonSerializer.Serialize(status)\n                };\n\n                var statusTime = DateTimeOffset.FromUnixTimeSeconds(status.timestamp).UtcDateTime;\n\n                switch (status.status.ToLower())\n                {\n                    case \"sent\": log.SentAt = statusTime; break;\n                    case \"delivered\": log.DeliveredAt = statusTime; break;\n                    case \"read\": log.ReadAt = statusTime; break;\n                }\n\n                if (status.errors != null && status.errors.Count > 0)\n                {\n                    log.ErrorMessage = status.errors[0].details;\n                    log.ErrorCode = status.errors[0].code;\n                }\n\n                await _context.MessageStatusLogs.AddAsync(log);\n            }\n\n            // ‚õëÔ∏è Wrap in try-catch and log full inner exception\n            try\n            {\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"‚ùå SaveChangesAsync failed: \" + ex.Message);\n                _logger.LogError(\"‚ùå Inner exception: \" + ex.InnerException?.Message);\n                throw;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs",
      "sha256": "25a1b1105d245abb3cf620574e2cca3c0da007884f8ba8a062c2cd4724b88022",
      "language": "csharp",
      "size": 1124,
      "content": "// üìÑ File: Features/MessagesEngine/Abstractions/IWhatsAppProvider.cs\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n   \n    public interface IWhatsAppProvider\n    {\n        Task<WaSendResult> SendTextAsync(string to, string body);\n        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components);\n        Task<WaSendResult> SendInteractiveAsync(object fullPayload); // prebuilt object (e.g., image + CTA)\n    }\n}\n\n\n\n//namespace xbytechat.api.Features.MessagesEngine.Abstractions\n//{\n//    public interface IWhatsAppProvider\n//    {\n//        string Provider { get; }\n\n//        Task<WaSendResult> SendTextAsync(string to, string body, CancellationToken ct = default);\n\n//        Task<WaSendResult> SendTemplateAsync(string to, string templateName, string language, object? components, CancellationToken ct = default);\n\n//        // Optional: interactive/image+CTA\n//        Task<WaSendResult> SendInteractiveAsync(object payload, CancellationToken ct = default);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendResult.cs",
      "sha256": "cbdf2f4ea14dafdbfd281c92d4701d11b385c52c89785faa04d1848b6af5bd8f",
      "language": "csharp",
      "size": 320,
      "content": "using System.Net;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public record WaSendResult(\n        bool Success,\n        string Provider,\n        string? ProviderMessageId = null,\n        HttpStatusCode? StatusCode = null,\n        string? RawResponse = null,\n        string? Error = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendTemplate.cs",
      "sha256": "ce04cfc0e5abaca6ef42cf5593159791a9ae093be9b7399eae4442252b2362bd",
      "language": "csharp",
      "size": 378,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendTemplate\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string TemplateName { get; init; } = \"\";\n        public string Language { get; init; } = \"en_US\";\n        public object? Components { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Abstractions/WaSendText.cs",
      "sha256": "192ded7365dc037581055e12a8e00816487953e786e107447465183e8e0f83a7",
      "language": "csharp",
      "size": 260,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Abstractions\n{\n    public class WaSendText\n    {\n        public Guid BusinessId { get; init; }\n        public string To { get; init; } = \"\";\n        public string Body { get; init; } = \"\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Contracts/MessageEnvelope.cs",
      "sha256": "7d9a3c2180154a34b5c48dbcc92d2b9ce3affbcadaacba097bba0eae1af2925e",
      "language": "csharp",
      "size": 648,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.Contracts\n{\n    /// <summary>\n    /// Provider-agnostic message envelope. Maps to Meta/Pinbot under the hood.\n    /// </summary>\n    public sealed record MessageEnvelope(\n        string To,\n        string Kind,                       // \"text\" | \"template\" | \"interactive\"\n        string? TemplateName = null,\n        string LanguageCode = \"en_US\",\n        List<object>? Components = null,    // template components\n        object? Interactive = null,         // interactive payload (if any)\n        string? TextBody = null,\n        string? ImageUrl = null\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Controllers/MessageEngineController.cs",
      "sha256": "dd1f769411eade4245311c0d7c29700ca7075eae0ba54277ccfc6be641537e74",
      "language": "csharp",
      "size": 5639,
      "content": "\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.ReportingModule.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.MessagesEngine.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class MessageEngineController : ControllerBase\n    {\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IMessageAnalyticsService _messageAnalyticsServiceervice;\n\n\n        public MessageEngineController(IMessageEngineService messageService, IMessageAnalyticsService messageAnalyticsService)\n        {\n            _messageEngineService = messageService;\n            _messageAnalyticsServiceervice = messageAnalyticsService;\n        }\n        [HttpPost(\"send-contentfree-text\")]\n        public async Task<IActionResult> SendTextMessage([FromBody] TextMessageSendDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid text message payload.\"));\n\n            try\n            {\n                var result = await _messageEngineService.SendTextDirectAsync(dto); // üëà New direct method\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(ResponseResult.ErrorInfo(result.Message, result.RawResponse));\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending text message: {ex.Message}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending text message.\", ex.ToString()));\n            }\n        }\n\n\n        [HttpPost(\"send-template-simple\")]\n        public async Task<IActionResult> SendTemplateMessageSimple([FromBody] SimpleTemplateMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid template message request.\"));\n\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out Guid businessId))\n                    return Unauthorized(ResponseResult.ErrorInfo(\"‚ùå Business ID not found in token.\"));\n\n                var result = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(ResponseResult.ErrorInfo(result.Message ?? \"‚ùå Failed to send template.\", result.RawResponse));\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception while sending template: {ex.Message}\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString()));\n            }\n        }\n\n\n        [HttpPost(\"send-image-campaign/{campaignId}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid campaignId)\n        {\n            try\n            {\n                var businessId = UserClaimHelper.GetBusinessId(User); // ‚úÖ from\n                                                                      // claims\n                var userName = UserClaimHelper.GetUserName(User);     // for logging (if needed)\n\n                var result = await _messageEngineService.SendImageCampaignAsync(campaignId, businessId, userName);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error while sending image campaign: \" + ex.Message);\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Server error while sending campaign.\", ex.ToString()));\n            }\n        }\n        public static class UserClaimHelper\n        {\n            public static Guid GetBusinessId(ClaimsPrincipal user)\n            {\n                var claim = user.Claims.FirstOrDefault(c => c.Type == \"businessId\");\n                return claim != null ? Guid.Parse(claim.Value) : Guid.Empty;\n            }\n\n            public static string GetUserName(ClaimsPrincipal user)\n            {\n                return user?.Identity?.Name ?? \"Unknown\";\n            }\n        }\n\n        [HttpPost(\"send-image-template\")]\n        public async Task<IActionResult> SendImageTemplateMessage([FromBody] ImageTemplateMessageDto dto)\n        {\n            Guid businessId;\n            try\n            {\n                businessId = User.GetBusinessId(); // Uses your extension method!\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return Unauthorized(new { message = ex.Message });\n            }\n\n            var result = await _messageEngineService.SendImageTemplateMessageAsync(dto, businessId);\n\n            if (result.Success)\n                return Ok(new { message = result.Message, raw = result.RawResponse });\n\n            return BadRequest(new { message = result.Message, raw = result.RawResponse });\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 20)\n        {\n            var businessId = User.GetBusinessId();\n            var logs = await _messageAnalyticsServiceervice.GetRecentLogsAsync(businessId, limit);\n            return Ok(new { success = true, data = logs });\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/AutoSendTemplateMessageDto.cs",
      "sha256": "99519bdaed8df38337d3485148cfc53b4972c2616ebb386417321455ad582576",
      "language": "csharp",
      "size": 422,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class AutoSendTemplateMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string PhoneNumber { get; set; }\n        public Guid TemplateId { get; set; }\n        public string TemplateName { get; set; }\n        public Dictionary<string, string> Placeholders { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/CtaButtonDto.cs",
      "sha256": "60ecf5aa33d787f635ef05f11c48b8f9f6a11d48b2d7322f7f2ef575b91f9657",
      "language": "csharp",
      "size": 307,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class CtaButtonDto\n    {\n        public string Title { get; set; } = string.Empty; // e.g., \"Buy Now\", \"View Details\"\n        public string Type { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/ImageTemplateMessageDto.cs",
      "sha256": "97564675c3c457ff71f51a241ad4cbca69ec60eaab2b81b81c14fb2360ae34f0",
      "language": "csharp",
      "size": 652,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\n\npublic class ImageTemplateMessageDto\n{\n    public Guid BusinessId { get; set; }\n    public string RecipientNumber { get; set; }\n    public string TemplateName { get; set; }\n    public string LanguageCode { get; set; } = \"en_US\";\n    public string HeaderImageUrl { get; set; }\n    public List<string> TemplateParameters { get; set; } = new();\n    public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n\n    // ‚úÖ Add these two for flow tracking\n    public Guid? CTAFlowConfigId { get; set; }\n    public Guid? CTAFlowStepId { get; set; }\n    public string? TemplateBody { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/MessageTypeEnum.cs",
      "sha256": "d3120f117dc16b8ab9901ba3726defab664b2a9b4a5414eff586e7e27f55062a",
      "language": "csharp",
      "size": 286,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [JsonConverter(typeof(JsonStringEnumConverter))] // Enables string parsing in JSON\n    public enum MessageTypeEnum\n    {\n        Text,\n        Image,\n        Template,\n        Cta\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendMessageDto.cs",
      "sha256": "1c45c09fda3fbb66ba843912c7617fe09447ec841b82f4b0f5c2a08cf8341fc1",
      "language": "csharp",
      "size": 1889,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.DTOs.Validation;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    [ValidateMessageDto] // ‚úÖ Custom validator will enforce conditional field rules\n    public class SendMessageDto\n    {\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [Phone]\n        public string RecipientNumber { get; set; } = string.Empty;\n\n        [Required]\n        public MessageTypeEnum MessageType { get; set; }\n\n        // üìù Text Message\n        public string? TextContent { get; set; }\n\n        // üñºÔ∏è Image Message\n        public string? MediaUrl { get; set; }\n\n        // üìã Template Message\n        public string? TemplateName { get; set; }\n        public Dictionary<string, string>? TemplateParameters { get; set; }\n\n        // üõí CTA Message\n        public List<CtaButtonDto>? CtaButtons { get; set; }\n\n        // ‚úÖ Required: this was missing [Optional but needed for CTA/Template message sending]\n        public List<string>? ButtonParams { get; set; }\n\n        // üìä Optional Metadata\n        public Guid? CampaignId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n\n        public string? SourceModule { get; set; }\n        public string? CustomerId { get; set; }\n        public string? CustomerName { get; set; }\n        public string? CustomerPhone { get; set; }\n        public string? BotId { get; set; }\n        public string? RefMessageId { get; set; }\n        public string? CTATriggeredFrom { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n\n        // ‚úÖ Add these two for flow tracking\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SendTemplateMessageSimpleDto.cs",
      "sha256": "00dc74bb6a1b396bab6fcd63f93454cfd59671260c4da8b0afd8754e83e10ce8",
      "language": "csharp",
      "size": 478,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SendTemplateMessageSimpleDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientNumber { get; set; }\n        public string TemplateName { get; set; }\n        public List<string> TemplateParameters { get; set; } = new();\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/SimpleTemplateMessageDto.cs",
      "sha256": "13b09ae3db26e3770de01db13a5f5dabff0f7e5b09c9ed73dc44272e47699ac2",
      "language": "csharp",
      "size": 703,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class SimpleTemplateMessageDto\n    {\n        //public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TemplateName { get; set; }\n\n        public List<string> TemplateParameters { get; set; } = new();\n        public bool HasStaticButtons { get; set; } = false;\n\n        // ‚úÖ Add these two for flow tracking\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public string? TemplateBody { get; set; }  // üî• Used to render actual message body from placeholders\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TemplateForUIResponseDto.cs",
      "sha256": "9b7be7ee8b48ca30422fe6b4ee2eb6af563f79ae7abad04aaaab9fdb4658612b",
      "language": "csharp",
      "size": 434,
      "content": "using xbytechat.api.WhatsAppSettings.DTOs;\n\npublic class TemplateForUIResponseDto\n{\n    public string Name { get; set; }\n    public string Language { get; set; }\n    public string Body { get; set; }\n\n    // ‚úÖ Correct naming for frontend\n    public int ParametersCount { get; set; }\n\n    public List<ButtonMetadataDto> ButtonParams { get; set; }\n    public bool HasImageHeader { get; set; } // üÜï Used to detect image templates\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/DTOs/TextMessageSendDto.cs",
      "sha256": "d7fa4ec175e1c0d95b0bf1d4a4e9c6c6afc1b616bbb4d487c263c4033b8fb331",
      "language": "csharp",
      "size": 610,
      "content": "namespace xbytechat.api.Features.MessagesEngine.DTOs\n{\n    public class TextMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        // ‚úÖ NEW: Optional source indicator (e.g., \"campaign\", \"auto-reply\", etc.)\n        public string? Source { get; set; }\n\n        // ‚úÖ NEW: Optional message ID for campaign tracing\n        public string? MessageId { get; set; }\n\n        public bool IsSaveContact { get; set; } = false; // default true\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Factory/IWhatsAppProviderFactory.cs",
      "sha256": "6707eef3d5eb2cdc04483a137ae4fe1df2386dfe964f87eae6af3d0889f06a08",
      "language": "csharp",
      "size": 389,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\n\nnamespace xbytechat.api.Features.MessagesEngine.Factory\n{\n    public interface IWhatsAppProviderFactory\n    {\n        //Task<IWhatsAppProvider> CreateAsync(Guid businessId, CancellationToken ct = default);\n        Task<IWhatsAppProvider> CreateAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Factory/WhatsAppProviderFactory.cs",
      "sha256": "b62ff4b12855bab644146b65059c457c6a19b562014228259bb3a22de9d63db5",
      "language": "csharp",
      "size": 4344,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.MessagesEngine.Providers;\n\nnamespace xbytechat.api.Features.MessagesEngine.Factory\n{\n    public class WhatsAppProviderFactory : IWhatsAppProviderFactory\n    {\n        private readonly IServiceProvider _sp;\n        private readonly AppDbContext _db;\n        private readonly ILogger<WhatsAppProviderFactory> _logger;\n\n        public WhatsAppProviderFactory(IServiceProvider sp, AppDbContext db, ILogger<WhatsAppProviderFactory> logger)\n        {\n            _sp = sp;\n            _db = db;\n            _logger = logger;\n        }\n\n        public async Task<IWhatsAppProvider> CreateAsync(Guid businessId)\n        {\n            var setting = await _db.WhatsAppSettings\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n                ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n            var providerKey = (setting.Provider ?? \"meta_cloud\").Trim().ToLowerInvariant();\n\n            using var scope = _sp.CreateScope();\n\n            var httpClientFactory = scope.ServiceProvider.GetService<IHttpClientFactory>();\n            var http =\n                httpClientFactory != null\n                    ? httpClientFactory.CreateClient(providerKey == \"meta_cloud\" ? \"wa:meta_cloud\" : \"wa:pinnacle\")\n                    : scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n            return providerKey switch\n            {\n                //\"pinnacle\" =>\n                //            new PinnacleProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(), setting),\n                \"pinnacle\" => new PinnacleProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinnacleProvider>>(), setting),\n                \"meta_cloud\" =>\n                    new MetaCloudProvider(_db, http, scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(), setting),\n\n                _ => throw new NotSupportedException($\"Unsupported WhatsApp provider: {providerKey}\")\n            };\n        }\n    }\n}\n\n\n//// üìÑ File: Features/MessagesEngine/Factory/WhatsAppProviderFactory.cs\n//using System;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.DependencyInjection;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.MessagesEngine.Abstractions;\n//using xbytechat.api.Features.MessagesEngine.Providers;\n\n//namespace xbytechat.api.Features.MessagesEngine.Factory\n//{\n\n//    public class WhatsAppProviderFactory : IWhatsAppProviderFactory\n//    {\n//        private readonly IServiceProvider _sp;\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<WhatsAppProviderFactory> _logger;\n\n//        public WhatsAppProviderFactory(IServiceProvider sp, AppDbContext db, ILogger<WhatsAppProviderFactory> logger)\n//        {\n//            _sp = sp;\n//            _db = db;\n//            _logger = logger;\n//        }\n\n//        public async Task<IWhatsAppProvider> CreateAsync(Guid businessId)\n//        {\n//            var setting = await _db.WhatsAppSettings.FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive)\n//                          ?? throw new InvalidOperationException(\"WhatsApp settings not found for this business.\");\n\n//            var providerKey = (setting.Provider ?? \"meta_cloud\").Trim().ToLowerInvariant();\n\n//            // Create a new scope to inject the per-tenant setting into provider constructor\n//            var scope = _sp.CreateScope();\n//            var http = scope.ServiceProvider.GetRequiredService<HttpClient>();\n\n//            return providerKey switch\n//            {\n//                \"pinnacle\" => new PinbotProvider(http, scope.ServiceProvider.GetRequiredService<ILogger<PinbotProvider>>(), setting),\n//                \"meta_cloud\" => new MetaCloudProvider(_db, http, scope.ServiceProvider.GetRequiredService<ILogger<MetaCloudProvider>>(), setting),\n//                _ => throw new NotSupportedException($\"Unsupported WhatsApp provider: {providerKey}\")\n//            };\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Outbox/OutboxMessage.cs",
      "sha256": "caa5c09bc7c28e6aaa5bb1aa93cd76f38c41f5c2754790d9c45f6af037ed1a25",
      "language": "csharp",
      "size": 1109,
      "content": "using System;\n\nnamespace xbytechat.api.Features.MessagesEngine.Outbox\n{\n    public enum OutboxStatus\n    {\n        Queued = 0,\n        Sending = 1,\n        Sent = 2,\n        Failed = 3\n    }\n\n    public class OutboxMessage\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        public string RecipientNumber { get; set; } = \"\";\n        public string ProviderKey { get; set; } = \"\"; // \"meta_cloud\" | \"pinnacle\" (optional hint)\n        public string PayloadJson { get; set; } = \"\"; // serialized MessageEnvelope\n        public string CorrelationId { get; set; } = \"\"; // for idempotency & tracing\n\n        public OutboxStatus Status { get; set; } = OutboxStatus.Queued;\n        public int AttemptCount { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? NextAttemptAt { get; set; } = DateTime.UtcNow;\n        public string? LastError { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/CtaMessagePayloadBuilder.cs",
      "sha256": "f23794fdb8775eff63c5d249f23e74b7ff5e4497daa7b255ce94693b3ba9a6f7",
      "language": "csharp",
      "size": 1063,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class CtaMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"interactive\",\n                interactive = new\n                {\n                    type = \"button\",\n                    body = new { text = dto.TextContent },\n                    action = new\n                    {\n                        buttons = dto.CtaButtons?.Select(b => new\n                        {\n                            type = \"reply\",\n                            reply = new\n                            {\n                                id = b.Value,\n                                title = b.Title\n                            }\n                        }).ToList()\n                    }\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/ImageMessagePayloadBuilder.cs",
      "sha256": "1400148a9ed0b32af7ece6c87b111a1407feda0f5b651819257c5b740bb01106",
      "language": "csharp",
      "size": 554,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class ImageMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"image\",\n                image = new\n                {\n                    link = dto.MediaUrl\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/IWhatsAppPayloadBuilder.cs",
      "sha256": "89d6b688ba597eb931cd71401717698a692f3e3b645a02d60c1d73dae24731d3",
      "language": "csharp",
      "size": 225,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public interface IWhatsAppPayloadBuilder\n    {\n        object BuildPayload(SendMessageDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/MessagePayloadBuilder.cs",
      "sha256": "5f3fdb0eec9de51853f33783973029ee43bf803491c0679c460374e2816f0d01",
      "language": "csharp",
      "size": 2574,
      "content": "using xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Shared.utility;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public static class MessagePayloadBuilder\n    {\n        /// <summary>\n        /// Builds a WhatsApp template message payload for image header + buttons.\n        /// </summary>\n        public static object BuildImageTemplatePayload(\n            string templateName,\n            string languageCode,\n            string recipientNumber,\n            List<string> templateParams,\n            string? imageUrl,\n            List<CampaignButton>? buttons\n        )\n        {\n            var components = new List<object>();\n\n            // ‚úÖ Body with template params\n            if (templateParams != null && templateParams.Any())\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = templateParams.Select(p => new { type = \"text\", text = p }).ToArray()\n                });\n            }\n\n            // ‚úÖ Header image if present\n            if (!string.IsNullOrWhiteSpace(imageUrl))\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new[]\n                    {\n                    new { type = \"image\", image = new { link = imageUrl } }\n                }\n                });\n            }\n\n            // ‚úÖ CTA buttons\n            if (buttons != null && buttons.Any())\n            {\n                var buttonComponents = buttons\n                    .OrderBy(b => b.Position)\n                    .Take(3)\n                    .Select((btn, index) => new\n                    {\n                        type = \"button\",\n                        sub_type = btn.Type, // \"url\" or \"phone_number\"\n                        index = index.ToString(),\n                        parameters = new[]\n                        {\n                        new { type = \"text\", text = btn.Value }\n                        }\n                    });\n\n                components.AddRange(buttonComponents);\n            }\n\n            // ‚úÖ Final WhatsApp Template Payload\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = recipientNumber,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = new { code = languageCode },\n                    components = components\n                }\n            };\n        }\n    }\n\n}"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TemplateMessagePayloadBuilder.cs",
      "sha256": "1beb36776f57bf30bf67df07af07052f4d5fe2609dfe6a4015bf512dff64aee8",
      "language": "csharp",
      "size": 5342,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TemplateMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.TemplateName))\n                throw new ArgumentException(\"TemplateName is required.\");\n            if (dto.TemplateParameters == null || dto.TemplateParameters.Count == 0)\n                throw new ArgumentException(\"TemplateParameters are required for template messages.\");\n\n            // Sort by placeholder index like {{1}}, {{2}}, guarding against bad keys\n            var bodyParams = dto.TemplateParameters\n                .Select(kvp =>\n                {\n                    var key = kvp.Key?.Trim('{', '}');\n                    _ = int.TryParse(key, out var idx);\n                    return (idx, kvp.Value);\n                })\n                .OrderBy(t => t.idx)\n                .Select(t => new { type = \"text\", text = t.Value })\n                .ToArray();\n\n            var components = new List<object>\n            {\n                new { type = \"body\", parameters = bodyParams }\n            };\n\n            if (dto.ButtonParams != null && dto.ButtonParams.Any())\n            {\n                for (int i = 0; i < dto.ButtonParams.Count; i++)\n                {\n                    components.Add(new\n                    {\n                        type = \"button\",\n                        sub_type = \"url\",\n                        index = i.ToString(),\n                        parameters = new[]\n                        {\n                            new { type = \"text\", text = dto.ButtonParams[i] }\n                        }\n                    });\n                }\n            }\n\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"template\",\n                template = new\n                {\n                    name = dto.TemplateName,\n                    language = new { code = \"en_US\" },\n                    components\n                }\n            };\n        }\n    }\n}\n\n\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n//{\n//    public class TemplateMessagePayloadBuilder : IWhatsAppPayloadBuilder\n//    {\n//        public object BuildPayload(SendMessageDto dto)\n//        {\n//            var components = new List<object>();\n\n//            // ‚úÖ BODY PARAMETERS: Insert dynamic values into the template body\n//            // WhatsApp expects these to be in order ({{1}}, {{2}}, etc.)\n//            if (dto.TemplateParameters == null || dto.TemplateParameters.Count == 0)\n//                return ResponseResult.ErrorInfo(\"‚ùå Missing template parameters.\");\n//            if (dto.TemplateParameters != null && dto.TemplateParameters.Any())\n//                {\n//                var bodyParams = dto.TemplateParameters\n//                    .OrderBy(kvp => int.Parse(kvp.Key.Trim('{', '}'))) // üî¢ Extract and sort by index\n//                    .Select(kvp => new\n//                    {\n//                        type = \"text\",\n//                        text = kvp.Value\n//                    }).ToArray();\n\n//                components.Add(new\n//                {\n//                    type = \"body\",\n//                    parameters = bodyParams\n//                });\n//            }\n\n//            // ‚úÖ BUTTON PARAMETERS: For templates with dynamic URL buttons (index-based)\n//            if (dto.ButtonParams != null && dto.ButtonParams.Any())\n//            {\n//                for (int i = 0; i < dto.ButtonParams.Count; i++)\n//                {\n//                    components.Add(new\n//                    {\n//                        type = \"button\",\n//                        sub_type = \"url\",\n//                        index = i.ToString(), // WhatsApp requires index as a string\n//                        parameters = new[]\n//                        {\n//                            new\n//                            {\n//                                type = \"text\",\n//                                text = dto.ButtonParams[i]\n//                            }\n//                        }\n//                    });\n//                }\n//            }\n\n//            // ‚úÖ FINAL WHATSAPP TEMPLATE PAYLOAD\n//            var payload = new\n//            {\n//                messaging_product = \"whatsapp\",\n//                to = dto.RecipientNumber,\n//                type = \"template\",\n//                template = new\n//                {\n//                    name = dto.TemplateName,\n//                    language = new { code = \"en_US\" },\n//                    components = components\n//                }\n//            };\n\n//            // ü™µ Debug log for developer console (optional)\n//            Console.WriteLine(\"üì¶ Built WhatsApp Template Payload:\");\n//            Console.WriteLine(System.Text.Json.JsonSerializer.Serialize(payload, new System.Text.Json.JsonSerializerOptions\n//            {\n//                WriteIndented = true\n//            }));\n\n//            return payload;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TemplateStaticButtonPayloadBuilder.cs",
      "sha256": "68979e5fa2d53ce3fa319c20377ca2022bf9e46b7244c817fb53f84594392f72",
      "language": "csharp",
      "size": 1397,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TemplateStaticButtonPayloadBuilder\n    {\n        public static object Build(SendTemplateMessageSimpleDto dto)\n        {\n            var components = new List<object>();\n\n            // ‚úÖ Add Body Params\n            if (dto.TemplateParameters != null && dto.TemplateParameters.Any())\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = dto.TemplateParameters.Select(p => new\n                    {\n                        type = \"text\",\n                        text = p\n                    }).ToArray()\n                });\n            }\n\n            // ‚ö†Ô∏è DO NOT add button components for static buttons\n            // Meta will render them automatically if template has static buttons defined\n            // You can later add logic here for dynamic buttons if needed\n\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"template\",\n                template = new\n                {\n                    name = dto.TemplateName,\n                    language = new { code = \"en_US\" },\n                    components = components\n                }\n            };\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/PayloadBuilders/TextMessagePayloadBuilder.cs",
      "sha256": "abc17e5a60e2f58ba07c610db126262040f598a15aca27d2f85d52afc2fb4766",
      "language": "csharp",
      "size": 554,
      "content": "using xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.PayloadBuilders\n{\n    public class TextMessagePayloadBuilder : IWhatsAppPayloadBuilder\n    {\n        public object BuildPayload(SendMessageDto dto)\n        {\n            return new\n            {\n                messaging_product = \"whatsapp\",\n                to = dto.RecipientNumber,\n                type = \"text\",\n                text = new\n                {\n                    body = dto.TextContent\n                }\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Providers/MetaCloudProvider.cs",
      "sha256": "bae23942587c9e571ac05f14833da096c1404e3b3983410cbc045e427c48d9b7",
      "language": "csharp",
      "size": 9915,
      "content": "// üìÑ File: Features/MessagesEngine/Providers/MetaCloudProvider.cs\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\nusing System.Text.Json.Serialization;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Providers\n{\n    public class MetaCloudProvider : IWhatsAppProvider\n    {\n        private readonly AppDbContext _db; // kept for future auditing/log enrichment\n        private readonly HttpClient _http;\n        private readonly ILogger<MetaCloudProvider> _logger;\n        private readonly WhatsAppSettingEntity _setting;\n\n        // ‚úÖ Ignore nulls to avoid sending \"components\": null etc.\n        private static readonly JsonSerializerOptions _jsonOpts = new()\n        {\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\n        };\n\n        public MetaCloudProvider(\n            AppDbContext db,\n            HttpClient http,\n            ILogger<MetaCloudProvider> logger,\n            WhatsAppSettingEntity setting)\n        {\n            _db = db;\n            _http = http;\n            _logger = logger;\n            _setting = setting;\n        }\n\n        private string BuildUrl()\n        {\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://graph.facebook.com/v18.0\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            if (string.IsNullOrWhiteSpace(_setting.PhoneNumberId))\n            {\n                _logger.LogError(\"MetaCloudProvider: PhoneNumberId is missing for BusinessId {BusinessId}\", _setting.BusinessId);\n                return $\"{baseUrl}/-/messages\"; // inert path; will fail fast with clear logs\n            }\n\n            return $\"{baseUrl}/{_setting.PhoneNumberId}/messages\";\n        }\n\n        private async Task<WaSendResult> PostAsync(object payload)\n        {\n            var url = BuildUrl();\n            var json = JsonSerializer.Serialize(payload, _jsonOpts);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            if (!string.IsNullOrWhiteSpace(_setting.ApiToken))\n            {\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _setting.ApiToken);\n            }\n            else\n            {\n                _logger.LogWarning(\"MetaCloudProvider: ApiToken is empty for BusinessId {BusinessId}\", _setting.BusinessId);\n            }\n\n            var res = await _http.SendAsync(req);\n            var body = await res.Content.ReadAsStringAsync();\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"MetaCloud send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n                return new WaSendResult(\n                    Success: false,\n                    Provider: \"MetaCloud\",\n                    ProviderMessageId: null,\n                    StatusCode: res.StatusCode,\n                    RawResponse: body,\n                    Error: res.ReasonPhrase\n                );\n            }\n\n            string? id = null;\n            try\n            {\n                var root = JsonNode.Parse(body);\n                id = root?[\"messages\"]?[0]?[\"id\"]?.GetValue<string>();\n            }\n            catch\n            {\n                // Keep raw; ID stays null\n            }\n\n            return new WaSendResult(\n                Success: true,\n                Provider: \"MetaCloud\",\n                ProviderMessageId: id,\n                StatusCode: res.StatusCode,\n                RawResponse: body,\n                Error: null\n            );\n        }\n\n        public Task<WaSendResult> SendTextAsync(string to, string body)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"text\",\n                text = new { preview_url = false, body }\n            });\n\n        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = new { code = languageCode },      // ‚úÖ Meta needs { code: \"en_US\" }\n                    components = components ?? System.Linq.Enumerable.Empty<object>() // ‚úÖ never null\n                }\n            });\n\n        public Task<WaSendResult> SendInteractiveAsync(object fullPayload)\n            => PostAsync(fullPayload);\n    }\n}\n\n\n//// üìÑ File: Features/MessagesEngine/Providers/MetaCloudProvider.cs\n//using System.Collections.Generic;\n//using System.Net;\n//using System.Net.Http;\n//using System.Net.Http.Headers;\n//using System.Text;\n//using System.Text.Json;\n//using System.Text.Json.Nodes;\n//using System.Threading.Tasks;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.MessagesEngine.Abstractions;\n//using xbytechat_api.WhatsAppSettings.Models;\n\n//namespace xbytechat.api.Features.MessagesEngine.Providers\n//{\n//    public class MetaCloudProvider : IWhatsAppProvider\n//    {\n//        private readonly AppDbContext _db; // kept for future auditing/log enrichment\n//        private readonly HttpClient _http;\n//        private readonly ILogger<MetaCloudProvider> _logger;\n//        private readonly WhatsAppSettingEntity _setting;\n\n//        public MetaCloudProvider(\n//            AppDbContext db,\n//            HttpClient http,\n//            ILogger<MetaCloudProvider> logger,\n//            WhatsAppSettingEntity setting)\n//        {\n//            _db = db;\n//            _http = http;\n//            _logger = logger;\n//            _setting = setting;\n//        }\n\n//        private string BuildUrl()\n//        {\n//            // Minimal defensive checks ‚Äì fail fast with clear logs\n//            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n//                ? \"https://graph.facebook.com/v18.0\"\n//                : _setting.ApiUrl.TrimEnd('/');\n\n//            if (string.IsNullOrWhiteSpace(_setting.PhoneNumberId))\n//            {\n//                _logger.LogError(\"MetaCloudProvider: PhoneNumberId is missing for BusinessId {BusinessId}\", _setting.BusinessId);\n//                // We return an error result instead of throwing (provider contract returns WaSendResult)\n//                // Caller will translate to ResponseResult.ErrorInfo.\n//                return $\"{baseUrl}/-/messages\"; // inert path; PostAsync will still be called and return error\n//            }\n\n//            return $\"{baseUrl}/{_setting.PhoneNumberId}/messages\";\n//        }\n\n//        private async Task<WaSendResult> PostAsync(object payload)\n//        {\n//            var url = BuildUrl();\n//            var json = JsonSerializer.Serialize(payload);\n\n//            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n//            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n//            if (!string.IsNullOrWhiteSpace(_setting.ApiToken))\n//            {\n//                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _setting.ApiToken);\n//            }\n//            else\n//            {\n//                _logger.LogWarning(\"MetaCloudProvider: ApiToken is empty for BusinessId {BusinessId}\", _setting.BusinessId);\n//            }\n\n//            var res = await _http.SendAsync(req);\n//            var body = await res.Content.ReadAsStringAsync();\n\n//            if (!res.IsSuccessStatusCode)\n//            {\n//                _logger.LogWarning(\"MetaCloud send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n\n//                return new WaSendResult(\n//                    Success: false,\n//                    Provider: \"MetaCloud\",\n//                    ProviderMessageId: null,\n//                    StatusCode: res.StatusCode,\n//                    RawResponse: body,\n//                    Error: res.ReasonPhrase\n//                );\n//            }\n\n//            string? id = null;\n//            try\n//            {\n//                var root = JsonNode.Parse(body);\n//                id = root?[\"messages\"]?[0]?[\"id\"]?.GetValue<string>();\n//            }\n//            catch\n//            {\n//                // Keep raw; ID stays null\n//            }\n\n//            return new WaSendResult(\n//                Success: true,\n//                Provider: \"MetaCloud\",\n//                ProviderMessageId: id,\n//                StatusCode: res.StatusCode,\n//                RawResponse: body,\n//                Error: null\n//            );\n//        }\n\n//        public Task<WaSendResult> SendTextAsync(string to, string body)\n//            => PostAsync(new\n//            {\n//                messaging_product = \"whatsapp\",\n//                to,\n//                type = \"text\",\n//                text = new { preview_url = false, body }\n//            });\n\n//        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n//            => PostAsync(new\n//            {\n//                messaging_product = \"whatsapp\",\n//                to,\n//                type = \"template\",\n//                template = new\n//                {\n//                    name = templateName,\n//                    language = new { code = languageCode },\n//                    components\n//                }\n//            });\n\n//        public Task<WaSendResult> SendInteractiveAsync(object fullPayload)\n//            => PostAsync(fullPayload);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Providers/PinbotProvider.cs",
      "sha256": "b42150f90c8705aa4742bab8ec5351c66edd98d9a0572bc128ae03635d3eed0c",
      "language": "csharp",
      "size": 5193,
      "content": "// üìÑ File: Features/MessagesEngine/Providers/PinbotProvider.cs\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Providers\n{\n    public class PinbotProvider : IWhatsAppProvider\n    {\n        private readonly HttpClient _http;\n        private readonly ILogger<PinbotProvider> _logger;\n        private readonly WhatsAppSettingEntity _setting;\n\n        public PinbotProvider(\n            HttpClient http,\n            ILogger<PinbotProvider> logger,\n            WhatsAppSettingEntity setting)\n        {\n            _http = http;\n            _logger = logger;\n            _setting = setting;\n        }\n\n        // Pinbot path segment can be WABA ID *or* PhoneNumberId depending on their account setup.\n        // Prefer PhoneNumberId, fall back to WabaId.\n        private string? ResolvePathIdOrNull()\n        {\n            if (!string.IsNullOrWhiteSpace(_setting.PhoneNumberId)) return _setting.PhoneNumberId!;\n            if (!string.IsNullOrWhiteSpace(_setting.WabaId)) return _setting.WabaId!;\n            return null;\n        }\n\n        private string BuildUrl(string pathId)\n        {\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://partnersv1.pinbot.ai\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            // Pinbot uses /v3/{id}/messages (id can be WABA ID or PhoneNumberId)\n            return $\"{baseUrl}/{pathId}/messages\";\n        }\n\n        private async Task<WaSendResult> PostAsync(object payload)\n        {\n            var pathId = ResolvePathIdOrNull();\n            if (string.IsNullOrWhiteSpace(pathId))\n            {\n                const string err = \"Pinnacle: PhoneNumberId or WabaId is required.\";\n                _logger.LogError(err);\n                return new WaSendResult(\n                    Success: false,\n                    Provider: \"Pinnacle\",\n                    ProviderMessageId: null,\n                    StatusCode: null,\n                    RawResponse: null,\n                    Error: err\n                );\n            }\n\n            var url = BuildUrl(pathId);\n            var json = JsonSerializer.Serialize(payload);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            // Pinbot requires apikey header (no Bearer token)\n            if (!string.IsNullOrWhiteSpace(_setting.ApiKey))\n            {\n                req.Headers.TryAddWithoutValidation(\"apikey\", _setting.ApiKey);\n            }\n            else\n            {\n                _logger.LogWarning(\"PinbotProvider: ApiKey is empty for BusinessId {BusinessId}\", _setting.BusinessId);\n            }\n\n            var res = await _http.SendAsync(req);\n            var body = await res.Content.ReadAsStringAsync();\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Pinbot send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n                return new WaSendResult(\n                    Success: false,\n                    Provider: \"Pinbot\",\n                    ProviderMessageId: null,\n                    StatusCode: res.StatusCode,\n                    RawResponse: body,\n                    Error: res.ReasonPhrase\n                );\n            }\n\n            string? id = null;\n            try\n            {\n                // Pinbot often mirrors Meta's envelope, but be defensive.\n                var root = JsonNode.Parse(body);\n                id = root?[\"messages\"]?[0]?[\"id\"]?.GetValue<string>()\n                     ?? root?[\"message\"]?[\"id\"]?.GetValue<string>();\n            }\n            catch\n            {\n                // keep raw; ID remains null\n            }\n\n            return new WaSendResult(\n                Success: true,\n                Provider: \"Pinbot\",\n                ProviderMessageId: id,\n                StatusCode: res.StatusCode,\n                RawResponse: body,\n                Error: null\n            );\n        }\n\n        public Task<WaSendResult> SendTextAsync(string to, string body)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"text\",\n                text = new { body }\n            });\n\n        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = new { code = languageCode },\n                    components\n                }\n            });\n\n        public Task<WaSendResult> SendInteractiveAsync(object fullPayload)\n            => PostAsync(fullPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Providers/PinnacleProvider.cs",
      "sha256": "720d7f9c39a95e9a324b0d19cdb5bf602c789a7ed59a9b1a83b95ab187152d8f",
      "language": "csharp",
      "size": 7443,
      "content": "// üìÑ File: Features/MessagesEngine/Providers/PinnacleProvider.cs\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\nusing System.Text.Json.Serialization;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Providers\n{\n    public class PinnacleProvider : IWhatsAppProvider\n    {\n        private readonly HttpClient _http;\n        private readonly ILogger<PinnacleProvider> _logger;\n        private readonly WhatsAppSettingEntity _setting;\n\n        private static readonly JsonSerializerOptions _jsonOpts = new()\n        {\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\n        };\n\n        public PinnacleProvider(HttpClient http, ILogger<PinnacleProvider> logger, WhatsAppSettingEntity setting)\n        {\n            _http = http;\n            _logger = logger;\n            _setting = setting;\n        }\n\n        private string? ResolvePathIdOrNull()\n        {\n            if (!string.IsNullOrWhiteSpace(_setting.PhoneNumberId)) return _setting.PhoneNumberId!;\n            if (!string.IsNullOrWhiteSpace(_setting.WabaId)) return _setting.WabaId!;\n            return null;\n        }\n\n        private string BuildBaseUrl()\n        {\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://partnersv1.pinbot.ai\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            if (!baseUrl.EndsWith(\"/v3\"))\n                baseUrl += \"/v3\";\n\n            return baseUrl;\n        }\n\n        // üîí Hard-append apikey ALWAYS (no conditions)\n        private string BuildSendUrlWithApiKey(string pathId)\n        {\n            // NEW LOGIC: Check if the 'pathId' is already a full URL.\n            // This is how we detect our tracking links.\n            if (Uri.IsWellFormedUriString(pathId, UriKind.Absolute))\n            {\n                // If it's a full URL, use it directly without modification.\n                return pathId;\n            }\n\n            // OLD LOGIC: If it's just a path ID, build the full Pinnacle API URL.\n            var baseUrl = string.IsNullOrWhiteSpace(_setting.ApiUrl)\n                ? \"https://partnersv1.pinbot.ai\"\n                : _setting.ApiUrl.TrimEnd('/');\n\n            if (!baseUrl.EndsWith(\"/v3\"))\n                baseUrl += \"/v3\";\n\n            return $\"{baseUrl}/{pathId}/messages?apikey={System.Uri.EscapeDataString(_setting.ApiKey)}\";\n        }\n\n        private async Task<WaSendResult> PostAsync(object payload)\n        {\n            var pathId = ResolvePathIdOrNull();\n            if (string.IsNullOrWhiteSpace(pathId))\n            {\n                const string err = \"Pinnacle: PhoneNumberId or WabaId is required.\";\n                _logger.LogError(err);\n                return new WaSendResult(false, \"Pinnacle\", null, null, null, err);\n            }\n\n            if (string.IsNullOrWhiteSpace(_setting.ApiKey))\n            {\n                const string err = \"Pinnacle: ApiKey is missing in WhatsApp settings.\";\n                _logger.LogError(err);\n                return new WaSendResult(false, \"Pinnacle\", null, null, null, err);\n            }\n\n            var url = BuildSendUrlWithApiKey(pathId);\n            var json = JsonSerializer.Serialize(payload, _jsonOpts);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, url);\n            req.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            // ‚úÖ Put key in ALL the places some tenants require\n            req.Headers.Remove(\"apikey\");\n            req.Headers.Remove(\"x-api-key\");\n            req.Headers.TryAddWithoutValidation(\"apikey\", _setting.ApiKey);\n            req.Headers.TryAddWithoutValidation(\"x-api-key\", _setting.ApiKey);\n            req.Headers.Authorization = new AuthenticationHeaderValue(\"Apikey\", _setting.ApiKey);\n            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            // üîç PROVE the headers exist BEFORE sending\n            var headerNames = req.Headers.Select(h => $\"{h.Key}:{string.Join(\",\", h.Value.Select(v => v.Length > 4 ? v[..4] + \"...\" : v))}\").ToArray();\n            _logger.LogInformation(\"Pinnacle POST {Url} | Headers => {Headers}\", url, string.Join(\" | \", headerNames));\n\n            var res = await _http.SendAsync(req);\n            var body = await res.Content.ReadAsStringAsync();\n\n            if (!res.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Pinnacle send failed (HTTP {Status}): {Body}\", (int)res.StatusCode, body);\n                return new WaSendResult(false, \"Pinnacle\", null, res.StatusCode, body, res.ReasonPhrase);\n            }\n\n            string? id = TryGetPinnMessageId(body);\n            return new WaSendResult(true, \"Pinnacle\", id, res.StatusCode, body, null);\n        }\n\n        public Task<WaSendResult> SendTextAsync(string to, string body)\n            => PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"text\",\n                text = new { preview_url = false, body }\n            });\n\n        public Task<WaSendResult> SendTemplateAsync(string to, string templateName, string languageCode, IEnumerable<object> components)\n        {\n            components ??= Enumerable.Empty<object>();\n            var langValue = languageCode; // use exact string from template metadata\n            return PostAsync(new\n            {\n                messaging_product = \"whatsapp\",\n                to,\n                type = \"template\",\n                template = new\n                {\n                    name = templateName,\n                    language = langValue,\n                    components\n                }\n            });\n        }\n\n        private static string? TryGetPinnMessageId(string json)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(json);\n                var root = doc.RootElement;\n                if (root.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var id0)) return id0.GetString();\n\n                if (root.TryGetProperty(\"message\", out var msg) &&\n                    msg.ValueKind == JsonValueKind.Object)\n                {\n                    if (msg.TryGetProperty(\"id\", out var id1)) return id1.GetString();\n                    if (msg.TryGetProperty(\"messageId\", out var id2)) return id2.GetString();\n                }\n                if (root.TryGetProperty(\"message_id\", out var id3)) return id3.GetString();\n                if (root.TryGetProperty(\"messageId\", out var id4)) return id4.GetString();\n                if (root.TryGetProperty(\"data\", out var data) &&\n                    data.ValueKind == JsonValueKind.Object &&\n                    data.TryGetProperty(\"messageId\", out var id5)) return id5.GetString();\n                if (root.TryGetProperty(\"id\", out var idTop)) return idTop.GetString();\n            }\n            catch { }\n            return null;\n        }\n\n        public Task<WaSendResult> SendInteractiveAsync(object fullPayload) => PostAsync(fullPayload);\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/IMessageEngineService.cs",
      "sha256": "c2b073484b095f3ae277da306bbc17f9cc0dd57eac1fc4f33c8cb977aa0dcf63",
      "language": "csharp",
      "size": 965,
      "content": "// ‚úÖ Step 1: Final interface\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Helpers;\nusing System.Threading.Tasks;\nusing System.IO.Pipelines;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public interface IMessageEngineService\n    {\n\n        Task<ResponseResult> SendTemplateMessageAsync(SendMessageDto dto); //\n        Task<ResponseResult> SendTextDirectAsync(TextMessageSendDto dto);\n        Task<ResponseResult> SendAutomationReply(TextMessageSendDto dto);\n        Task<ResponseResult> SendTemplateMessageSimpleAsync(Guid businessId, SimpleTemplateMessageDto dto);\n        Task<ResponseResult> SendImageCampaignAsync(Guid campaignId, Guid businessId, string triggeredBy);\n        Task<ResponseResult> SendImageTemplateMessageAsync(ImageTemplateMessageDto dto, Guid businessId);\n        Task<ResponseResult> SendPayloadAsync(Guid businessId, object payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/ITemplateMessageSender.cs",
      "sha256": "4b54a967e87c74ed41ae2cca4f1ebffc6068cfaa25f10dc6b01021b056886266",
      "language": "csharp",
      "size": 822,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Shared;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public interface ITemplateMessageSender\n    {\n        Task<ResponseResult> SendTemplateMessageToContactAsync(\n           Guid businessId,\n           Contact contact,\n           string templateName,\n           List<string> templateParams,\n           string? imageUrl = null,\n           List<CampaignButton>? buttons = null,\n           string? source = null,\n           Guid? refMessageId = null\n       );\n\n        Task<ResponseResult> SendTemplateCampaignAsync(Campaign campaign);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/MessageEngineService.cs",
      "sha256": "373d5a838a59fd2539ab228fbcc5bf36fda072265c2e9d8097f1c3573636de6b",
      "language": "csharp",
      "size": 41219,
      "content": "// üìÑ File: Features/MessagesEngine/Services/MessageEngineService.cs\nusing Newtonsoft.Json;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.PayloadBuilders;\nusing xbytechat.api.Features.PlanManagement.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api;\nusing xbytechat_api.WhatsAppSettings.Models;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System.Net.Http;\nusing xbytechat.api.Shared.utility;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.ReportingModule.DTOs;\n\n// ‚úÖ provider abstraction + factory\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.MessagesEngine.Factory;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing xbytechat.api.CRM.Models;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public class MessageEngineService : IMessageEngineService\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http; // kept for other internal calls if any\n        private readonly TextMessagePayloadBuilder _textBuilder;\n        private readonly ImageMessagePayloadBuilder _imageBuilder;\n        private readonly TemplateMessagePayloadBuilder _templateBuilder;\n        private readonly CtaMessagePayloadBuilder _ctaBuilder;\n        private readonly IPlanManager _planManager;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly IContactService _contactService;\n\n        // üîÑ Basic cache for WhatsApp settings to reduce DB load (kept for other paths)\n        private static readonly Dictionary<Guid, (WhatsAppSettingEntity setting, DateTime expiresAt)> _settingsCache = new();\n\n        private readonly IWhatsAppProviderFactory _providerFactory;\n\n        public MessageEngineService(\n            AppDbContext db,\n            HttpClient http,\n            TextMessagePayloadBuilder textBuilder,\n            ImageMessagePayloadBuilder imageBuilder,\n            TemplateMessagePayloadBuilder templateBuilder,\n            CtaMessagePayloadBuilder ctaBuilder,\n            IPlanManager planManager,\n            IHubContext<InboxHub> hubContext,\n            IMessageIdResolver messageIdResolver,\n            IHttpContextAccessor httpContextAccessor,\n            IContactService contactService,\n            IWhatsAppProviderFactory providerFactory\n        )\n        {\n            _db = db;\n            _http = http;\n            _textBuilder = textBuilder;\n            _imageBuilder = imageBuilder;\n            _templateBuilder = templateBuilder;\n            _ctaBuilder = ctaBuilder;\n            _planManager = planManager;\n            _hubContext = hubContext;\n            _messageIdResolver = messageIdResolver;\n            _httpContextAccessor = httpContextAccessor;\n            _contactService = contactService;\n            _providerFactory = providerFactory;\n        }\n\n        public async Task<ResponseResult> SendPayloadAsync(Guid businessId, object payload)\n        {\n            // This new method correctly reuses your existing provider logic.\n            // It calls your private helper `SendViaProviderAsync` and tells it\n            // to use the `SendInteractiveAsync` method on whichever provider is created.\n\n            var result = await SendViaProviderAsync(\n                businessId,\n                provider => provider.SendInteractiveAsync(payload)\n            );\n\n            // The 'WaSendResult' from the provider needs to be mapped to the 'ResponseResult'\n            // that the controller expects.\n            return new ResponseResult\n            {\n                Success = result.Success,\n                Message = result.Message,\n                ErrorMessage = result.Success ? null : result.Message,\n                RawResponse = result.RawResponse,\n                MessageId = result.MessageId\n            };\n        }\n        private async Task<ResponseResult> SendViaProviderAsync(\n                           Guid businessId,\n                           Func<IWhatsAppProvider, Task<WaSendResult>> action)\n        {\n            try\n            {\n                var provider = await _providerFactory.CreateAsync(businessId);\n                if (provider == null)\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå WhatsApp provider not configured for this business.\");\n                }\n\n                var res = await action(provider);\n\n                // Map provider result ‚Üí ResponseResult\n                if (!res.Success)\n                {\n                    return ResponseResult.ErrorInfo(\n                        \"‚ùå WhatsApp API returned an error.\",\n                        res.Error,\n                        res.RawResponse\n                    );\n                }\n\n                // Build success response and surface provider message id\n                var rr = ResponseResult.SuccessInfo(\"‚úÖ Message sent successfully\", data: null, raw: res.RawResponse);\n                rr.MessageId = res.ProviderMessageId;\n\n                // Fallback: try to parse WAMID from Meta-style payload if the provider didn‚Äôt set it\n                if (string.IsNullOrWhiteSpace(rr.MessageId) && !string.IsNullOrWhiteSpace(res.RawResponse))\n                {\n                    try\n                    {\n                        var raw = res.RawResponse.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var doc = System.Text.Json.JsonDocument.Parse(raw);\n                            if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                                msgs.ValueKind == System.Text.Json.JsonValueKind.Array &&\n                                msgs.GetArrayLength() > 0 &&\n                                msgs[0].TryGetProperty(\"id\", out var idProp))\n                            {\n                                rr.MessageId = idProp.GetString();\n                            }\n                        }\n                    }\n                    catch\n                    {\n                        // best-effort; ignore parse errors\n                    }\n                }\n\n                return rr;\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Provider call failed.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> SendTemplateMessageAsync(SendMessageDto dto)\n        {\n            try\n            {\n                Console.WriteLine($\"üì® Sending template message to {dto.RecipientNumber} via BusinessId {dto.BusinessId}\");\n\n                if (dto.MessageType != MessageTypeEnum.Template)\n                    return ResponseResult.ErrorInfo(\"Only template messages are supported in this method.\");\n\n                // ‚úÖ Quota\n                var quotaCheck = await _planManager.CheckQuotaBeforeSendingAsync(dto.BusinessId);\n                if (!quotaCheck.Success)\n                {\n                    Console.WriteLine($\"‚ùå Quota check failed: {quotaCheck.Message}\");\n                    return quotaCheck;\n                }\n\n                // ‚úÖ Build template components from dto.TemplateParameters\n                var bodyParams = (dto.TemplateParameters?.Values?.ToList() ?? new List<string>())\n                    .Select(p => new { type = \"text\", text = p })\n                    .ToArray();\n\n                var components = new List<object>();\n                if (bodyParams.Length > 0)\n                {\n                    components.Add(new\n                    {\n                        type = \"body\",\n                        parameters = bodyParams\n                    });\n                }\n\n                // üöÄ Send to provider\n                var sendResult = await SendViaProviderAsync(\n                    dto.BusinessId,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName!, \"en_US\", components)\n                );\n\n                // ‚úÖ Build rendered body\n                var resolvedBody = TemplateParameterHelper.FillPlaceholders(\n                    dto.TemplateBody ?? \"\",\n                    dto.TemplateParameters?.Values.ToList() ?? new List<string>()\n                );\n\n                // üìù Log success\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName ?? \"N/A\",\n                    RenderedBody = resolvedBody,\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = JsonConvert.SerializeObject(sendResult),\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n\n                // üìâ Decrement remaining quota\n                var planInfo = await _db.BusinessPlanInfos\n                    .FirstOrDefaultAsync(p => p.BusinessId == dto.BusinessId);\n\n                if (planInfo != null && planInfo.RemainingMessages > 0)\n                {\n                    planInfo.RemainingMessages -= 1;\n                    planInfo.UpdatedAt = DateTime.UtcNow;\n                }\n\n                await _db.SaveChangesAsync();\n\n                // üì° SignalR push\n                await _hubContext.Clients\n                    .Group($\"business_{dto.BusinessId}\")\n                    .SendAsync(\"ReceiveMessage\", new\n                    {\n                        Id = log.Id,\n                        RecipientNumber = log.RecipientNumber,\n                        MessageContent = log.RenderedBody,\n                        MediaUrl = log.MediaUrl,\n                        Status = log.Status,\n                        CreatedAt = log.CreatedAt,\n                        SentAt = log.SentAt\n                    });\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Template message sent successfully.\", sendResult, log.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                var errorId = Guid.NewGuid();\n                Console.WriteLine($\"üß® Error ID: {errorId}\\n{ex}\");\n\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName ?? \"N/A\",\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(\n                        dto.TemplateBody ?? \"\",\n                        dto.TemplateParameters?.Values.ToList() ?? new List<string>()\n                    ),\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    RawResponse = ex.ToString(),\n                    CreatedAt = DateTime.UtcNow\n                });\n\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.ErrorInfo(\n                    $\"‚ùå Exception occurred while sending template message. [Ref: {errorId}]\",\n                    ex.ToString()\n                );\n            }\n        }\n\n        private async Task<WhatsAppSettingEntity> GetBusinessWhatsAppSettingsAsync(Guid businessId)\n        {\n            if (_settingsCache.TryGetValue(businessId, out var cached) && cached.expiresAt > DateTime.UtcNow)\n                return cached.setting;\n\n            var business = await _db.Businesses\n                .Include(b => b.WhatsAppSettings)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null || business.WhatsAppSettings == null)\n                throw new Exception(\"WhatsApp settings not found.\");\n\n            _settingsCache[businessId] = (business.WhatsAppSettings, DateTime.UtcNow.AddMinutes(5));\n            return business.WhatsAppSettings;\n        }\n\n        public async Task<ResponseResult> SendTextDirectAsync(TextMessageSendDto dto)\n        {\n            try\n            {\n                var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                    ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId from context.\");\n\n                Guid? contactId = null;\n\n                // 1. Look for an existing contact just once using an efficient, indexed query.\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId && c.PhoneNumber == dto.RecipientNumber);\n\n                if (contact != null)\n                {\n                    // 2. If the contact already exists, always use its ID and update the timestamp.\n                    // This ensures message history is always linked correctly for existing contacts.\n                    contactId = contact.Id;\n                    contact.LastContactedAt = DateTime.UtcNow;\n                }\n                else if (dto.IsSaveContact)\n                {\n                    // 3. If the contact does NOT exist AND the user wants to save it, create a new one.\n                    contact = new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = \"WhatsApp User\", // Default name for new contacts\n                        PhoneNumber = dto.RecipientNumber,\n                        CreatedAt = DateTime.UtcNow,\n                        LastContactedAt = DateTime.UtcNow\n                    };\n                    _db.Contacts.Add(contact);\n                    contactId = contact.Id;\n                }\n\n                // 4. Save any changes (either the timestamp update or the new contact creation).\n                await _db.SaveChangesAsync();\n\n                // üöÄ Send message via provider\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    p => p.SendTextAsync(dto.RecipientNumber, dto.TextContent)\n                );\n\n                // üîé Extract messageId from provider or RawResponse\n                string? messageId = sendResult.MessageId;\n                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(sendResult.RawResponse))\n                {\n                    try\n                    {\n                        var raw = sendResult.RawResponse!.TrimStart();\n                        if (raw.StartsWith(\"{\"))\n                        {\n                            using var parsed = System.Text.Json.JsonDocument.Parse(raw);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var msgs)\n                                && msgs.ValueKind == System.Text.Json.JsonValueKind.Array\n                                && msgs.GetArrayLength() > 0)\n                            {\n                                messageId = msgs[0].TryGetProperty(\"id\", out var idProp)\n                                    ? idProp.GetString()\n                                    : null;\n                            }\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è JSON parsing failed: {ex.Message} | Raw: {sendResult.RawResponse}\");\n                    }\n                }\n\n                // üìù Log message\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent,\n                    RenderedBody = dto.TextContent,\n                    ContactId = contactId, // This will be the ID if found/created, otherwise null\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                // üîó Optional campaign mapping\n                Guid? campaignSendLogId = null;\n                if (dto.Source == \"campaign\" && !string.IsNullOrEmpty(messageId))\n                {\n                    try\n                    {\n                        campaignSendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n                        Console.WriteLine($\"üì¶ CampaignSendLog resolved: {campaignSendLogId}\");\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è Failed to resolve campaign log for {messageId}: {ex.Message}\");\n                    }\n                }\n\n                return new ResponseResult\n                {\n                    Success = true,\n                    Message = \"‚úÖ Text message sent successfully.\",\n                    Data = new\n                    {\n                        Success = true,\n                        MessageId = messageId,\n                        LogId = log.Id,\n                        CampaignSendLogId = campaignSendLogId\n                    },\n                    RawResponse = sendResult.RawResponse,\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception in SendTextDirectAsync: {ex.Message}\");\n\n                try\n                {\n                    var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                        ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId in failure path.\");\n\n                    await _db.MessageLogs.AddAsync(new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        RecipientNumber = dto.RecipientNumber,\n                        MessageContent = dto.TextContent,\n                        Status = \"Failed\",\n                        ErrorMessage = ex.Message,\n                        CreatedAt = DateTime.UtcNow\n                    });\n\n                    await _db.SaveChangesAsync();\n                }\n                catch (Exception logEx)\n                {\n                    Console.WriteLine($\"‚ùå Failed to log failure to DB: {logEx.Message}\");\n                }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send text message.\", ex.ToString());\n            }\n        }\n        public async Task<ResponseResult> SendAutomationReply(TextMessageSendDto dto)\n        {\n            try\n            {\n                var businessId = (dto.BusinessId != Guid.Empty)\n                    ? dto.BusinessId\n                    : _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                      ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId from context or DTO.\");\n\n                Guid? contactId = null;\n                try\n                {\n                    var contact = await _contactService.FindOrCreateAsync(businessId, dto.RecipientNumber);\n                    contactId = contact.Id;\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"‚ö†Ô∏è Failed to resolve or create contact: {ex.Message}\");\n                }\n\n                var sendResult = await SendViaProviderAsync(businessId,\n                    p => p.SendTextAsync(dto.RecipientNumber, dto.TextContent));\n\n                string? messageId = null;\n                var raw = sendResult?.RawResponse;\n                if (!string.IsNullOrWhiteSpace(raw))\n                {\n                    try\n                    {\n                        if (raw.TrimStart().StartsWith(\"{\"))\n                        {\n                            var parsed = JsonDocument.Parse(raw);\n                            if (parsed.RootElement.TryGetProperty(\"messages\", out var messages) && messages.GetArrayLength() > 0)\n                                messageId = messages[0].GetProperty(\"id\").GetString();\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è JSON parsing failed: {ex.Message} | Raw: {raw}\");\n                    }\n                }\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent,\n                    RenderedBody = dto.TextContent,\n                    ContactId = contactId,\n                    MediaUrl = null,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    // RawResponse = JsonConvert.SerializeObject(sendResult),\n                    RawResponse = sendResult.RawResponse,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    MessageId = messageId\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                Guid? campaignSendLogId = null;\n                if (dto.Source == \"campaign\" && !string.IsNullOrEmpty(messageId))\n                {\n                    try\n                    {\n                        campaignSendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n                        Console.WriteLine($\"üì¶ CampaignSendLog resolved: {campaignSendLogId}\");\n                    }\n                    catch (Exception ex)\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è Failed to resolve campaign log for {messageId}: {ex.Message}\");\n                    }\n                }\n\n                return new ResponseResult\n                {\n                    Success = true,\n                    Message = \"‚úÖ Text message sent successfully.\",\n                    Data = new\n                    {\n                        Success = true,\n                        MessageId = messageId,\n                        LogId = log.Id,\n                        CampaignSendLogId = campaignSendLogId\n                    },\n                    RawResponse = JsonConvert.SerializeObject(sendResult),\n                    MessageId = messageId,\n                    LogId = log.Id\n                };\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Exception in SendAutomationReply: {ex.Message}\");\n\n                try\n                {\n                    var businessId = (dto.BusinessId != Guid.Empty)\n                        ? dto.BusinessId\n                        : _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                          ?? throw new UnauthorizedAccessException(\"‚ùå Cannot resolve BusinessId in failure path.\");\n\n                    await _db.MessageLogs.AddAsync(new MessageLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        RecipientNumber = dto.RecipientNumber,\n                        MessageContent = dto.TextContent,\n                        Status = \"Failed\",\n                        ErrorMessage = ex.Message,\n                        CreatedAt = DateTime.UtcNow\n                    });\n\n                    await _db.SaveChangesAsync();\n                }\n                catch (Exception logEx)\n                {\n                    Console.WriteLine($\"‚ùå Failed to log failure to DB: {logEx.Message}\");\n                }\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send text message.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendTemplateMessageSimpleAsync(Guid businessId, SimpleTemplateMessageDto dto)\n        {\n            try\n            {\n                // Build minimal components (body only)\n                var components = new List<object>();\n                var parameters = (dto.TemplateParameters ?? new List<string>())\n                    .Select(p => new { type = \"text\", text = p })\n                    .ToArray();\n\n                if (parameters.Length > 0)\n                {\n                    components.Add(new { type = \"body\", parameters });\n                }\n\n                var sendResult = await SendViaProviderAsync(\n                    businessId,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName, \"en_US\", components)\n                );\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(dto.TemplateBody ?? \"\", dto.TemplateParameters ?? new List<string>()),\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = JsonConvert.SerializeObject(sendResult),\n                    SentAt = DateTime.UtcNow,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Template sent successfully.\", sendResult);\n            }\n            catch (Exception ex)\n            {\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(dto.TemplateBody ?? \"\", dto.TemplateParameters ?? new List<string>()),\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.ErrorInfo(\"‚ùå Template send failed\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> SendImageCampaignAsync(Guid campaignId, Guid businessId, string sentBy)\n        {\n            try\n            {\n                var campaign = await _db.Campaigns\n                    .Include(c => c.MultiButtons)\n                    .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                if (campaign == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign not found or unauthorized.\");\n\n                var recipients = await _db.CampaignRecipients\n                    .Include(r => r.Contact)\n                    .Where(r => r.CampaignId == campaignId && r.BusinessId == businessId)\n                    .ToListAsync();\n\n                if (recipients.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ö†Ô∏è No recipients assigned to this campaign.\");\n\n                if (string.IsNullOrWhiteSpace(campaign.ImageCaption))\n                    return ResponseResult.ErrorInfo(\"‚ùå Campaign caption (ImageCaption) is required.\");\n\n                var validButtons = campaign.MultiButtons\n                    ?.Where(b => !string.IsNullOrWhiteSpace(b.Title))\n                    .Select(b => new CtaButtonDto { Title = b.Title, Value = b.Value })\n                    .ToList();\n\n                if (validButtons == null || validButtons.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå At least one CTA button with a valid title is required.\");\n\n                int successCount = 0, failCount = 0;\n\n                foreach (var recipient in recipients)\n                {\n                    if (recipient.Contact == null || string.IsNullOrWhiteSpace(recipient.Contact.PhoneNumber))\n                    {\n                        Console.WriteLine($\"‚ö†Ô∏è Skipping invalid contact: {recipient.Id}\");\n                        failCount++;\n                        continue;\n                    }\n\n                    var dto = new SendMessageDto\n                    {\n                        BusinessId = businessId,\n                        RecipientNumber = recipient.Contact.PhoneNumber,\n                        MessageType = MessageTypeEnum.Image,\n                        MediaUrl = campaign.ImageUrl,\n                        TextContent = campaign.MessageTemplate,\n                        CtaButtons = validButtons,\n\n                        CampaignId = campaign.Id,\n                        SourceModule = \"image-campaign\",\n                        CustomerId = recipient.Contact.Id.ToString(),\n                        CustomerName = recipient.Contact.Name,\n                        CustomerPhone = recipient.Contact.PhoneNumber,\n                        CTATriggeredFrom = \"campaign\"\n                    };\n\n                    var result = await SendImageWithCtaAsync(dto);\n\n                    var sendLog = new CampaignSendLog\n                    {\n                        Id = Guid.NewGuid(),\n                        CampaignId = campaign.Id,\n                        ContactId = recipient.Contact.Id,\n                        RecipientId = recipient.Id,\n                        MessageLogId = result?.LogId,\n                        SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                        SentAt = DateTime.UtcNow,\n                        CreatedBy = sentBy,\n                        BusinessId = businessId,\n                    };\n\n                    await _db.CampaignSendLogs.AddAsync(sendLog);\n\n                    if (result.Success) successCount++;\n                    else failCount++;\n                }\n\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo($\"‚úÖ Campaign sent.\\nüì§ Success: {successCount}, ‚ùå Failed: {failCount}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"‚ùå Error sending image campaign: {ex.Message}\");\n                return ResponseResult.ErrorInfo(\"‚ùå Unexpected error while sending image campaign.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendImageWithCtaAsync(SendMessageDto dto)\n        {\n            try\n            {\n                Console.WriteLine($\"üì§ Sending image+CTA to {dto.RecipientNumber}\");\n\n                if (string.IsNullOrWhiteSpace(dto.TextContent))\n                    return ResponseResult.ErrorInfo(\"‚ùå Image message caption (TextContent) cannot be empty.\");\n\n                var validButtons = dto.CtaButtons?\n                    .Where(b => !string.IsNullOrWhiteSpace(b.Title))\n                    .Take(3)\n                    .Select((btn, index) => new\n                    {\n                        type = \"reply\",\n                        reply = new\n                        {\n                            id = $\"btn_{index + 1}_{Guid.NewGuid():N}\".Substring(0, 16),\n                            title = btn.Title\n                        }\n                    }).ToList();\n\n                if (validButtons == null || validButtons.Count == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå At least one CTA button with a valid title is required.\");\n\n                // interactive payload (works for meta; for Pinbot, provider will just proxy)\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = dto.RecipientNumber,\n                    type = \"interactive\",\n                    interactive = new\n                    {\n                        type = \"button\",\n                        body = new { text = dto.TextContent },\n                        action = new { buttons = validButtons }\n                    },\n                    image = string.IsNullOrWhiteSpace(dto.MediaUrl) ? null : new { link = dto.MediaUrl }\n                };\n\n                var sendResult = await SendViaProviderAsync(dto.BusinessId, p => p.SendInteractiveAsync(payload));\n                var rawJson = JsonConvert.SerializeObject(sendResult);\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent ?? \"[Image with CTA]\",\n                    RenderedBody = dto.TextContent ?? \"\",\n                    MediaUrl = dto.MediaUrl,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = rawJson,\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                var response = ResponseResult.SuccessInfo(\"‚úÖ Image+CTA message sent.\", null, rawJson);\n                response.MessageId = log.Id.ToString();\n                response.LogId = log.Id;\n                return response;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Exception in SendImageWithCtaAsync: \" + ex.Message);\n\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TextContent ?? \"[Image CTA Failed]\",\n                    RenderedBody = dto.TextContent ?? \"[Failed image CTA]\",\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    RawResponse = ex.ToString(),\n                    CreatedAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                });\n\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to send image+CTA.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> SendImageTemplateMessageAsync(ImageTemplateMessageDto dto, Guid businessId)\n        {\n            try\n            {\n                var components = new List<object>();\n\n                if (!string.IsNullOrWhiteSpace(dto.HeaderImageUrl))\n                {\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new[]\n                        {\n                            new\n                            {\n                                type = \"image\",\n                                image = new { link = dto.HeaderImageUrl }\n                            }\n                        }\n                    });\n                }\n\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = (dto.TemplateParameters ?? new List<string>())\n                        .Select(p => new { type = \"text\", text = p })\n                        .ToArray()\n                });\n\n                // Buttons (dynamic up to 3)\n                for (int i = 0; i < dto.ButtonParameters.Count && i < 3; i++)\n                {\n                    var btn = dto.ButtonParameters[i];\n                    var subType = btn.ButtonType?.ToLower();\n\n                    if (string.IsNullOrWhiteSpace(subType))\n                        continue;\n\n                    var button = new Dictionary<string, object>\n                    {\n                        [\"type\"] = \"button\",\n                        [\"sub_type\"] = subType,\n                        [\"index\"] = i.ToString()\n                    };\n\n                    // Add params based on subtype\n                    if (subType == \"quick_reply\" && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                    {\n                        button[\"parameters\"] = new[]\n                        {\n                            new { type = \"payload\", payload = btn.TargetUrl }\n                        };\n                    }\n                    else if (subType == \"url\" && !string.IsNullOrWhiteSpace(btn.TargetUrl))\n                    {\n                        button[\"parameters\"] = new[]\n                        {\n                            new { type = \"text\", text = btn.TargetUrl }\n                        };\n                    }\n\n                    components.Add(button);\n                }\n\n                var sendResult = await SendViaProviderAsync(businessId,\n                    p => p.SendTemplateAsync(dto.RecipientNumber, dto.TemplateName, dto.LanguageCode ?? \"en_US\", components));\n\n                var renderedBody = TemplateParameterHelper.FillPlaceholders(\n                    dto.TemplateBody ?? \"\",\n                    dto.TemplateParameters ?? new List<string>()\n                );\n\n                var log = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    MediaUrl = dto.HeaderImageUrl,\n                    RenderedBody = renderedBody,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                    RawResponse = JsonConvert.SerializeObject(sendResult),\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                };\n\n                await _db.MessageLogs.AddAsync(log);\n                await _db.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Image template sent successfully.\", sendResult, log.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                await _db.MessageLogs.AddAsync(new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    RecipientNumber = dto.RecipientNumber,\n                    MessageContent = dto.TemplateName,\n                    RenderedBody = TemplateParameterHelper.FillPlaceholders(dto.TemplateBody ?? \"\", dto.TemplateParameters ?? new List<string>()),\n                    MediaUrl = dto.HeaderImageUrl,\n                    Status = \"Failed\",\n                    ErrorMessage = ex.Message,\n                    CreatedAt = DateTime.UtcNow,\n                    CTAFlowConfigId = dto.CTAFlowConfigId,\n                    CTAFlowStepId = dto.CTAFlowStepId,\n                });\n\n                await _db.SaveChangesAsync();\n                return ResponseResult.ErrorInfo(\"‚ùå Error sending image template.\", ex.ToString());\n            }\n        }\n\n        public async Task<IEnumerable<RecentMessageLogDto>> GetLogsByBusinessIdAsync(Guid businessId)\n        {\n            var logs = await _db.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(1000)\n                .Select(m => new RecentMessageLogDto\n                {\n                    Id = m.Id,\n                    RecipientNumber = m.RecipientNumber,\n                    MessageContent = m.MessageContent,\n                    Status = m.Status,\n                    CreatedAt = m.CreatedAt,\n                    SentAt = m.SentAt,\n                    ErrorMessage = m.ErrorMessage\n                })\n                .ToListAsync();\n\n            return logs;\n        }\n    }\n}\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Services/TemplateMessageSender.cs",
      "sha256": "caea58e3ba73814fd7ae63f0f47d8732408da8e0b3678d25e8d613f7839d8922",
      "language": "csharp",
      "size": 8302,
      "content": "// üìÑ File: Features/MessagesEngine/Services/TemplateMessageSender.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\n\n//using xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Shared.utility;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.MessagesEngine.Services\n{\n    public class TemplateMessageSender : ITemplateMessageSender\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<TemplateMessageSender> _logger;\n        private readonly IWhatsAppTemplateFetcherService _templateService;\n\n        public TemplateMessageSender(\n            AppDbContext db,\n            HttpClient httpClient,\n            ILogger<TemplateMessageSender> logger,\n            IWhatsAppTemplateFetcherService templateService)\n        {\n            _db = db;\n            _httpClient = httpClient;\n            _logger = logger;\n            _templateService = templateService;\n        }\n\n        public async Task<ResponseResult> SendTemplateMessageToContactAsync(\n            Guid businessId,\n            Contact contact,\n            string templateName,\n            List<string> templateParams,\n            string? imageUrl = null,\n            List<CampaignButton>? buttons = null,\n            string? source = null,\n            Guid? refMessageId = null)\n        {\n            var setting = await _db.WhatsAppSettings.FirstOrDefaultAsync(s => s.BusinessId == businessId && s.IsActive);\n            if (setting == null)\n                return ResponseResult.ErrorInfo(\"WhatsApp settings not found for this business.\");\n\n            var template = await _templateService.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n            if (template == null)\n                return ResponseResult.ErrorInfo(\"Template not found or invalid.\");\n\n            var payload = new Dictionary<string, object>\n            {\n                [\"messaging_product\"] = \"whatsapp\",\n                [\"to\"] = contact.PhoneNumber,\n                [\"type\"] = \"template\",\n                [\"template\"] = new\n                {\n                    name = template.Name,\n                    language = new { code = template.Language },\n                    components = BuildTemplateComponents(template, templateParams, imageUrl, buttons)\n                }\n            };\n\n            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", setting.ApiToken);\n            var json = JsonSerializer.Serialize(payload);\n            var response = await _httpClient.PostAsync(\n                $\"{setting.ApiUrl?.TrimEnd('/') ?? \"https://graph.facebook.com/v18.0\"}/{setting.PhoneNumberId}/messages\",\n                new StringContent(json, Encoding.UTF8, \"application/json\"));\n\n            var responseBody = await response.Content.ReadAsStringAsync();\n            var status = response.IsSuccessStatusCode ? \"Sent\" : \"Failed\";\n\n            await _db.MessageLogs.AddAsync(new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = contact.Id,\n                MessageContent = template.Name,\n                MediaUrl = imageUrl,\n                Status = status,\n                RawResponse = responseBody,\n                ErrorMessage = response.IsSuccessStatusCode ? null : responseBody,\n                Source = source,\n                RefMessageId = refMessageId,\n                CreatedAt = DateTime.UtcNow,\n                SentAt = DateTime.UtcNow\n            });\n\n            await _db.SaveChangesAsync();\n            return response.IsSuccessStatusCode\n                ? ResponseResult.SuccessInfo(\"‚úÖ Message sent successfully\", null, responseBody)\n                : ResponseResult.ErrorInfo(\"‚ùå Message failed\", null, responseBody);\n\n        }\n\n        public async Task<ResponseResult> SendTemplateCampaignAsync(Campaign campaign)\n        {\n            if (campaign == null || campaign.IsDeleted)\n                return ResponseResult.ErrorInfo(\"Invalid or deleted campaign.\");\n\n            var contacts = await _db.CampaignRecipients\n                .Include(r => r.Contact)\n                .Where(r => r.CampaignId == campaign.Id && r.Contact != null)\n                .ToListAsync();\n\n            if (!contacts.Any())\n                return ResponseResult.ErrorInfo(\"No contacts found for this campaign.\");\n\n            var templateName = campaign.TemplateId;\n            var templateParams = TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters);\n            var templateMeta = await _templateService.GetTemplateByNameAsync(campaign.BusinessId, templateName, includeButtons: true);\n\n            if (templateMeta == null)\n                return ResponseResult.ErrorInfo(\"Template metadata not found.\");\n\n            int success = 0, failed = 0;\n\n            foreach (var r in contacts)\n            {\n                var result = await SendTemplateMessageToContactAsync(\n                    campaign.BusinessId,\n                    r.Contact,\n                    templateName,\n                    templateParams,\n                    campaign.ImageUrl,\n                    campaign.MultiButtons?.ToList(),\n                    source: \"campaign\",\n                    refMessageId: campaign.Id);\n\n                await _db.CampaignSendLogs.AddAsync(new CampaignSendLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignId = campaign.Id,\n                    ContactId = r.ContactId,\n                    RecipientId = r.Id,\n                    MessageBody = campaign.MessageBody ?? templateName,\n                    TemplateId = templateName,\n                    SendStatus = result.Success ? \"Sent\" : \"Failed\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    CreatedBy = campaign.CreatedBy\n                });\n\n                if (result.Success) success++;\n                else failed++;\n            }\n\n            await _db.SaveChangesAsync();\n            return ResponseResult.SuccessInfo($\"üì§ Sent to {success}, ‚ùå Failed for {failed}.\");\n        }\n\n        private List<object> BuildTemplateComponents(\n            TemplateMetadataDto template,\n            List<string> paramsList,\n            string? imageUrl,\n            List<CampaignButton>? buttons)\n        {\n            var components = new List<object>();\n\n            if (template.HasImageHeader && !string.IsNullOrWhiteSpace(imageUrl))\n            {\n                components.Add(new\n                {\n                    type = \"header\",\n                    parameters = new[] { new { type = \"image\", image = new { link = imageUrl } } }\n                });\n            }\n\n            if (paramsList.Any())\n            {\n                components.Add(new\n                {\n                    type = \"body\",\n                    parameters = paramsList.Select(p => new { type = \"text\", text = p }).ToList()\n                });\n            }\n\n            if (buttons != null && buttons.Any())\n            {\n                for (int i = 0; i < buttons.Count; i++)\n                {\n                    var btn = buttons[i];\n                    components.Add(new\n                    {\n                        type = \"button\",\n                        sub_type = btn.Type?.ToLower() == \"url\" ? \"url\" : \"quick_reply\",\n                        index = i.ToString(),\n                        parameters = new[] {\n                            new {\n                                type = \"text\",\n                                text = btn.Value ?? btn.Title\n                            }\n                        }\n                    });\n                }\n            }\n\n            return components;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessagesEngine/Validators/ValidateMessageDtoAttribute.cs",
      "sha256": "9b7355295c8cecdf6c4416a324d05f0910b3ff67e99fd35e04e397f715096a9b",
      "language": "csharp",
      "size": 1760,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\n\nnamespace xbytechat.api.Features.MessagesEngine.DTOs.Validation\n{\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class ValidateMessageDtoAttribute : ValidationAttribute\n    {\n        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)\n        {\n            if (value is not SendMessageDto dto)\n                return ValidationResult.Success;\n\n            switch (dto.MessageType)\n            {\n                case MessageTypeEnum.Text:\n                    if (string.IsNullOrWhiteSpace(dto.TextContent))\n                        return new ValidationResult(\"TextContent is required for text messages.\", new[] { nameof(dto.TextContent) });\n                    break;\n\n                case MessageTypeEnum.Image:\n                    if (string.IsNullOrWhiteSpace(dto.MediaUrl))\n                        return new ValidationResult(\"MediaUrl is required for image messages.\", new[] { nameof(dto.MediaUrl) });\n                    break;\n\n                case MessageTypeEnum.Template:\n                    if (string.IsNullOrWhiteSpace(dto.TemplateName))\n                        return new ValidationResult(\"TemplateName is required for template messages.\", new[] { nameof(dto.TemplateName) });\n                    break;\n\n                case MessageTypeEnum.Cta:\n                    if (dto.CtaButtons == null || dto.CtaButtons.Count == 0)\n                        return new ValidationResult(\"CtaButtons is required for CTA messages.\", new[] { nameof(dto.CtaButtons) });\n                    break;\n            }\n\n            return ValidationResult.Success;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/extract_all.bat",
      "sha256": "e15d73a156320cb7235895198a4cd732b5731cda51944f0dfe4e1da83d1e2d5e",
      "language": "bat",
      "size": 731,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\n\nset \"outputFile=All_Content.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/Models/BusinessPlanInfo.cs",
      "sha256": "4a8d4603750b0630eec386cbb831948aaa2cc2f5872d4e1b178da2b9a6952bc7",
      "language": "csharp",
      "size": 1240,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\n\nnamespace xbytechat.api.Models.BusinessModel\n{\n    public class BusinessPlanInfo\n    {\n        [Key]\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üîó Foreign key to Business\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [ForeignKey(nameof(BusinessId))]\n        public Business Business { get; set; }\n\n        // üì¶ Plan Management\n        [Required]\n        public PlanType Plan { get; set; } = PlanType.Trial; // Default Trial\n\n        [Required]\n        public int TotalMonthlyQuota { get; set; } = 100; // Default Trial Messages\n\n        [Required]\n        public int RemainingMessages { get; set; } = 100;\n\n        public DateTime QuotaResetDate { get; set; } = DateTime.UtcNow.AddMonths(1);\n\n        // üí∞ Wallet Management (optional)\n        public decimal WalletBalance { get; set; } = 0.00m;\n\n        // üìÖ Timestamps\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/Models/PlanFeature.cs",
      "sha256": "af8483d1a28e7555f8111b552d2730fd4ef167d9ba562bebb508328248b01a12",
      "language": "csharp",
      "size": 687,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.PlanManagement.Models\n{\n    [Table(\"PlanFeatureMatrix\")]\n    public class PlanFeatureMatrix\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        [MaxLength(20)]\n        public string PlanName { get; set; } = string.Empty;  // \"Basic\", \"Smart\", \"Advance\"\n\n        [Required]\n        [MaxLength(50)]\n        public string FeatureName { get; set; } = string.Empty; // \"Contacts\", \"Catalog\", etc.\n\n        [Required]\n        public bool IsEnabled { get; set; }  // Default state for this plan-feature pair\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/Models/PlanType.cs",
      "sha256": "52170542c11ff0a0e52b9f16289446106038cd266cd602169980aa1d684672ea",
      "language": "csharp",
      "size": 187,
      "content": "namespace xbytechat.api.Features.PlanManagement.Models\n{\n    public enum PlanType\n    {\n       \n        Basic = 0,\n        Smart = 1,\n        Advanced = 2,\n            Trial = 3,\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/Services/IPlanManager.cs",
      "sha256": "69cb77d9f587d971ee0cc96bf3fa399d9982294045981db84e714050dc242d85",
      "language": "csharp",
      "size": 418,
      "content": "using xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.PlanManagement.Services\n{\n    public interface IPlanManager\n    {\n        /// <summary>\n        /// Checks if business has enough quota to send a message.\n        /// </summary>\n        Task<ResponseResult> CheckQuotaBeforeSendingAsync(Guid businessId);\n        Dictionary<string, bool> GetPlanFeatureMap(string plan);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/PlanManagement/Services/PlanManager.cs",
      "sha256": "0d93116ee8bd77194569c6739adad49911359cad9bd6f1919bae85f130027871",
      "language": "csharp",
      "size": 1992,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.PlanManagement.Services\n{\n    public class PlanManager : IPlanManager\n    {\n        private readonly AppDbContext _db;\n\n        public PlanManager(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<ResponseResult> CheckQuotaBeforeSendingAsync(Guid businessId)\n        {\n            var business = await _db.Businesses.FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"Business not found.\", \"Invalid business ID\");\n            if (business?.BusinessPlanInfo?.RemainingMessages <= 0)\n            {\n                var msg = business?.BusinessPlanInfo?.Plan == PlanType.Trial\n                    ? \"Trial limit reached. Please upgrade your plan.\"\n                    : \"Monthly quota exhausted. Please upgrade or wait for reset.\";\n\n                return ResponseResult.ErrorInfo(msg, \"Quota limit exceeded\");\n            }\n\n            return ResponseResult.SuccessInfo(\"Quota check passed.\");\n        }\n\n        public Dictionary<string, bool> GetPlanFeatureMap(string plan)\n        {\n            // Example map ‚Äî replace with real logic if needed\n            if (plan == \"Basic\")\n                return new Dictionary<string, bool>\n            {\n                { \"CATALOG\", true },\n                { \"MESSAGE_SEND\", false },\n                { \"CRM_NOTES\", false }\n            };\n\n            if (plan == \"Advanced\")\n                return new Dictionary<string, bool>\n            {\n                { \"CATALOG\", true },\n                { \"MESSAGE_SEND\", true },\n                { \"CRM_NOTES\", true },\n                { \"CRM_TAGS\", true }\n            };\n\n            // Fallback plan\n            return new Dictionary<string, bool>();\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ReportingModule/Controllers/MessageAnalyticsController.cs",
      "sha256": "99dc4aa00c1bae7339a4b7cf1c00c7946b5aebeb41f493a46adb22e6d15af298",
      "language": "csharp",
      "size": 1238,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.ReportingModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ReportingModule.Controllers\n{\n    [ApiController]\n    [Authorize] // ‚úÖ add this\n    [Route(\"api/reporting/messages\")]\n    public class MessageAnalyticsController : ControllerBase\n    {\n        private readonly IMessageAnalyticsService _service;\n\n        public MessageAnalyticsController(IMessageAnalyticsService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 20)\n        {\n            var businessId = User.GetBusinessId();\n            var logs = await _service.GetRecentLogsAsync(businessId, limit);\n            return Ok(new { success = true, data = logs });\n        }\n\n        [HttpGet(\"history\")]\n        public async Task<IActionResult> GetPaginatedLogs([FromQuery] PaginatedRequest request)\n        {\n            var businessId = User.GetBusinessId();\n            var result = await _service.GetPaginatedLogsAsync(businessId, request);\n            return Ok(new { success = true, data = result });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ReportingModule/DTOs/DirectMessageLogFilterDto.cs",
      "sha256": "e8f948d0367820dd6dce43d8c057e8bfe7a65889ab2eb6361f062de66d36922b",
      "language": "csharp",
      "size": 293,
      "content": "namespace xbytechat.api.Features.ReportingModule.DTOs\n{\n    public class DirectMessageLogFilterDto\n\n    {\n        public int Page { get; set; } = 1;\n        public int PageSize { get; set; } = 10;\n        public string? Status { get; set; }\n        public string? Search { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ReportingModule/DTOs/RecentMessageLogDto.cs",
      "sha256": "f86a239c42fefe2d63c5087c403a7c2cc1e2eea942cc1443bd03495783bbb2f4",
      "language": "csharp",
      "size": 586,
      "content": "// üìÑ File: Features/ReportingModule/DTOs/RecentMessageLogDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ReportingModule.DTOs\n{\n    public class RecentMessageLogDto\n    {\n        public Guid Id { get; set; }\n        public string RecipientNumber { get; set; }\n        public string MessageContent { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }             \n        public Guid? CampaignId { get; set; }\n        public string? Status { get; set; }\n        public string? ErrorMessage { get; set; }         \n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ReportingModule/Services/IMessageAnalyticsService.cs",
      "sha256": "08c8fb19a092bb252492d04c2114547e4ca4a5725875accb403182551c8229f4",
      "language": "csharp",
      "size": 536,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.ReportingModule.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ReportingModule.Services\n{\n    public interface IMessageAnalyticsService\n    {\n        Task<List<RecentMessageLogDto>> GetRecentLogsAsync(Guid businessId, int limit);\n        Task<PaginatedResponse<RecentMessageLogDto>> GetPaginatedLogsAsync(Guid businessId, PaginatedRequest request);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ReportingModule/Services/MessageAnalyticsService.cs",
      "sha256": "3a87316fa63b4890a5bc35b2d867a96a2a7d73e8aea0e52ff6854e89c4245b7a",
      "language": "csharp",
      "size": 2844,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.ReportingModule.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ReportingModule.Services\n{\n    public class MessageAnalyticsService : IMessageAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public MessageAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<RecentMessageLogDto>> GetRecentLogsAsync(Guid businessId, int limit)\n        {\n            return await _context.MessageLogs\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(limit)\n                .Select(x => new RecentMessageLogDto\n                {\n                    Id = x.Id,\n                    RecipientNumber = x.RecipientNumber,\n                    MessageContent = x.MessageContent,\n                    CreatedAt = x.CreatedAt,\n                    CampaignId = x.CampaignId,\n                    Status = x.Status,\n                    SentAt = x.SentAt,\n                })\n                .ToListAsync();\n        }\n\n        public async Task<PaginatedResponse<RecentMessageLogDto>> GetPaginatedLogsAsync(Guid businessId, PaginatedRequest request)\n        {\n            var query = _context.MessageLogs\n                .Where(x => x.BusinessId == businessId);\n\n            if (!string.IsNullOrEmpty(request.Status))\n                query = query.Where(x => x.Status == request.Status);\n\n            if (!string.IsNullOrEmpty(request.Search))\n                query = query.Where(x =>\n                    x.RecipientNumber.Contains(request.Search) ||\n                    x.MessageContent.Contains(request.Search));\n\n            var totalCount = await query.CountAsync();\n\n            var items = await query\n                .OrderByDescending(x => x.CreatedAt)\n                .Skip((request.Page - 1) * request.PageSize)\n                .Take(request.PageSize)\n                .Select(x => new RecentMessageLogDto\n                {\n                    Id = x.Id,\n                    RecipientNumber = x.RecipientNumber,\n                    MessageContent = x.MessageContent,\n                    CreatedAt = x.CreatedAt,\n                    CampaignId = x.CampaignId,\n                    Status = x.Status,\n                    SentAt = x.SentAt,\n                })\n                .ToListAsync();\n\n            return new PaginatedResponse<RecentMessageLogDto>\n            {\n                Items = items,\n                TotalCount = totalCount,\n                Page = request.Page,\n                PageSize = request.PageSize\n            };\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Controllers/TemplatesController.cs",
      "sha256": "b7014e9c08b5d3cf85e8dbd5edf632bc51e34a2acac661dbb3109dcd259edf4c",
      "language": "csharp",
      "size": 1479,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateModule.Services;\n\nnamespace xbytechat.api.Features.TemplateModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/templates\")]\n    public class TemplatesController : ControllerBase\n    {\n        private readonly IWhatsAppTemplateService _templateService;\n        private readonly ILogger<TemplatesController> _logger;\n\n        public TemplatesController(IWhatsAppTemplateService templateService, ILogger<TemplatesController> logger)\n        {\n            _templateService = templateService;\n            _logger = logger;\n        }\n\n        /// <summary>\n        /// Fetches WhatsApp template metadata (name, language, body, placeholders)\n        /// </summary>\n        [HttpGet(\"metadata\")]\n        public async Task<IActionResult> GetTemplates()\n        {\n            try\n            {\n                var templates = await _templateService.FetchTemplatesAsync();\n                return Ok(new\n                {\n                    success = true,\n                    templates\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error fetching template metadata: \" + ex.Message);\n                return StatusCode(500, new\n                {\n                    success = false,\n                    message = \"‚ùå Failed to retrieve template metadata\",\n                    error = ex.Message\n                });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/IWhatsAppTemplateService.cs",
      "sha256": "2ed5f5891246b4fec02e29892760c3d033e76572488701c525fd801763f742a9",
      "language": "csharp",
      "size": 226,
      "content": "using xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public interface IWhatsAppTemplateService\n    {\n        Task<List<TemplateMetadataDto>> FetchTemplatesAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/WhatsAppTemplateService.cs",
      "sha256": "ee70376834e701f63425a69d50a4ea5d02170321edf828fe7fd2bd5d100bf3a1",
      "language": "csharp",
      "size": 2815,
      "content": "using Microsoft.Extensions.Configuration;\nusing Newtonsoft.Json;\nusing xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public class WhatsAppTemplateService : IWhatsAppTemplateService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly IConfiguration _config;\n        private readonly ILogger<WhatsAppTemplateService> _logger;\n\n        public WhatsAppTemplateService(HttpClient httpClient, IConfiguration config, ILogger<WhatsAppTemplateService> logger)\n        {\n            _httpClient = httpClient;\n            _config = config;\n            _logger = logger;\n        }\n\n        public async Task<List<TemplateMetadataDto>> FetchTemplatesAsync()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var token = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v18.0/{wabaId}/message_templates\";\n\n            var templates = new List<TemplateMetadataDto>();\n\n            try\n            {\n                _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);\n                var response = await _httpClient.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogError(\"Failed to fetch WhatsApp templates: \" + json);\n                    return templates;\n                }\n\n                var parsed = JsonConvert.DeserializeObject<dynamic>(json);\n\n                foreach (var tpl in parsed.data)\n                {\n                    string name = tpl.name;\n                    string language = tpl.language ?? \"en_US\";\n                    string body = \"\";\n\n                    foreach (var component in tpl.components)\n                    {\n                        if (component.type == \"BODY\")\n                        {\n                            body = component.text;\n                            break;\n                        }\n                    }\n\n                    // Count {{placeholders}}\n                    var placeholderCount = System.Text.RegularExpressions.Regex.Matches(body, \"{{(.*?)}}\").Count;\n\n                    templates.Add(new TemplateMetadataDto\n                    {\n                        Name = name,\n                        Language = language,\n                        Body = body,\n                        PlaceholderCount = placeholderCount\n                    });\n                }\n\n                return templates;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error while fetching templates from Meta: \" + ex.Message);\n                return templates;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingController.cs",
      "sha256": "2268baa219ea50c48a2af49ee42830c0426f28333713b4caba7833cd10fbc3d6",
      "language": "csharp",
      "size": 6440,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api; // Your using for AppDbContext\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Worker; // Your using for DTOs\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking\")]\n    public class TrackingController : ControllerBase\n    {\n        private readonly ITrackingService _tracker;\n        private readonly AppDbContext _context;\n        private readonly IContactJourneyService _journeyService;\n        public TrackingController(ITrackingService tracker, AppDbContext context, IContactJourneyService journeyService)\n        {\n            _tracker = tracker;\n            _context = context;\n            _journeyService = journeyService;\n        }\n\n        [HttpGet(\"journeys/{campaignSendLogId}\")]\n        public async Task<IActionResult> GetJourney(Guid campaignSendLogId)\n        {\n            var journeyEvents = await _journeyService.GetJourneyEventsAsync(campaignSendLogId);\n            return Ok(journeyEvents);\n        }\n\n\n        //[HttpGet(\"redirect/{campaignSendLogId}\")]\n        //public async Task<IActionResult> TrackCampaignClick(\n        //    Guid campaignSendLogId,\n        //    [FromQuery] string type,\n        //    [FromQuery] string to)\n        //{\n        //    if (string.IsNullOrWhiteSpace(to))\n        //    {\n        //        return BadRequest(\"Missing redirect target URL.\");\n        //    }\n\n        //    var log = await _context.CampaignSendLogs.FindAsync(campaignSendLogId);\n        //    if (log != null)\n        //    {\n        //        log.IsClicked = true;\n        //        log.ClickedAt = DateTime.UtcNow;\n        //        log.ClickType = type;\n        //        log.IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString();\n        //        await _context.SaveChangesAsync();\n        //    }\n\n        //    return Redirect(to);\n        //}\n\n        [HttpGet(\"redirect/{campaignSendLogId}\")]\n        public async Task<IActionResult> TrackCampaignClick(\n                            Guid campaignSendLogId,\n                            [FromQuery] string type,\n                            [FromQuery] string to,\n                            [FromQuery] int? idx = null,                // optional button index if caller knows it\n                            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(to))\n                return BadRequest(\"Missing redirect target URL.\");\n\n            // Normalize & validate destination\n            if (!Uri.TryCreate(to, UriKind.Absolute, out var destUri))\n                return BadRequest(\"Destination URL is invalid.\");\n\n            // Derive a clickType when not provided\n            string clickType = string.IsNullOrWhiteSpace(type)\n                ? ClassifyClickType(destUri)\n                : type.Trim().ToLowerInvariant();\n\n            // Load parent CSL (so we can copy RunId etc.)\n            var log = await _context.CampaignSendLogs.FindAsync(new object[] { campaignSendLogId }, ct);\n            if (log != null)\n            {\n                // First-click fast path on the send\n                log.IsClicked = true;\n                log.ClickedAt = DateTime.UtcNow;\n                log.ClickType = clickType;\n                log.IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString();\n\n                // Persist a CampaignClickLog row (ties this click to the same run)\n                var ua = Request.Headers.UserAgent.ToString();\n                await _context.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,\n                    ButtonIndex = (short)(idx ?? 0),\n                    ButtonTitle = string.IsNullOrWhiteSpace(type) ? \"link\" : type,\n                    Destination = destUri.ToString(),\n                    ClickedAt = DateTime.UtcNow,\n                    Ip = log.IpAddress ?? \"\",\n                    UserAgent = ua ?? \"\",\n                    ClickType = clickType,\n                    RunId = log.RunId              // ‚Üê remove if your schema doesn't have RunId yet\n                }, ct);\n\n                await _context.SaveChangesAsync(ct);\n            }\n\n            // Simple 302 redirect\n            return Redirect(destUri.ToString());\n        }\n\n        // Simple classifier used above\n        private static string ClassifyClickType(Uri u)\n        {\n            if (u == null) return \"web\";\n            var scheme = u.Scheme?.ToLowerInvariant() ?? \"\";\n            if (scheme == \"tel\") return \"call\";\n            if (scheme == \"whatsapp\") return \"whatsapp\";\n            if (scheme is \"http\" or \"https\")\n            {\n                var host = u.Host?.ToLowerInvariant() ?? \"\";\n                if (host.Contains(\"wa.me\") || host.Contains(\"api.whatsapp.com\"))\n                    return \"whatsapp\";\n            }\n            return \"web\";\n        }\n\n        /// <summary>\n        /// Gets detailed information for a specific tracking log entry.\n        /// </summary>\n        [HttpGet(\"logs/{id}/details\")]\n        public async Task<IActionResult> GetLogDetails(Guid id)\n        {\n            var result = await _tracker.GetLogDetailsAsync(id);\n            if (result == null)\n                return NotFound(\"Tracking log not found\");\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Retrieves click logs specifically related to automation flows.\n        /// </summary>\n        [HttpGet(\"flow-clicks\")]\n        public async Task<IActionResult> GetFlowClickLogs()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing business ID\");\n\n            var logs = await _tracker.GetFlowClickLogsAsync(businessId);\n\n            var dtoList = logs.Select(x => new\n            {\n                x.Id,\n                x.StepId,\n                x.ContactPhone,\n                x.ButtonText,\n                x.TemplateId,\n                x.FollowUpSent,\n                x.ClickedAt\n            });\n\n            return Ok(dtoList);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingViewerController.cs",
      "sha256": "6dfeff85fe69af455c90c7ae2ad1fd0614866359c0eaee39cf101ca67b819507",
      "language": "csharp",
      "size": 1584,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking/logs\")]\n    public class TrackingViewerController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n\n        public TrackingViewerController(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] Guid? campaignId = null)\n        {\n            var query = _context.TrackingLogs\n                .Include(t => t.Campaign) // Optional\n                .Include(t => t.Contact)  // Optional\n                .OrderByDescending(t => t.ClickedAt)\n                .AsQueryable();\n\n            if (campaignId.HasValue)\n                query = query.Where(t => t.CampaignId == campaignId);\n\n            var results = await query\n                .Select(t => new\n                {\n                    t.Id,\n                    t.ContactPhone,\n                    ContactName = t.Contact != null ? t.Contact.Name : \"(N/A)\",\n                    t.ButtonText,\n                    t.CTAType,\n                    t.SourceType,\n                    t.ClickedAt,\n                    t.DeviceType,\n                    t.Country,\n                    CampaignName = t.Campaign != null ? t.Campaign.Name : \"(Unknown)\"\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = results });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/JourneyEventDto.cs",
      "sha256": "34abc81cfaea73e66ebb64431d3723ede8e2ac5cab0fcd6e8f4a1b2bbfe20320",
      "language": "csharp",
      "size": 727,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class JourneyEventDto\n    {\n        public DateTime Timestamp { get; set; }\n        public string Source { get; set; } = \"System\"; // System/User/Provider\n        public string EventType { get; set; } = \"\";    // MessageSent/Delivered/Read/ButtonClicked/FlowStep/FlowSend/Redirect/Error\n        public string Title { get; set; } = \"\";\n        public string Details { get; set; } = \"\";\n        public Guid? StepId { get; set; }\n        public string? StepName { get; set; }\n        public int? ButtonIndex { get; set; }\n        public string? ButtonTitle { get; set; }\n        public string? Url { get; set; }\n        public string? TemplateName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/JourneyResponseDto.cs",
      "sha256": "0dd5d4a7faf319e281c5c96d6a7164a6e763aba0de03a617e58165196f48dffa",
      "language": "csharp",
      "size": 549,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class JourneyResponseDto\n    {\n        public string CampaignType { get; set; } = \"dynamic_url\"; // or \"flow\"\n        public string? FlowName { get; set; }\n        public Guid? FlowId { get; set; }\n        public Guid CampaignId { get; set; }\n        public Guid ContactId { get; set; }\n        public string ContactPhone { get; set; } = \"\";\n        public List<JourneyEventDto> Events { get; set; } = new();\n        public string? LeftOffAt { get; set; }  // step title or reason\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDetailsDto.cs",
      "sha256": "e27d7a86aea38ec1fef0aaf6d4d6c208e2481cfaf7033c57fa8da1c81d2c693c",
      "language": "csharp",
      "size": 453,
      "content": "using xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDetailsDto\n    {\n        public TrackingLogDto Tracking { get; set; } = new();\n        public ContactDto? Contact { get; set; }\n        public CampaignDto? Campaign { get; set; }\n        public MessageLogDto? MessageLog { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDto.cs",
      "sha256": "bae94801851bba1bbeb94d60e81f2d20efd13b86be1391265098462d82a3c762",
      "language": "csharp",
      "size": 1798,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDto\n    {\n        // üß© Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // üë§ CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n\n        // üîó Source Info\n        public string SourceType { get; set; } = string.Empty; // e.g. \"campaign\", \"reminder\", \"bot\"\n        public Guid? SourceId { get; set; }\n\n        // üîò CTA Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // üì® Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n\n        // üß† Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n        // üì° Tracking\n        public string? IPAddress { get; set; }\n        public string? Browser { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üîñ Session context\n        public string? SessionId { get; set; }\n        public string? ThreadId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Guid? CampaignSendLogId { get; set; }\n\n        public string RawJson { get; set; } = string.Empty; // used in queue method\n        public DateTime EnqueuedAt { get; set; } // used in queue method\n        public string? NextStepMatched { get; set; } // ‚úÖ Add this if not already there\n\n        public string? TemplateName { get; set; } // ‚úÖ Needed for follow-up matcher\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Models/TrackingLog.cs",
      "sha256": "ce8da394901366ef9d5d9b32a338d7a49d6b8d06eb1f911e89e02296506b4281",
      "language": "csharp",
      "size": 2252,
      "content": "using xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.Tracking.Models;\nnamespace xbytechat.api.Features.Tracking.Models\n{\n    public class TrackingLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß© Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // üë§ CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n        public Contact? Contact { get; set; } // ‚úÖ NEW\n\n        // üîó Source Info\n        public string SourceType { get; set; } = string.Empty;\n        public Guid? SourceId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; } // ‚úÖ NEW\n\n        public Guid? CampaignSendLogId { get; set; }\n        public CampaignSendLog? CampaignSendLog { get; set; } // ‚úÖ Optional\n\n        // üîò Button Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // üì® Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; } // ‚úÖ Optional\n\n        // üß† Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n\n        // üïí Audit Trail\n        public DateTime ClickedAt { get; set; } = DateTime.UtcNow;\n        public string? IPAddress { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üîñ Follow-up & Analytics\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n\n        // üßµ Journey Tracking\n        public Guid? SessionId { get; set; }\n        public Guid? ThreadId { get; set; }\n        public Guid? StepId { get; set; } // ‚úÖ Link to CTAFlowStep for CTA Flow tracking\n\n       //  public string? NextStepMatched { get; set; } // Logs which template system resolved\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/ContactJourneyService.cs",
      "sha256": "e45aedc7431343417385b05cf199aa7a315e9d79105d38de4a604e890a637d45",
      "language": "csharp",
      "size": 13691,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.DTOs; // Updated namespace\n// Add other necessary using statements for your project\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class ContactJourneyService : IContactJourneyService\n    {\n        private readonly AppDbContext _context;\n\n        public ContactJourneyService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<JourneyResponseDto> GetJourneyEventsAsync(Guid initialCampaignSendLogId)\n        {\n            var resp = new JourneyResponseDto();\n            var events = new List<JourneyEventDto>();\n\n            // 0) Load the selected send\n            var sentLog = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Include(x => x.Campaign)\n                .Include(x => x.Contact)\n                .FirstOrDefaultAsync(x => x.Id == initialCampaignSendLogId);\n\n            if (sentLog == null || sentLog.Campaign == null || sentLog.Contact == null)\n            {\n                resp.Events = events;\n                return resp;\n            }\n\n            resp.CampaignId = sentLog.CampaignId;\n            resp.ContactId = sentLog.ContactId;\n            resp.ContactPhone = sentLog.Contact.PhoneNumber ?? \"\";\n            resp.CampaignType = sentLog.CTAFlowConfigId.HasValue ? \"flow\" : \"dynamic_url\";\n            resp.FlowId = sentLog.CTAFlowConfigId;\n\n            // 1) Establish a \"session window\" for THIS run of the campaign to THIS contact\n            var sessionStart = sentLog.SentAt ?? sentLog.CreatedAt;\n\n            // next send to same contact for same campaign\n            var nextSameCampaignAt = await _context.CampaignSendLogs.AsNoTracking()\n                .Where(x => x.ContactId == sentLog.ContactId &&\n                            x.CampaignId == sentLog.CampaignId &&\n                            x.CreatedAt > sessionStart)\n                .OrderBy(x => x.CreatedAt)\n                .Select(x => (DateTime?)x.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            // next send to same contact for same flow (if this is a flow)\n            DateTime? nextSameFlowAt = null;\n            if (sentLog.CTAFlowConfigId.HasValue)\n            {\n                nextSameFlowAt = await _context.CampaignSendLogs.AsNoTracking()\n                    .Where(x => x.ContactId == sentLog.ContactId &&\n                                x.CTAFlowConfigId == sentLog.CTAFlowConfigId &&\n                                x.CreatedAt > sessionStart)\n                    .OrderBy(x => x.CreatedAt)\n                    .Select(x => (DateTime?)x.CreatedAt)\n                    .FirstOrDefaultAsync();\n            }\n\n            // session end = earliest ‚Äúnext run‚Äù OR +24h cap\n            var sessionEnd = new[] { nextSameCampaignAt, nextSameFlowAt }\n                .Where(dt => dt.HasValue)\n                .Select(dt => dt!.Value)\n                .DefaultIfEmpty(sessionStart.AddHours(24))\n                .Min();\n\n            // 2) Initial \"sent\" + statuses from CSL\n            events.Add(new JourneyEventDto\n            {\n                Timestamp = sessionStart,\n                Source = \"System\",\n                EventType = \"MessageSent\",\n                Title = $\"Campaign '{sentLog.Campaign.Name}' sent\",\n                Details = $\"Template '{sentLog.TemplateId}' to {resp.ContactPhone}\",\n                TemplateName = sentLog.TemplateId\n            });\n\n            if (sentLog.DeliveredAt.HasValue && sentLog.DeliveredAt.Value >= sessionStart && sentLog.DeliveredAt.Value < sessionEnd)\n                events.Add(new JourneyEventDto { Timestamp = sentLog.DeliveredAt.Value, Source = \"Provider\", EventType = \"Delivered\", Title = \"Message delivered\", Details = $\"Delivered to {resp.ContactPhone}\", TemplateName = sentLog.TemplateId });\n\n            if (sentLog.ReadAt.HasValue && sentLog.ReadAt.Value >= sessionStart && sentLog.ReadAt.Value < sessionEnd)\n                events.Add(new JourneyEventDto { Timestamp = sentLog.ReadAt.Value, Source = \"Provider\", EventType = \"Read\", Title = \"Message read\", Details = $\"Read by {resp.ContactPhone}\", TemplateName = sentLog.TemplateId });\n\n            // 3) URL clicks for THIS send within the window\n            var urlClicksInitial = await _context.CampaignClickLogs\n                .AsNoTracking()\n                .Where(c => c.CampaignSendLogId == sentLog.Id &&\n                            c.ClickedAt >= sessionStart &&\n                            c.ClickedAt < sessionEnd)\n                .OrderBy(c => c.ClickedAt)\n                .ToListAsync();\n\n            foreach (var c in urlClicksInitial)\n            {\n                events.Add(new JourneyEventDto\n                {\n                    Timestamp = c.ClickedAt,\n                    Source = \"User\",\n                    EventType = \"ButtonClicked\",\n                    Title = $\"Clicked URL Button: '{c.ButtonTitle}'\",\n                    Details = $\"Redirected to {c.Destination}\",\n                    ButtonIndex = c.ButtonIndex,\n                    ButtonTitle = c.ButtonTitle,\n                    Url = c.Destination\n                });\n            }\n\n            // 4) FLOW chain (if any) scoped to THIS session window\n            if (sentLog.CTAFlowConfigId.HasValue)\n            {\n                // Flow label\n                resp.FlowName = await _context.CTAFlowConfigs\n                    .Where(f => f.Id == sentLog.CTAFlowConfigId.Value)\n                    .Select(f => f.FlowName)\n                    .FirstOrDefaultAsync();\n\n                // All flow sends (CSLs) for same contact+flow within the window\n                var flowCslChain = await _context.CampaignSendLogs\n                    .AsNoTracking()\n                    .Where(csl => csl.BusinessId == sentLog.BusinessId &&\n                                  csl.ContactId == sentLog.ContactId &&\n                                  csl.CTAFlowConfigId == sentLog.CTAFlowConfigId &&\n                                  csl.CreatedAt >= sessionStart &&\n                                  csl.CreatedAt < sessionEnd)\n                    .OrderBy(csl => csl.CreatedAt)\n                    .Select(csl => new { csl.Id, csl.MessageLogId, csl.SentAt, csl.CreatedAt, csl.TemplateId, csl.CTAFlowStepId, csl.DeliveredAt, csl.ReadAt })\n                    .ToListAsync();\n\n                var chainCslIds = flowCslChain.Select(x => x.Id).ToList();\n                var chainMsgLogIds = flowCslChain.Where(x => x.MessageLogId.HasValue).Select(x => x.MessageLogId!.Value).ToList();\n\n                // FlowExecutionLogs joined by CSL id\n                var execByCsl = await _context.FlowExecutionLogs\n                    .AsNoTracking()\n                    .Where(f => f.CampaignSendLogId.HasValue &&\n                                chainCslIds.Contains(f.CampaignSendLogId.Value) &&\n                                f.ExecutedAt >= sessionStart &&\n                                f.ExecutedAt < sessionEnd)\n                    .OrderBy(f => f.ExecutedAt)\n                    .ToListAsync();\n\n                // Or by message log id\n                var execByMsg = chainMsgLogIds.Count == 0 ? new List<FlowExecutionLog>()\n                    : await _context.FlowExecutionLogs\n                        .AsNoTracking()\n                        .Where(f => f.MessageLogId.HasValue &&\n                                    chainMsgLogIds.Contains(f.MessageLogId.Value) &&\n                                    f.ExecutedAt >= sessionStart &&\n                                    f.ExecutedAt < sessionEnd)\n                        .OrderBy(f => f.ExecutedAt)\n                        .ToListAsync();\n\n                // Phone fallback (strictly within the session window; accept + or digits-only)\n                var phoneA = resp.ContactPhone ?? \"\";\n                var phoneB = phoneA.StartsWith(\"+\") ? phoneA.Substring(1) : \"+\" + phoneA;\n                var execByPhone = await _context.FlowExecutionLogs\n                    .AsNoTracking()\n                    .Where(f => f.BusinessId == sentLog.BusinessId &&\n                                f.FlowId == sentLog.CTAFlowConfigId &&\n                                (f.ContactPhone == phoneA || f.ContactPhone == phoneB) &&\n                                f.ExecutedAt >= sessionStart &&\n                                f.ExecutedAt < sessionEnd)\n                    .OrderBy(f => f.ExecutedAt)\n                    .ToListAsync();\n\n                var flowExec = execByCsl.Concat(execByMsg).Concat(execByPhone)\n                    .GroupBy(x => x.Id).Select(g => g.First())\n                    .OrderBy(x => x.ExecutedAt).ToList();\n\n                foreach (var fe in flowExec)\n                {\n                    if (!string.IsNullOrWhiteSpace(fe.TriggeredByButton))\n                    {\n                        events.Add(new JourneyEventDto\n                        {\n                            Timestamp = fe.ExecutedAt,\n                            Source = \"User\",\n                            EventType = \"ButtonClicked\",\n                            Title = $\"Clicked Quick Reply: '{fe.TriggeredByButton}'\",\n                            Details = string.IsNullOrWhiteSpace(fe.TemplateName) ? $\"Advanced in flow at step '{fe.StepName}'\" : $\"Triggered next template: '{fe.TemplateName}'\",\n                            StepId = fe.StepId,\n                            StepName = fe.StepName,\n                            ButtonIndex = fe.ButtonIndex.HasValue ? (int?)fe.ButtonIndex.Value : null,\n                            ButtonTitle = fe.TriggeredByButton,\n                            TemplateName = fe.TemplateName\n                        });\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(fe.TemplateName))\n                    {\n                        events.Add(new JourneyEventDto\n                        {\n                            Timestamp = fe.ExecutedAt,\n                            Source = \"System\",\n                            EventType = \"FlowSend\",\n                            Title = $\"Flow sent template '{fe.TemplateName}'\",\n                            Details = $\"Step '{fe.StepName}'\",\n                            StepId = fe.StepId,\n                            StepName = fe.StepName,\n                            TemplateName = fe.TemplateName\n                        });\n                    }\n                }\n\n                // Include the flow CSLs themselves + statuses (within window)\n                foreach (var csl in flowCslChain.Where(x => x.Id != sentLog.Id))\n                {\n                    var ts = csl.SentAt ?? csl.CreatedAt;\n                    events.Add(new JourneyEventDto\n                    {\n                        Timestamp = ts,\n                        Source = \"System\",\n                        EventType = \"FlowSend\",\n                        Title = $\"Flow sent template '{csl.TemplateId}'\",\n                        Details = csl.CTAFlowStepId.HasValue ? $\"Step: {csl.CTAFlowStepId}\" : null,\n                        StepId = csl.CTAFlowStepId,\n                        TemplateName = csl.TemplateId\n                    });\n\n                    if (csl.DeliveredAt.HasValue && csl.DeliveredAt.Value >= sessionStart && csl.DeliveredAt.Value < sessionEnd)\n                        events.Add(new JourneyEventDto { Timestamp = csl.DeliveredAt.Value, Source = \"Provider\", EventType = \"Delivered\", Title = \"Message delivered\", Details = \"\", TemplateName = csl.TemplateId, StepId = csl.CTAFlowStepId });\n\n                    if (csl.ReadAt.HasValue && csl.ReadAt.Value >= sessionStart && csl.ReadAt.Value < sessionEnd)\n                        events.Add(new JourneyEventDto { Timestamp = csl.ReadAt.Value, Source = \"Provider\", EventType = \"Read\", Title = \"Message read\", Details = \"\", TemplateName = csl.TemplateId, StepId = csl.CTAFlowStepId });\n                }\n\n                // URL clicks during the flow (within window)\n                if (chainCslIds.Count > 0)\n                {\n                    var flowClicks = await _context.CampaignClickLogs\n                        .AsNoTracking()\n                        .Where(c => chainCslIds.Contains(c.CampaignSendLogId) &&\n                                    c.ClickedAt >= sessionStart &&\n                                    c.ClickedAt < sessionEnd)\n                        .OrderBy(c => c.ClickedAt)\n                        .ToListAsync();\n\n                    foreach (var c in flowClicks)\n                    {\n                        events.Add(new JourneyEventDto\n                        {\n                            Timestamp = c.ClickedAt,\n                            Source = \"User\",\n                            EventType = \"ButtonClicked\",\n                            Title = $\"Clicked URL: '{c.ButtonTitle}'\",\n                            Details = $\"Redirected to {c.Destination}\",\n                            ButtonIndex = c.ButtonIndex,\n                            ButtonTitle = c.ButtonTitle,\n                            Url = c.Destination\n                        });\n                    }\n                }\n\n                // Where the user left off in this session\n                var lastFlowEvent = events\n                    .Where(e => e.EventType == \"FlowSend\" || e.EventType == \"ButtonClicked\")\n                    .OrderBy(e => e.Timestamp)\n                    .LastOrDefault();\n\n                resp.LeftOffAt = lastFlowEvent?.StepName ?? lastFlowEvent?.Title;\n            }\n\n            resp.Events = events.OrderBy(e => e.Timestamp).ToList();\n            return resp;\n        }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IContactJourneyService.cs",
      "sha256": "e073e1050a64e2ac4cd335378ce53f0ed653944621efaefbd090223ab818c8fe",
      "language": "csharp",
      "size": 341,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs; // Updated namespace\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IContactJourneyService\n    {\n        Task<JourneyResponseDto> GetJourneyEventsAsync(Guid initialCampaignSendLogId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/ITrackingService.cs",
      "sha256": "7331e4a2b1fb44932573c4ed055613cc4ae21dcd9ec54bc25210c57cd340737c",
      "language": "csharp",
      "size": 528,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface ITrackingService\n    {\n        Task LogCTAClickAsync(TrackingLogDto dto);\n        Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId);\n        Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto);\n        Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IUrlBuilderService.cs",
      "sha256": "2415363e2bcc41b916d5b2836a0c28ac68dabd407d67b63661da9feb8372bd56",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IUrlBuilderService\n    {\n\n         string BuildTrackedButtonUrl(\n        Guid campaignSendLogId,\n        int buttonIndex,\n        string? buttonTitle,\n        string destinationUrlAbsolute);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingService.cs",
      "sha256": "90d3f4b3c6a0d5d10d83300d0c3ed58fc81149c2dec145768cfafe2886dccb0b",
      "language": "csharp",
      "size": 9142,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Shared.TrackingUtils;\nusing Serilog;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing AutoMapper;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class TrackingService : ITrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMapper _mapper;\n        public TrackingService(AppDbContext context, IMapper mapper)\n        {\n            _context = context;\n            _mapper = mapper;\n        }\n\n\n        public async Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                // üß† 1. Try enrich from MessageLog (if msg ID provided)\n                if (!string.IsNullOrEmpty(dto.MessageId))\n                {\n                    var messageLog = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m => m.MessageId == dto.MessageId || m.Id.ToString() == dto.MessageId);\n\n                    if (messageLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty ? messageLog.BusinessId : dto.BusinessId;\n                        dto.ContactId ??= messageLog.ContactId;\n                        dto.CampaignId ??= messageLog.CampaignId;\n                        dto.MessageLogId ??= messageLog.Id;\n                    }\n                }\n\n                // üß© 2. Enrich from CampaignSendLog if sourceType = campaign\n                CampaignSendLog? sendLog = null;\n\n                if (dto.SourceType == \"campaign\")\n                {\n                    if (!string.IsNullOrEmpty(dto.MessageId))\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .FirstOrDefaultAsync(c => c.MessageId == dto.MessageId);\n                    }\n\n                    if (sendLog == null && dto.CampaignId != null)\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .Where(c => c.CampaignId == dto.CampaignId)\n                            .OrderByDescending(c => c.CreatedAt)\n                            .FirstOrDefaultAsync();\n                    }\n\n                    if (sendLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty\n                            ? sendLog.Recipient?.BusinessId ?? Guid.Empty\n                            : dto.BusinessId;\n\n                        dto.ContactId ??= sendLog.ContactId;\n                        dto.CampaignId ??= sendLog.CampaignId;\n                        dto.CampaignSendLogId ??= sendLog.Id;\n\n                        // ‚úÖ Update campaign send log click details\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = dto.ClickedAt ?? DateTime.UtcNow;\n                        sendLog.ClickType = dto.ButtonText;\n\n                        await _context.SaveChangesAsync();\n                    }\n                }\n\n                // ‚úÖ 3. Validate business context\n                if (dto.BusinessId == Guid.Empty)\n                {\n                    Log.Warning(\"‚ùå TrackingLog failed: No BusinessId available for click.\");\n                    return ResponseResult.ErrorInfo(\"Business context is missing.\");\n                }\n\n                // üíæ 4. Save tracking log (inline instead of separate method)\n                var trackingLog = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(trackingLog);\n                await _context.SaveChangesAsync();\n\n                // ‚úÖ Return the TrackingLog.Id in the response\n                return ResponseResult.SuccessInfo(\"CTA click tracked successfully.\", trackingLog.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during CTA tracking enrichment\");\n                return ResponseResult.ErrorInfo(\"Exception during tracking: \" + ex.Message);\n            }\n        }\n\n        public async Task LogCTAClickAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                var log = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log CTA click\");\n            }\n        }\n        public async Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId)\n        {\n            var tracking = await _context.TrackingLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (tracking == null)\n                return null;\n\n            var contact = tracking.ContactId != null\n                ? await _context.Contacts.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.ContactId)\n                : null;\n\n            var campaign = tracking.CampaignId != null\n                ? await _context.Campaigns.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.CampaignId)\n                : null;\n\n            var messageLog = tracking.MessageLogId != null\n                ? await _context.MessageLogs.AsNoTracking().FirstOrDefaultAsync(m => m.Id == tracking.MessageLogId)\n                : null;\n\n            return new TrackingLogDetailsDto\n            {\n                Tracking = _mapper.Map<TrackingLogDto>(tracking),\n                Contact = contact != null ? _mapper.Map<ContactDto>(contact) : null,\n                Campaign = campaign != null ? _mapper.Map<CampaignDto>(campaign) : null,\n                MessageLog = messageLog != null ? _mapper.Map<MessageLogDto>(messageLog) : null\n            };\n        }\n        public async Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId)\n        {\n            return await _context.TrackingLogs\n                .Where(x => x.BusinessId == businessId && x.SourceType == \"cta-flow\")\n                .OrderByDescending(x => x.ClickedAt)\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingToken.cs",
      "sha256": "b5250fc25e3e0ca598d78eba428d651a345550debbc5696ceb32b55ce684019e",
      "language": "csharp",
      "size": 809,
      "content": "using System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public static class TrackingToken\n    {\n        public static string Create(object payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var bytes = System.Text.Encoding.UTF8.GetBytes(json);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        public static T Decode<T>(string token)\n        {\n            var bytes = WebEncoders.Base64UrlDecode(token);\n            var json = System.Text.Encoding.UTF8.GetString(bytes);\n            return JsonSerializer.Deserialize<T>(json)!;\n        }\n    }\n\n    // What we put inside the token:\n    public record ClickToken(Guid cid, int btnIndex, string btnTitle, string to, string phone);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/UrlBuilderService.cs",
      "sha256": "8f3156fd79a3ab196299a3f0ebb88e74ebe340db9a0d13bd47189ecc5996109d",
      "language": "csharp",
      "size": 4999,
      "content": "// Features/Tracking/Services/UrlBuilderService.cs\nusing System;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class UrlBuilderService : IUrlBuilderService\n    {\n        private readonly IClickTokenService _token;\n        private readonly TrackingOptions _opt;\n\n        // Allowed schemes for destination links\n        private static readonly string[] AllowedSchemes = new[] { \"http\", \"https\", \"tel\", \"wa\", \"whatsapp\" };\n\n        public UrlBuilderService(IClickTokenService token, IOptions<TrackingOptions> opt)\n        {\n            _token = token;\n            _opt = opt.Value;\n        }\n\n        /// <summary>\n        /// Normalizes destination and enforces an allowlist of schemes:\n        /// http, https, tel, wa, whatsapp.\n        /// Also supports shorthand WhatsApp hosts: wa.me/... and api.whatsapp.com/...\n        /// </summary>\n        private static string NormalizeAbsoluteUrlOrThrow(string input)\n        {\n            if (input is null) throw new ArgumentException(\"Destination URL is null.\", nameof(input));\n\n            // Trim and remove any non-printable/control whitespace characters\n            var s = input.Trim();\n            s = new string(Array.FindAll(s.ToCharArray(), c => !char.IsControl(c)));\n\n            if (s.Length == 0)\n                throw new ArgumentException(\"Destination URL is empty after trimming.\", nameof(input));\n\n            // Short-circuit for already tracked links, just in case this ever gets called that way\n            if (s.Contains(\"/r/\", StringComparison.Ordinal))\n                return s;\n\n            // Support common WhatsApp shorthands without scheme\n            // e.g. \"wa.me/9170...\" or \"api.whatsapp.com/send?phone=...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (s.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    s.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guessWa = \"https://\" + s;\n                    if (Uri.TryCreate(guessWa, UriKind.Absolute, out var waAbs))\n                        return waAbs.AbsoluteUri;\n                }\n            }\n\n            // Accept absolute URIs with allowed schemes\n            if (Uri.TryCreate(s, UriKind.Absolute, out var abs))\n            {\n                var scheme = abs.Scheme ?? string.Empty;\n\n                // Allow only whitelisted schemes\n                var isAllowed = false;\n                for (int i = 0; i < AllowedSchemes.Length; i++)\n                {\n                    if (scheme.Equals(AllowedSchemes[i], StringComparison.OrdinalIgnoreCase))\n                    {\n                        isAllowed = true;\n                        break;\n                    }\n                }\n\n                if (!isAllowed)\n                    throw new ArgumentException(\n                        $\"Destination must use one of: http, https, tel, wa, whatsapp. Got '{scheme}:'\",\n                        nameof(input));\n\n                // http/https ‚Üí return canonical AbsoluteUri\n                if (scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return abs.AbsoluteUri;\n                }\n\n                // tel:/wa:/whatsapp://send ‚Üí return as provided (trimmed), do not modify\n                return s;\n            }\n\n            // Human input like \"www.example.com/...\" or \"example.com/...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal) && s.Contains('.', StringComparison.Ordinal))\n            {\n                var guess = \"https://\" + s;\n                if (Uri.TryCreate(guess, UriKind.Absolute, out var httpAbs))\n                    return httpAbs.AbsoluteUri;\n            }\n\n            throw new ArgumentException(\n                $\"Destination must be an absolute URL or allowed deep link (http, https, tel, wa, whatsapp). Got: '{input}'\",\n                nameof(input));\n        }\n\n        public string BuildTrackedButtonUrl(\n            Guid campaignSendLogId,\n            int buttonIndex,\n            string? buttonTitle,\n            string destinationUrlAbsolute)\n        {\n            var dest = NormalizeAbsoluteUrlOrThrow(destinationUrlAbsolute);\n\n            var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n            var exp = now + (long)_opt.TokenTtl.TotalSeconds;\n\n            var payload = new ClickTokenPayload(\n                cid: campaignSendLogId,\n                bi: buttonIndex,\n                bt: buttonTitle ?? string.Empty,\n                to: dest,\n                iat: now,\n                exp: exp\n            );\n\n            var token = _token.Create(payload);\n            return $\"{_opt.BaseUrl.TrimEnd('/')}/r/{token}\";\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "4a0dbbf63a7e5e5dbdea08790538d449d81f91e4234da7a4b8acedf0ff744b25",
      "language": "csharp",
      "size": 3019,
      "content": "using System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services;\nusing xbytechat.api.Features.Webhooks.DTOs;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var clonedPayload = payload.Clone(); // ‚úÖ Avoid disposal issue\n\n                using var scope = _scopeFactory.CreateScope();\n\n                // üîÑ Resolve scoped dependencies\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                // üöÄ Dispatch\n                await dispatcher.DispatchAsync(clonedPayload);\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error while processing webhook payload.\");\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                       // RawJson = ex.Data[\"payload\"]?.ToString() ?? \"(unavailable)\",\n                        RawJson = ex.Data[\"payload\"]?.ToString() ?? \"{}\",\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    await failureLogger.LogFailureAsync(fallback);\n                }\n                catch (Exception innerEx)\n                {\n                    _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to log to FailedWebhookLogs table.\");\n                }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookCallback.cs",
      "sha256": "0353a97ed4f6c1349262de94a5e68f37d87955d3b6735e595aedc13f2b2f7365",
      "language": "csharp",
      "size": 2481,
      "content": "// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhookcallback\")]\n    public class WebhookCallbackController : ControllerBase\n    {\n        private readonly ILogger<WebhookCallbackController> _logger;\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookCallbackController(\n            ILogger<WebhookCallbackController> logger,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _queue = queue;\n        }\n\n        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here\n        [HttpPost]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)\n        {\n            if (!Request.HasJsonContentType())\n            {\n                return BadRequest(new { error = \"Content-Type must be application/json\" });\n            }\n\n            try\n            {\n                var raw = payload.GetRawText();\n                _logger.LogInformation(\"üì• Webhook received. bytes={Len}\", raw.Length);\n\n                // Clone JsonElement before queueing\n                _queue.Enqueue(payload.Clone());\n\n                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily\n                return Ok(new { received = true });\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Webhook processing cancelled by client.\");\n                return StatusCode(499);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue webhook payload.\");\n                // 500 lets BSP retry later\n                return StatusCode(500, new { error = \"webhook_enqueue_failed\" });\n            }\n        }\n    }\n\n    // Small helper for JSON content-type\n    internal static class HttpRequestContentTypeExtensions\n    {\n        public static bool HasJsonContentType(this HttpRequest request)\n        {\n            if (request?.ContentType is null) return false;\n            return request.ContentType.StartsWith(\"application/json\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "d25c1bf6870c1712f3270bf8e478e741c09e7d32497bb0f3e64885e8e5c6c7ec",
      "language": "csharp",
      "size": 2801,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n            public WhatsAppWebhookController(ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config, AppDbContext context, IWhatsAppWebhookService webhookService, IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            // üîê Load your secret token from config or environment\n            var expectedToken = _config[\"WhatsApp:MetaToken\"];\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\"‚ùå WhatsApp webhook verification failed.\");\n            return Forbid(\"Token mismatch.\");\n        }\n\n     \n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            _logger.LogWarning(\"üì• Webhook received at controller:\\n\" + payload.ToString());\n\n            try\n            {\n                var cloned = payload.Clone(); // Important to clone here\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/IProviderDirectory.cs",
      "sha256": "9c5e07f8d7488efd67624a5d0b04fe85acf0163688ba6a704f500383e17210d4",
      "language": "csharp",
      "size": 995,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// Resolves BusinessId from provider-specific webhook identifiers.\n    /// </summary>\n    public interface IProviderDirectory\n    {\n        /// <param name=\"provider\">\"meta\" or \"pinnacle\" (lowercase preferred)</param>\n        /// <param name=\"phoneNumberId\">Meta/Pinnacle phone_number_id (strongest key)</param>\n        /// <param name=\"displayPhoneNumber\">Formatted sending number (e.g. \"+91XXXXXXXXXX\")</param>\n        /// <param name=\"wabaId\">WhatsApp Business Account ID (Meta)</param>\n        /// <param name=\"waId\">Optional WA ID (recipient); used only as a last-ditch heuristic</param>\n        Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/ProviderDirectory.cs",
      "sha256": "5bdcab88c349cdadff7bc3ce2ec8cf39b61659a39a7bf028bd2267fc0aa36cbd",
      "language": "csharp",
      "size": 5184,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.\n    /// </summary>\n    public class ProviderDirectory : IProviderDirectory\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ProviderDirectory> _logger;\n        private readonly IMemoryCache _cache;\n\n        // reduce DB hits during webhook bursts\n        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);\n\n        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)\n        {\n            _db = db;\n            _logger = logger;\n            _cache = cache;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default)\n        {\n            provider = provider?.Trim().ToLowerInvariant();\n\n            var cacheKey = $\"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}\";\n            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))\n                return cached;\n\n            try\n            {\n                // ‚öì 1) Strongest match: provider + phone_number_id\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 2) Next: provider + display_phone_number (normalized)\n                var normalizedDisplay = Normalize(displayPhoneNumber);\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))\n                {\n                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 3) Next: provider + wabaId (Meta)\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))\n                {\n                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                _logger.LogWarning(\n                    \"ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}\",\n                    provider, phoneNumberId, normalizedDisplay, wabaId\n                );\n                return CacheAndReturn(cacheKey, null);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ProviderDirectory lookup failed.\");\n                return null;\n            }\n        }\n\n        private Guid? CacheAndReturn(string key, Guid? value)\n        {\n            _cache.Set(key, value, CacheTtl);\n            return value;\n        }\n\n        /// <summary>\n        /// Centralized query; now materializes candidates so Normalize() runs in-memory.\n        /// </summary>\n        private async Task<Guid?> QueryByAsync(\n            string provider,\n            string? phoneNumberId = null,\n            string? displayPhoneNumber = null,\n            string? wabaId = null,\n            CancellationToken ct = default)\n        {\n            // Only bring back what we need\n            var candidates = await _db.Set<WhatsAppSettingEntity>()\n                .AsNoTracking()\n                .Where(s => s.IsActive && s.Provider.ToLower() == provider)\n                .Select(s => new\n                {\n                    s.BusinessId,\n                    s.PhoneNumberId,\n                    s.WhatsAppBusinessNumber,\n                    s.WabaId\n                })\n                .ToListAsync(ct);\n\n            var normDisp = Normalize(displayPhoneNumber);\n\n            var hit = candidates.FirstOrDefault(s =>\n                (!string.IsNullOrEmpty(phoneNumberId) && s.PhoneNumberId == phoneNumberId) ||\n                (!string.IsNullOrEmpty(normDisp) && Normalize(s.WhatsAppBusinessNumber) == normDisp) ||\n                (!string.IsNullOrEmpty(wabaId) && s.WabaId == wabaId)\n            );\n\n            return hit?.BusinessId;\n        }\n\n        /// <summary>\n        /// Normalize phone formatting for robust comparisons.\n        /// </summary>\n        private static string? Normalize(string? phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone)) return null;\n            var trimmed = phone.Trim();\n            var hasPlus = trimmed.StartsWith(\"+\");\n            var digits = new string(trimmed.Where(char.IsDigit).ToArray());\n            return hasPlus ? \"+\" + digits : digits;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Controllers/PinnacleWebhookController.cs",
      "sha256": "347412f9e7ce91e2e2852339fcb267da0f2153f38df4bfe8902a1f0b4a678ca8",
      "language": "csharp",
      "size": 1235,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers\n{\n    [ApiController]\n    [Route(\"api/pinnacle/callback\")]\n    public sealed class PinnacleWebhookController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n        private readonly IPinnacleToMetaAdapter _adapter;\n        private readonly ILogger<PinnacleWebhookController> _logger;\n\n        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)\n        {\n            _queue = queue;\n            _adapter = adapter;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public IActionResult Post([FromBody] JsonElement body)\n        {\n            // Transform to the envelope WhatsAppWebhookDispatcher already expects\n            var metaEnvelope = _adapter.ToMetaEnvelope(body);\n            _queue.Enqueue(metaEnvelope);\n            _logger.LogInformation(\"üì® Pinnacle payload transformed and enqueued.\");\n            return Ok(new { received = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/IPinnacleToMetaAdapter.cs",
      "sha256": "7daf100e2d244ce83b0c3f91f8e006bce5359eddf8fe6f7cf2b046f9e071c17b",
      "language": "csharp",
      "size": 364,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters\n{\n    public interface IPinnacleToMetaAdapter\n    {\n        /// <summary>Converts provider-native payload to Meta-like envelope:\n        /// { \"entry\":[{ \"changes\":[{ \"value\": { ... } }]}] }</summary>\n        JsonElement ToMetaEnvelope(JsonElement pinnPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/PinnacleToMetaAdapter.cs",
      "sha256": "38b4863c5f4881b2196ae42ce86a47b8d92904a61daad400ab8d1e7e5db2d289",
      "language": "csharp",
      "size": 9751,
      "content": "using System.Buffers;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n\npublic sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter\n{\n    public JsonElement ToMetaEnvelope(JsonElement p)\n    {\n        var buf = new ArrayBufferWriter<byte>();\n        using var w = new Utf8JsonWriter(buf);\n\n        w.WriteStartObject();\n        w.WritePropertyName(\"entry\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // entry[0]\n        w.WritePropertyName(\"changes\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // changes[0]\n        w.WritePropertyName(\"value\");\n        w.WriteStartObject();\n\n        // NEW: try to emit metadata up-front (harmless if not found)\n        WriteMetadata(p, w);\n\n        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))\n        {\n            w.WritePropertyName(\"provider_raw\");\n            p.WriteTo(w);\n        }\n\n        w.WriteEndObject(); // value\n        w.WriteEndObject(); // change\n        w.WriteEndArray();  // changes\n        w.WriteEndObject(); // entry[0]\n        w.WriteEndArray();  // entry\n        w.WriteEndObject(); // root\n        w.Flush();\n\n        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);\n        using var doc = JsonDocument.Parse(ros);\n        return doc.RootElement.Clone();\n    }\n\n    // ---- NEW ----\n    // Best-effort extraction; tolerate any Pinnacle layout you have.\n    // We only write fields if we can resolve them.\n    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)\n    {\n        string? displayPhone = null;\n        string? phoneNumberId = null;\n        string? wabaId = null;\n\n        // common guesses; add/rename to match your Pinnacle payload\n        // 1) flat\n        if (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();\n        if (p.TryGetProperty(\"phone_number_id\", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();\n        if (p.TryGetProperty(\"waba_id\", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();\n\n        // 2) channel\n        if (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && ch.TryGetProperty(\"display_phone_number\", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();\n            if (displayPhone is null && ch.TryGetProperty(\"phone\", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();\n\n            if (phoneNumberId is null && ch.TryGetProperty(\"phone_number_id\", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();\n            if (phoneNumberId is null && ch.TryGetProperty(\"id\", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();\n\n            if (wabaId is null && ch.TryGetProperty(\"waba_id\", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();\n        }\n\n        // 3) meta-style wrapper\n        if (p.TryGetProperty(\"metadata\", out var meta) && meta.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && meta.TryGetProperty(\"display_phone_number\", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();\n            if (phoneNumberId is null && meta.TryGetProperty(\"phone_number_id\", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();\n            if (wabaId is null && meta.TryGetProperty(\"waba_id\", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();\n        }\n\n        if (displayPhone is null && p.TryGetProperty(\"business\", out var biz) && biz.ValueKind == JsonValueKind.Object)\n        {\n            if (biz.TryGetProperty(\"phone\", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();\n            if (biz.TryGetProperty(\"phone_id\", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();\n        }\n\n        // Only emit if we have at least one of them.\n        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)\n        {\n            w.WritePropertyName(\"metadata\");\n            w.WriteStartObject();\n            if (displayPhone is not null) w.WriteString(\"display_phone_number\", displayPhone);\n            if (phoneNumberId is not null) w.WriteString(\"phone_number_id\", phoneNumberId);\n            if (wabaId is not null) w.WriteString(\"waba_id\", wabaId);\n            w.WriteEndObject();\n        }\n    }\n    // ---- NEW END ----\n\n    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)\n    {\n        string? id = null, status = null;\n        long? ts = null;\n\n        if (p.TryGetProperty(\"messageId\", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();\n        if (p.TryGetProperty(\"id\", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();\n        if (p.TryGetProperty(\"status\", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();\n\n        if (p.TryGetProperty(\"timestamp\", out var t))\n        {\n            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();\n            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;\n        }\n\n        if (p.TryGetProperty(\"data\", out var d) && d.ValueKind == JsonValueKind.Object)\n        {\n            if (id is null && d.TryGetProperty(\"id\", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();\n            if (status is null && d.TryGetProperty(\"status\", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();\n            if (ts is null && d.TryGetProperty(\"ts\", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();\n        }\n\n        if (id is null || status is null) return false;\n\n        w.WritePropertyName(\"statuses\");\n        w.WriteStartArray();\n        w.WriteStartObject();\n        w.WriteString(\"id\", id);\n        w.WriteString(\"status\", status);\n        if (ts.HasValue) w.WriteNumber(\"timestamp\", ts.Value);\n        w.WriteEndObject();\n        w.WriteEndArray();\n        return true;\n    }\n\n    \n    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)\n    {\n        // { \"click\": { \"title\":\"Flow Test\", \"contextId\":\"wamid..\", \"from\":\"<biz_phone?>\" , \"user\":\"<customer_wa_id?>\" } }\n        if (p.TryGetProperty(\"click\", out var c) && c.ValueKind == JsonValueKind.Object)\n        {\n            var title = c.TryGetProperty(\"title\", out var t) ? t.GetString() : null;\n            var ctxId = c.TryGetProperty(\"contextId\", out var ctx) ? ctx.GetString() : null;\n\n            // customer who clicked\n            var customerFrom = c.TryGetProperty(\"user\", out var u) && u.ValueKind == JsonValueKind.String\n                ? u.GetString()\n                : (c.TryGetProperty(\"from\", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);\n\n            // **business** number that sent the message (Meta provides this as context.from)\n            var businessFrom =\n                (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :\n                (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object &&\n                 ch.TryGetProperty(\"phone\", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :\n                (c.TryGetProperty(\"from\", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort\n\n            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))\n            {\n                w.WritePropertyName(\"messages\");\n                w.WriteStartArray();\n                w.WriteStartObject();\n                w.WriteString(\"type\", \"button\");\n                w.WriteString(\"from\", customerFrom ?? \"\");          // customer wa_id\n                w.WritePropertyName(\"button\");\n                w.WriteStartObject();\n                w.WriteString(\"text\", title!);\n                w.WriteEndObject();\n                w.WritePropertyName(\"context\");\n                w.WriteStartObject();\n                w.WriteString(\"id\", ctxId!);\n                if (!string.IsNullOrWhiteSpace(businessFrom))\n                    w.WriteString(\"from\", businessFrom!);           // **important for directory resolution**\n                w.WriteEndObject();\n                w.WriteEndObject();\n                w.WriteEndArray();\n                return true;\n            }\n        }\n\n        // { \"message\": { \"from\":\"<customer_wa_id>\", \"body\":\"hi\", \"type\":\"text\" }, \"channel\":{ \"phone\":\"<biz_phone>\" } }\n        if (p.TryGetProperty(\"message\", out var m) && m.ValueKind == JsonValueKind.Object)\n        {\n            var type = m.TryGetProperty(\"type\", out var tp) ? tp.GetString() : \"text\";\n            var from = m.TryGetProperty(\"from\", out var fr) ? fr.GetString() : \"\";\n\n            w.WritePropertyName(\"messages\");\n            w.WriteStartArray();\n            w.WriteStartObject();\n            w.WriteString(\"type\", type ?? \"text\");\n            w.WriteString(\"from\", from ?? \"\");\n            if ((type ?? \"text\") == \"text\")\n            {\n                var body = m.TryGetProperty(\"body\", out var bd) ? bd.GetString() : \"\";\n                w.WritePropertyName(\"text\");\n                w.WriteStartObject();\n                w.WriteString(\"body\", body ?? \"\");\n                w.WriteEndObject();\n            }\n            w.WriteEndObject();\n            w.WriteEndArray();\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "68f4211391a24a94d3096c5cd71fbd6cbd0fed0211dd2929b92b1780ffd02fc8",
      "language": "csharp",
      "size": 2109,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceProvider _services;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(ILogger<FailedWebhookLogCleanupService> logger, IServiceProvider services)\n        {\n            _logger = logger;\n            _services = services;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _services.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Any())\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\"üßπ Deleted {Count} old failed webhook logs.\", oldLogs.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                await Task.Delay(_interval, stoppingToken); // wait before next cleanup\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "ad5a6464f10897dfa75f4fdc1d7914492c73a593d01d71de18ed75df95de1836",
      "language": "csharp",
      "size": 293,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService.cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "43ad2f563b35072aeeda5cd8b04c703daaa4ba8cdc8711be3c2e167e519a5ae6",
      "language": "csharp",
      "size": 19650,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n        private readonly IFlowRuntimeService _flowRuntime;\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService,\n                        IFlowRuntimeService flowRuntime\n            )\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n            _flowRuntime = flowRuntime;\n\n        }\n\n       \n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                    return;\n\n                static string Norm(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n                    return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n                                 .Trim()\n                                 .ToLowerInvariant();\n                }\n\n                static string NormalizePhone(string? raw)\n                {\n                    if (string.IsNullOrWhiteSpace(raw)) return \"\";\n                    var p = raw.Trim();\n                    return p.StartsWith(\"+\") ? p.Substring(1) : p; // store digits-only (or pick one convention)\n                }\n\n                foreach (var msg in messages.EnumerateArray())\n                {\n                    if (!msg.TryGetProperty(\"type\", out var typeProp))\n                        continue;\n\n                    var type = typeProp.GetString();\n\n                    string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                    string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n                        ? ctxId.GetString()\n                        : null;\n                    string from = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n\n                    // ‚Äî‚Äî‚Äî button label extraction\n                    string? buttonText = null;\n                    if (type == \"button\")\n                    {\n                        buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n                                     btn.TryGetProperty(\"text\", out var textProp)\n                                       ? textProp.GetString()?.Trim()\n                                       : null;\n                    }\n                    else if (type == \"interactive\" && msg.TryGetProperty(\"interactive\", out var interactive))\n                    {\n                        if (interactive.TryGetProperty(\"type\", out var intrType) &&\n                            string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n                            interactive.TryGetProperty(\"button_reply\", out var br) &&\n                            br.TryGetProperty(\"title\", out var titleProp))\n                        {\n                            buttonText = titleProp.GetString()?.Trim();\n                        }\n                        else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n                                 lr.TryGetProperty(\"title\", out var listTitleProp))\n                        {\n                            buttonText = listTitleProp.GetString()?.Trim();\n                        }\n                    }\n\n                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}\", type);\n                        continue;\n                    }\n\n                    _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                        from, clickMessageId, originalMessageId, buttonText);\n\n                    // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)\n                    var origin = await _context.MessageLogs\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId &&\n                            m.CTAFlowConfigId != null &&\n                            m.CTAFlowStepId != null);\n\n                    Guid businessId;\n                    Guid flowId;\n                    Guid stepId;\n                    string? bundleJson = null;\n                    int? flowVersion = null;\n\n                    Guid? campaignSendLogId = null; // üëà we will always try to set this\n                    Guid? runId = null;             // üëà NEW: will copy from the parent CSL\n\n                    if (origin != null)\n                    {\n                        businessId = origin.BusinessId;\n                        flowId = origin.CTAFlowConfigId!.Value;\n                        stepId = origin.CTAFlowStepId!.Value;\n                        bundleJson = origin.ButtonBundleJson;\n                        flowVersion = origin.FlowVersion;\n\n                        // map back to CSL via MessageLogId or WAMID and fetch RunId\n                        var cslInfo = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n                            .OrderByDescending(csl => csl.CreatedAt)\n                            .Select(csl => new { csl.Id, csl.RunId })\n                            .FirstOrDefaultAsync();\n\n                        campaignSendLogId = cslInfo?.Id;\n                        runId = cslInfo?.RunId;\n                    }\n                    else\n                    {\n                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n                        var sendLog = await _context.CampaignSendLogs\n                            .Include(sl => sl.Campaign)\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n                        if (sendLog == null)\n                        {\n                            _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        businessId = sendLog.BusinessId != Guid.Empty\n                            ? sendLog.BusinessId\n                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n                        if (businessId == Guid.Empty)\n                        {\n                            _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        campaignSendLogId = sendLog.Id; // üëà link the click to this send\n                        runId = sendLog.RunId;          // üëà NEW: capture the run id\n\n                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n                        {\n                            flowId = sendLog.CTAFlowConfigId.Value;\n                            stepId = sendLog.CTAFlowStepId.Value;\n                        }\n                        else if (sendLog.Campaign?.CTAFlowConfigId != null)\n                        {\n                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n                            var entry = await _context.CTAFlowSteps\n                                .Where(s => s.CTAFlowConfigId == flowId)\n                                .OrderBy(s => s.StepOrder)\n                                .Select(s => s.Id)\n                                .FirstOrDefaultAsync();\n\n                            if (entry == Guid.Empty)\n                            {\n                                _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n                                continue;\n                            }\n\n                            stepId = entry;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        bundleJson = sendLog.ButtonBundleJson;\n                    }\n\n                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n                    short? buttonIndex = null;\n                    FlowBtnBundleNode? hit = null;\n\n                    if (!string.IsNullOrWhiteSpace(bundleJson))\n                    {\n                        try\n                        {\n                            var nodes = System.Text.Json.JsonSerializer\n                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n                            hit = nodes.FirstOrDefault(n =>\n                                string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n                            if (hit != null)\n                                buttonIndex = (short)hit.i;\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n                        }\n                    }\n\n                    // ‚Äî‚Äî Fallback: find link by TEXT for this step\n                    FlowButtonLink? linkMatchedByText = null;\n                    if (buttonIndex == null)\n                    {\n                        var stepLinks = await _context.FlowButtonLinks\n                            .Where(l => l.CTAFlowStepId == stepId)\n                            .OrderBy(l => l.ButtonIndex)\n                            .ToListAsync();\n\n                        if (stepLinks.Count > 0)\n                        {\n                            linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n                            if (linkMatchedByText == null && stepLinks.Count == 1)\n                            {\n                                linkMatchedByText = stepLinks[0];\n                                _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n                            }\n\n                            if (linkMatchedByText != null)\n                            {\n                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n                                _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n                                    buttonIndex, flowId, stepId);\n                            }\n                        }\n                    }\n\n                    if (buttonIndex == null)\n                    {\n                        _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n                            originalMessageId, buttonText);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n                               ?? linkMatchedByText;\n\n                    if (link == null)\n                    {\n                        _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n                            flowId, stepId, buttonIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Resolve index + step name (for logging)\n                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n                    var stepName = await _context.CTAFlowSteps\n                        .Where(s => s.Id == stepId)\n                        .Select(s => s.TemplateToSend)\n                        .FirstOrDefaultAsync() ?? string.Empty;\n\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    // üìù WRITE CLICK LOG (always, even if terminal)\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    try\n                    {\n                        var clickExec = new FlowExecutionLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            FlowId = flowId,\n                            StepId = stepId,\n                            StepName = stepName,\n                            CampaignSendLogId = campaignSendLogId,  // links this click to the shown message\n                            MessageLogId = origin?.Id,\n                            ContactPhone = NormalizePhone(from),\n                            ButtonIndex = resolvedIndex,\n                            TriggeredByButton = buttonText,\n                            TemplateName = null,                    // will be set by runtime on send (if you also log sends)\n                            TemplateType = \"quick_reply\",\n                            Success = true,\n                            ExecutedAt = DateTime.UtcNow,\n                            RequestId = Guid.NewGuid(),\n                            RunId = runId                           // üëà NEW: copy parent CSL's RunId\n                        };\n\n                        _context.FlowExecutionLogs.Add(clickExec);\n                        await _context.SaveChangesAsync();\n                    }\n                    catch (Exception exSave)\n                    {\n                        _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n                    }\n\n                    // ‚Äî‚Äî If terminal/URL button: we already logged the click; optionally log CampaignClickLog here\n                    if (link.NextStepId == null)\n                    {\n                        _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n                            flowId, stepId, resolvedIndex, link.ButtonText);\n\n                        // OPTIONAL: if you log URL clicks here (instead of your redirect endpoint), include RunId too:\n                        // _context.CampaignClickLogs.Add(new CampaignClickLog {\n                        //     Id = Guid.NewGuid(),\n                        //     CampaignSendLogId = campaignSendLogId!.Value,\n                        //     ButtonIndex = resolvedIndex,\n                        //     ButtonTitle = buttonText,\n                        //     Destination = \"<resolved-url-if-known>\",\n                        //     ClickedAt = DateTime.UtcNow,\n                        //     RunId = runId                               // üëà include\n                        // });\n                        // await _context.SaveChangesAsync();\n\n                        continue;\n                    }\n\n                    if (_flowRuntime == null)\n                    {\n                        _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Execute next\n                    var ctxObj = new NextStepContext\n                    {\n                        BusinessId = businessId,\n                        FlowId = flowId,\n                        Version = flowVersion ?? 1,\n                        SourceStepId = stepId,\n                        TargetStepId = link.NextStepId,   // not null here\n                        ButtonIndex = resolvedIndex,\n                        MessageLogId = origin?.Id ?? Guid.Empty,\n                        ContactPhone = from,\n                        RequestId = Guid.NewGuid(),\n                        ClickedButton = link\n                        // If your NextStepContext supports it, also pass RunId = runId\n                    };\n\n                    try\n                    {\n                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n                        // ‚ö†Ô∏è Make sure your flow send path copies the parent CSL.RunId\n                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n                        {\n                            _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n                        }\n                    }\n                    catch (Exception exRun)\n                    {\n                        _logger.LogError(exRun,\n                            \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, from, originalMessageId, buttonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n        private sealed class FlowBtnBundleNode\n        {\n            public int i { get; init; }\n            public string? t { get; init; }   // button text/title\n            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)\n            public string? v { get; init; }   // value/payload (e.g., URL)\n            public Guid? ns { get; init; }    // next step id\n        }\n\n\n    \n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "88a853847d7ddb7fadd49567a23f05a00cfeb475417797f125704a23f396696a",
      "language": "csharp",
      "size": 6482,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\n\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory)\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n        }\n\n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n                // ‚úÖ 1. Extract WhatsApp metadata and message\n                var msg = value.GetProperty(\"messages\")[0];\n                var contactPhone = msg.GetProperty(\"from\").GetString()!;\n                var content = msg.GetProperty(\"text\").GetProperty(\"body\").GetString();\n                var businessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString()!;\n\n                // ‚úÖ 2. Resolve business by WhatsApp number\n                var business = await db.Businesses\n                    .Include(b => b.WhatsAppSettings)\n                    .FirstOrDefaultAsync(b => b.WhatsAppSettings.WhatsAppBusinessNumber == businessNumber);\n\n                if (business == null)\n                {\n                    logger.LogWarning(\"‚ùå Business not found for WhatsApp number: {Number}\", businessNumber);\n                    return;\n                }\n\n                var businessId = business.Id;\n\n                // ‚úÖ 3. Find or create contact\n                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // ‚úÖ 4. Check chat mode (skip inbox sync if not agent)\n                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // ‚úÖ 5. Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                // ‚úÖ 6. Try to trigger automation by keyword\n                try\n                {\n                    var triggerKeyword = content.Trim().ToLower();\n                    var handled = await automationService.TryRunFlowByKeywordAsync(\n                        businessId,\n                        triggerKeyword,\n                        contact.PhoneNumber,\n                        sourceChannel: \"whatsapp\",\n                        industryTag: \"default\"\n                    );\n\n                    if (!handled)\n                    {\n                        logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n                }\n\n                // ‚úÖ 7. Only sync to inbox if chat mode is agent\n                if (isAgentMode)\n                {\n                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                    {\n                        BusinessId = businessId,\n                        ContactId = contact.Id,\n                        RecipientPhone = contact.PhoneNumber,\n                        MessageBody = messageLog.MessageContent,\n                        IsIncoming = true,\n                        Status = messageLog.Status,\n                        SentAt = messageLog.CreatedAt\n                    });\n\n                    logger.LogInformation(\"üì• Message synced to inbox for contact {Phone}\", contactPhone);\n                }\n                else\n                {\n                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "5e4ad8a6b9cfece35403204938588d1ef8db2031afbc328d880acb1ee2231a25",
      "language": "csharp",
      "size": 238,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "8749f0f8cf17ab2fa69210d1844138a078fe8538d1e8062b0d2014146877dcc1",
      "language": "csharp",
      "size": 11778,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\n// üëá where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog\nusing xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    /// <summary>\n    /// Legacy status processor (back-compat).\n    /// - Extracts statuses from the payload\n    /// - Resolves CampaignSendLog via IMessageIdResolver when possible\n    /// - Updates CampaignSendLog / MessageLog idempotently\n    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.\n    /// </summary>\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver)\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n        }\n\n        /// <summary>\n        /// Entry point from dispatcher (legacy path).\n        /// Normalizes Meta envelope to a \"value\" object, then processes.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogDebug(\"status_webhook_in (legacy) \\n{Payload}\", payload.ToString());\n\n            // 1) Envelope ‚Üí value\n            if (TryExtractValue(payload, out var value))\n            {\n                await ProcessAsync(value);\n                return;\n            }\n\n            // 2) Already value-like (adapter flattened)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                (payload.TryGetProperty(\"statuses\", out _) || payload.TryGetProperty(\"messages\", out _)))\n            {\n                await ProcessAsync(payload);\n                return;\n            }\n\n            _logger.LogWarning(\"Unrecognized status payload shape (legacy path).\");\n        }\n\n        /// <summary>\n        /// Extract statuses from a Meta-like \"value\" object and update DB.\n        /// </summary>\n        public async Task ProcessAsync(JsonElement value)\n        {\n            if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è 'statuses' array missing in webhook payload (legacy path).\");\n                return;\n            }\n\n            foreach (var status in statuses.EnumerateArray())\n            {\n                if (status.ValueKind != JsonValueKind.Object) continue;\n\n                // message id (WAMID)\n                var messageId = status.TryGetProperty(\"id\", out var idEl) && idEl.ValueKind == JsonValueKind.String\n                    ? idEl.GetString()\n                    : null;\n\n                // status text\n                var statusText = status.TryGetProperty(\"status\", out var stEl) && stEl.ValueKind == JsonValueKind.String\n                    ? stEl.GetString()\n                    : null;\n\n                if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or status in webhook payload (legacy path).\");\n                    continue;\n                }\n\n                // timestamp (string or number)\n                DateTime? eventTime = null;\n                if (status.TryGetProperty(\"timestamp\", out var tsEl))\n                {\n                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))\n                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;\n                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))\n                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;\n                }\n\n                _logger.LogDebug(\"üïì Parsed timestamp: {Time} (raw kind={Kind})\",\n                    eventTime?.ToString(\"o\") ?? \"n/a\", status.TryGetProperty(\"timestamp\", out var tsDbg) ? tsDbg.ValueKind.ToString() : \"n/a\");\n\n                // ‚úÖ First try resolving a CampaignSendLog row via resolver\n                Guid? sendLogId = null;\n                try\n                {\n                    sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"MessageId resolver failed for {MessageId}\", messageId);\n                }\n\n                if (sendLogId is Guid sid)\n                {\n                    var log = await _context.Set<CampaignSendLog>()\n                                            .FirstOrDefaultAsync(l => l.Id == sid);\n\n                    if (log != null)\n                    {\n                        bool changed = false;\n\n                        var newStatus = MapMetaStatus(statusText);\n                        if (!string.IsNullOrEmpty(newStatus) &&\n                            !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n                        {\n                            log.SendStatus = newStatus;\n                            changed = true;\n                        }\n\n                        if (statusText == \"sent\" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)\n                        {\n                            log.SentAt = eventTime.Value;\n                            changed = true;\n                        }\n                        if (statusText == \"delivered\" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)\n                        {\n                            log.DeliveredAt = eventTime.Value;\n                            changed = true;\n                        }\n                        if (statusText == \"read\" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)\n                        {\n                            log.ReadAt = eventTime.Value;\n                            changed = true;\n                        }\n\n                        if (changed)\n                        {\n                            await _context.SaveChangesAsync();\n                            _logger.LogInformation(\"‚úÖ CampaignSendLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, newStatus ?? statusText);\n                        }\n                        else\n                        {\n                            _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n                        }\n\n                        continue; // done with this status item\n                    }\n                }\n\n                // üîÅ Fallback: update MessageLog when there‚Äôs no CampaignSendLog\n                var msg = await _context.Set<MessageLog>()\n                                        .FirstOrDefaultAsync(m => m.MessageId == messageId);\n\n                if (msg != null)\n                {\n                    bool changed = false;\n\n                    switch (statusText)\n                    {\n                        case \"sent\":\n                            if (!EqualsIgnoreCase(msg.Status, \"Sent\"))\n                            {\n                                msg.Status = \"Sent\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value;\n                                changed = true;\n                            }\n                            break;\n\n                        case \"delivered\":\n                            // no DeliveredAt column on MessageLog; just progression\n                            if (!EqualsIgnoreCase(msg.Status, \"Read\") &&\n                                !EqualsIgnoreCase(msg.Status, \"Delivered\"))\n                            {\n                                msg.Status = \"Delivered\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value; // ensure SentAt eventually set\n                                changed = true;\n                            }\n                            break;\n\n                        case \"read\":\n                            if (!EqualsIgnoreCase(msg.Status, \"Read\"))\n                            {\n                                msg.Status = \"Read\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value;\n                                changed = true;\n                            }\n                            break;\n\n                        default:\n                            // leave as-is for unknown statuses\n                            break;\n                    }\n\n                    if (changed)\n                    {\n                        await _context.SaveChangesAsync();\n                        _logger.LogInformation(\"‚ÑπÔ∏è MessageLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, msg.Status);\n                    }\n                    else\n                    {\n                        _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n                    }\n                }\n                else\n                {\n                    // lower severity; common when a send failed before obtaining a message id\n                    _logger.LogInformation(\"‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)\", messageId);\n                }\n            }\n        }\n\n        // ----------------- helpers -----------------\n\n        private static bool TryExtractValue(JsonElement payload, out JsonElement value)\n        {\n            value = default;\n            if (payload.ValueKind != JsonValueKind.Object) return false;\n            if (!payload.TryGetProperty(\"entry\", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;\n\n            var e0 = entry[0];\n            if (!e0.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;\n\n            var c0 = changes[0];\n            if (!c0.TryGetProperty(\"value\", out var v) || v.ValueKind != JsonValueKind.Object) return false;\n\n            value = v;\n            return true;\n        }\n\n        private static string? MapMetaStatus(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => \"Sent\",\n                \"delivered\" => \"Delivered\",\n                \"read\" => \"Read\",\n                \"failed\" => \"Failed\",\n                \"deleted\" => \"Deleted\",\n                _ => null\n            };\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "a9129664eb60ff771e1f4895a51f74dd7277f7693c9a9638cab9363dc4618baa",
      "language": "csharp",
      "size": 369,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "34280daacb42fd65daf76845f254009aff42867432c235250272bb6fc6676084",
      "language": "csharp",
      "size": 1972,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "5de062949cd3197e00bf3971292ea36c2014849de597b6cc077673c464a02286",
      "language": "csharp",
      "size": 1054,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n\n        public WebhookQueueService()\n        {\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            if (!_queue.Writer.TryWrite(item))\n            {\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            return await _queue.Reader.ReadAsync(cancellationToken);\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "697c1ae4bf53b4a2820ab575b4d032605b78185f79e4578ac20d6770e5e819ff",
      "language": "csharp",
      "size": 13792,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Directory;            // ‚úÖ provider directory\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Central dispatcher for WhatsApp webhook events.\n    /// Routes payloads to the appropriate processor based on payload type.\n    /// </summary>\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        private readonly IStatusWebhookProcessor _statusProcessor;           // legacy fallback (keep)\n        private readonly ITemplateWebhookProcessor _templateProcessor;       // template events path (unchanged)\n        private readonly IClickWebhookProcessor _clickProcessor;             // click/journey path (unchanged)\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;  // inbound chat path (unchanged)\n        private readonly IWhatsAppWebhookService _webhookService;            // ‚úÖ for new unified status updater call\n        private readonly IProviderDirectory _directory;                      // ‚úÖ resolve BusinessId from provider hints\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n        public WhatsAppWebhookDispatcher(\n            IStatusWebhookProcessor statusProcessor,\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor,\n            IWhatsAppWebhookService webhookService,     // ‚úÖ add\n            IProviderDirectory directory,\n             IPinnacleToMetaAdapter pinnacleToMetaAdapter\n        // ‚úÖ add\n        )\n        {\n            _statusProcessor = statusProcessor;\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n            _webhookService = webhookService;\n            _directory = directory;\n            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n        }\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n{Payload}\", payload.ToString());\n\n            try\n            {\n                // 0) Detect provider & normalize to a Meta-like envelope for downstream processors\n                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n\n                JsonElement envelope = provider == \"pinnacle\"\n                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n                    : payload;\n\n                if (!envelope.TryGetProperty(\"entry\", out var entries)) return;\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                        // 1) STATUS UPDATES\n                        if (IsStatusPayload(envelope)) // üîÅ use envelope, not raw payload\n                        {\n                            Guid? businessId = null;\n                            try\n                            {\n                                var hints = ExtractNumberHints(envelope, provider); // üîÅ from envelope\n                                businessId = await _directory.ResolveBusinessIdAsync(\n                                    provider: provider,\n                                    phoneNumberId: hints.PhoneNumberId,\n                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n                                    wabaId: hints.WabaId,\n                                    waId: hints.WaId\n                                );\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"ProviderDirectory lookup failed; will fallback to legacy status processor.\");\n                            }\n\n                            if (businessId is Guid bid && !string.IsNullOrWhiteSpace(provider))\n                            {\n                                _logger.LogInformation(\"üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\", provider, bid);\n                                await _webhookService.ProcessStatusUpdateAsync(bid, provider!, envelope); // üîÅ pass envelope\n                            }\n                            else\n                            {\n                                _logger.LogWarning(\"‚ö†Ô∏è Status routing fallback ‚Üí legacy processor (provider={Provider}, businessId={BusinessId})\", provider, businessId);\n                                await _statusProcessor.ProcessStatusUpdateAsync(envelope); // üîÅ pass envelope\n                            }\n                            continue;\n                        }\n\n                        // 2) TEMPLATE EVENTS (unchanged)\n                        if (value.TryGetProperty(\"event\", out var eventType)\n                            && eventType.GetString()?.StartsWith(\"template_\") == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope); // üîÅ pass envelope\n                            continue;\n                        }\n\n                        // 3) MESSAGES (clicks + inbound)\n                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è No 'messages' array present.\");\n                            continue;\n                        }\n\n                        foreach (var m in msgs.EnumerateArray())\n                        {\n                            if (!m.TryGetProperty(\"type\", out var typeProp))\n                            {\n                                _logger.LogDebug(\"‚ÑπÔ∏è Message without 'type' field.\");\n                                continue;\n                            }\n\n                            var type = typeProp.GetString();\n\n                            // (A) Legacy quick-reply button ‚Üí CLICK\n                            if (type == \"button\")\n                            {\n                                _logger.LogInformation(\"üëâ Routing to Click Processor (legacy 'button')\");\n                                await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                continue;\n                            }\n\n                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK\n                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n                            {\n                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n                                    interactiveType.GetString() == \"button_reply\")\n                                {\n                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/button_reply)\");\n                                    await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                    continue;\n                                }\n\n                                if (interactive.TryGetProperty(\"list_reply\", out _))\n                                {\n                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/list_reply)\");\n                                    await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                    continue;\n                                }\n                            }\n\n                            // (C) Inbound plain message types ‚Üí INBOUND\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n                                await _inboundMessageProcessor.ProcessChatAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                continue;\n                            }\n\n                            _logger.LogDebug(\"‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.\", type);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n        private static bool IsStatusPayload(JsonElement root)\n        {\n            // Try Meta shape first: entry[].changes[].value.statuses\n            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n                return true;\n\n            // Try common Pinnacle shapes: \"status\" or event containing \"status\"\n            if (root.TryGetProperty(\"status\", out _)) return true;\n            if (root.TryGetProperty(\"event\", out var ev) &&\n                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n                return true;\n\n            return false;\n        }\n\n        private static string? DetectProvider(JsonElement root)\n        {\n            // Heuristics by envelope\n            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n                return \"meta\";\n            if (root.TryGetProperty(\"entry\", out _))\n                return \"meta\";\n            if (root.TryGetProperty(\"event\", out _))\n                return \"pinnacle\";\n\n            return null;\n        }\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n        {\n            var hints = new NumberHints();\n\n            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase))\n            {\n                if (TryGetMetaValue(root, out var v))\n                {\n                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n                    {\n                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n                            hints.PhoneNumberId = pnid.GetString();\n\n                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n                    }\n\n                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n                    {\n                        var s0 = statuses[0];\n                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n                            hints.WaId = rid.GetString();\n                    }\n                }\n            }\n            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n            {\n                // Adjust to your Pinnacle adapter payload (post-adaptation).\n                // If you inject phone_number_id when adapting to Meta shape, this will pick it up:\n                if (root.TryGetProperty(\"phone_number_id\", out var pn))\n                    hints.PhoneNumberId = pn.GetString();\n\n                // Fallback to sender number fields:\n                if (root.TryGetProperty(\"from\", out var from))\n                    hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n                else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n                    hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n\n                if (root.TryGetProperty(\"wabaId\", out var waba))\n                    hints.WabaId = waba.GetString();\n            }\n\n            return hints;\n        }\n\n        private static string? NormalizePhone(string? v)\n        {\n            if (string.IsNullOrWhiteSpace(v)) return null;\n            var t = v.Trim();\n            var keepPlus = t.StartsWith(\"+\");\n            var digits = new string(t.Where(char.IsDigit).ToArray());\n            return keepPlus ? \"+\" + digits : digits;\n        }\n\n        private struct NumberHints\n        {\n            public string? PhoneNumberId { get; set; }\n            public string? DisplayPhoneNumber { get; set; }\n            public string? WabaId { get; set; }\n            public string? WaId { get; set; }\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "c3bf201e03458a246ea22f55cefa2c6bd2abc9659838214b01fe321dbb0f854b",
      "language": "csharp",
      "size": 14925,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nusing xbytechat.api;                                      // AppDbContext\nusing xbytechat.api.Features.CampaignTracking.Models;     // CampaignSendLog\nusing xbytechat.api.Features.Webhooks.Status;             // IMessageStatusUpdater, StatusEvent, MessageDeliveryState\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n        private readonly IMessageStatusUpdater _updater;\n\n        public WhatsAppWebhookService(\n            AppDbContext context,\n            ILogger<WhatsAppWebhookService> logger,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Legacy path: payload only (Meta-like).\n        /// We keep this for back-compat, but we *upgrade* behavior:\n        /// - For each status: find CampaignSendLog by MessageId\n        /// - If found ‚Üí get BusinessId and delegate to the unified updater\n        /// - If not found ‚Üí keep legacy log-only update (minimal)\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)\n        {\n            _logger.LogInformation(\"üì¶ Processing Webhook Status (legacy):\\n{Pretty}\",\n                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));\n\n            if (!payload.TryGetProperty(\"entry\", out var entries))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Payload missing 'entry' property.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value)) continue;\n                    if (!value.TryGetProperty(\"statuses\", out var statuses)) continue;\n\n                    foreach (var status in statuses.EnumerateArray())\n                    {\n                        string? messageId = status.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = status.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n\n                        // timestamp may be string or number\n                        long ts = 0;\n                        if (status.TryGetProperty(\"timestamp\", out var tsProp))\n                        {\n                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsedTs))\n                                ts = parsedTs;\n                            else if (tsProp.ValueKind == JsonValueKind.Number)\n                                ts = tsProp.GetInt64();\n                        }\n\n                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))\n                        {\n                            _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or status in webhook payload.\");\n                            continue;\n                        }\n\n                        // Try to locate CampaignSendLog (gives us BusinessId)\n                        var sendLog = await _context.Set<CampaignSendLog>()\n                            .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);\n\n                        if (sendLog != null)\n                        {\n                            var ev = new StatusEvent\n                            {\n                                BusinessId = sendLog.BusinessId,\n                                Provider = \"meta\", // legacy path is Meta-shaped; adjust if you also send Pinnacle here\n                                ProviderMessageId = messageId,\n                                State = MapMetaState(statusText),\n                                OccurredAt = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts) : DateTimeOffset.UtcNow\n                            };\n\n                            await _updater.UpdateAsync(ev, ct);\n                            _logger.LogInformation(\"‚úÖ Unified update applied for MessageId {MessageId} (state={State})\", messageId, statusText);\n                        }\n                        else\n                        {\n                            // Fallback: minimal legacy update to CampaignSendLogs (kept from your original code)\n                            var time = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts).UtcDateTime : (DateTime?)null;\n\n                            var log = await _context.Set<CampaignSendLog>()\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);\n\n                            if (log == null)\n                            {\n                                _logger.LogWarning(\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {MessageId}\", messageId);\n                                continue;\n                            }\n\n                            var newStatus = statusText switch\n                            {\n                                \"sent\" => \"Sent\",\n                                \"delivered\" => \"Delivered\",\n                                \"read\" => \"Read\",\n                                _ => null\n                            };\n\n                            bool isUpdated = false;\n\n                            if (!string.IsNullOrEmpty(newStatus) && !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n                            {\n                                log.SendStatus = newStatus;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"delivered\" && log.DeliveredAt == null && time.HasValue)\n                            {\n                                log.DeliveredAt = time.Value;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"read\" && log.ReadAt == null && time.HasValue)\n                            {\n                                log.ReadAt = time.Value;\n                                isUpdated = true;\n                            }\n\n                            if (isUpdated)\n                            {\n                                await _context.SaveChangesAsync(ct);\n                                _logger.LogInformation(\"‚úÖ Log updated for MessageId: {MessageId} ‚Üí {Status}\", messageId, newStatus);\n                            }\n                            else\n                            {\n                                _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId}\", statusText, messageId);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// New provider-aware overload called by the dispatcher after it resolves BusinessId + Provider.\n        /// Always uses the unified updater.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)\n        {\n            provider = (provider ?? \"\").Trim().ToLowerInvariant();\n\n            foreach (var ev in ParseStatusEvents(businessId, provider, payload))\n            {\n                await _updater.UpdateAsync(ev, ct);\n            }\n        }\n\n        // ---------------- Parsers (Meta + Pinnacle) ----------------\n\n        private static IEnumerable<StatusEvent> ParseStatusEvents(Guid businessId, string provider, JsonElement root)\n        {\n            if (provider == \"meta\" || provider == \"meta_cloud\" || provider == \"meta-cloud\")\n            {\n                if (TryGetMetaValue(root, out var v) &&\n                    v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                    statuses.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var s in statuses.EnumerateArray())\n                    {\n                        var stateStr = s.TryGetProperty(\"status\", out var st) ? st.GetString() : null;\n                        var state = MapMetaState(stateStr);\n\n                        var tsStr = s.TryGetProperty(\"timestamp\", out var tsv) ? tsv.ToString() : null;\n                        var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;\n\n                        var providerMsgId = s.TryGetProperty(\"id\", out var idv) ? idv.GetString() : null;\n                        var waId = s.TryGetProperty(\"recipient_id\", out var rid) ? rid.GetString() : null;\n\n                        string? errorCode = null, errorMsg = null;\n                        if (s.TryGetProperty(\"errors\", out var errs) && errs.ValueKind == JsonValueKind.Array && errs.GetArrayLength() > 0)\n                        {\n                            var e0 = errs[0];\n                            if (e0.TryGetProperty(\"code\", out var cv)) errorCode = cv.ToString();\n                            if (e0.TryGetProperty(\"message\", out var mv)) errorMsg = mv.GetString();\n                        }\n\n                        string? conversationId = null;\n                        if (s.TryGetProperty(\"conversation\", out var conv) && conv.TryGetProperty(\"id\", out var cid))\n                            conversationId = cid.GetString();\n\n                        yield return new StatusEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = \"meta\",\n                            ProviderMessageId = providerMsgId ?? string.Empty,\n                            RecipientWaId = waId,\n                            State = state,\n                            OccurredAt = occurredAt,\n                            ErrorCode = errorCode,\n                            ErrorMessage = errorMsg,\n                            ConversationId = conversationId\n                        };\n                    }\n                }\n                yield break;\n            }\n\n            if (provider == \"pinnacle\")\n            {\n                // Support both object and array shapes\n                if (root.ValueKind == JsonValueKind.Object)\n                {\n                    foreach (var ev in ParsePinnacleObject(businessId, root))\n                        yield return ev;\n                }\n                else if (root.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var item in root.EnumerateArray())\n                        foreach (var ev in ParsePinnacleObject(businessId, item))\n                            yield return ev;\n                }\n                yield break;\n            }\n        }\n\n        private static IEnumerable<StatusEvent> ParsePinnacleObject(Guid businessId, JsonElement obj)\n        {\n            var providerMsgId = obj.TryGetProperty(\"message_id\", out var mid) ? mid.GetString()\n                              : obj.TryGetProperty(\"id\", out var idv) ? idv.GetString()\n                              : null;\n\n            var waId = obj.TryGetProperty(\"to\", out var to) ? to.GetString()\n                     : obj.TryGetProperty(\"recipient_id\", out var rid) ? rid.GetString()\n                     : null;\n\n            var stateStr = obj.TryGetProperty(\"status\", out var st) ? st.GetString()\n                         : obj.TryGetProperty(\"event\", out var ev) ? ev.GetString()\n                         : null;\n\n            var state = MapPinnacleState(stateStr);\n\n            var tsStr = obj.TryGetProperty(\"timestamp\", out var tsv) ? tsv.ToString() : null;\n            var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;\n\n            string? errorCode = null, errorMsg = null;\n            if (obj.TryGetProperty(\"error\", out var err))\n            {\n                if (err.TryGetProperty(\"code\", out var cv)) errorCode = cv.ToString();\n                if (err.TryGetProperty(\"message\", out var mv)) errorMsg = mv.GetString();\n            }\n\n            yield return new StatusEvent\n            {\n                BusinessId = businessId,\n                Provider = \"pinnacle\",\n                ProviderMessageId = providerMsgId ?? string.Empty,\n                RecipientWaId = waId,\n                State = state,\n                OccurredAt = occurredAt,\n                ErrorCode = errorCode,\n                ErrorMessage = errorMsg\n            };\n        }\n\n        // ---------------- helpers ----------------\n\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static MessageDeliveryState MapMetaState(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => MessageDeliveryState.Sent,\n                \"delivered\" => MessageDeliveryState.Delivered,\n                \"read\" => MessageDeliveryState.Read,\n                \"failed\" => MessageDeliveryState.Failed,\n                \"deleted\" => MessageDeliveryState.Deleted,\n                _ => MessageDeliveryState.Sent\n            };\n\n        private static MessageDeliveryState MapPinnacleState(string? s)\n        {\n            var v = (s ?? \"\").ToLowerInvariant();\n            if (v.Contains(\"deliv\")) return MessageDeliveryState.Delivered;\n            if (v.Contains(\"read\")) return MessageDeliveryState.Read;\n            if (v.Contains(\"fail\") || v.Contains(\"error\")) return MessageDeliveryState.Failed;\n            if (v.Contains(\"sent\") || v.Contains(\"submit\")) return MessageDeliveryState.Sent;\n            if (v.Contains(\"delete\")) return MessageDeliveryState.Deleted;\n            return MessageDeliveryState.Sent;\n        }\n\n        private static DateTimeOffset? TryParseUnix(string? val)\n        {\n            if (string.IsNullOrWhiteSpace(val)) return null;\n            if (long.TryParse(val, out var s)) return DateTimeOffset.FromUnixTimeSeconds(s);\n            return null;\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/IMessageStatusUpdater.cs",
      "sha256": "0472e0663f9b5118e02ff84984c10aee28ce0c60a177e382d774e5fe88414dda",
      "language": "csharp",
      "size": 1518,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// Provider-agnostic updater for delivery/read/fail transitions.\n    /// Must be idempotent (safe under retries / duplicates).\n    /// </summary>\n    public interface IMessageStatusUpdater\n    {\n        Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);\n    }\n\n    /// <summary>\n    /// Normalized status event parsed from any provider payload.\n    /// </summary>\n    public sealed class StatusEvent\n    {\n        public Guid BusinessId { get; init; }\n        public string Provider { get; init; } = \"\";          // \"meta\" | \"pinnacle\"\n\n        // Provider message id (Meta \"id\", Pinnacle equivalent) ‚Üí maps to MessageId in your DB\n        public string ProviderMessageId { get; init; } = \"\";\n\n        // Optional hints (not required in your current lookups)\n        public Guid? CampaignSendLogId { get; init; }\n        public string? RecipientWaId { get; init; }\n\n        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted\n        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available\n\n        public string? ErrorCode { get; init; }\n        public string? ErrorMessage { get; init; }\n        public string? ConversationId { get; init; }\n    }\n\n    public enum MessageDeliveryState\n    {\n        Sent,\n        Delivered,\n        Read,\n        Failed,\n        Deleted\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusContracts.cs",
      "sha256": "37627bd0faaa1e9e438a5d7379dc5f5773a8f7553fe9e1b476e74ee20a66ce30",
      "language": "csharp",
      "size": 1443,
      "content": "namespace xbytechat.api.Features.Webhooks.Status\n{\n    public class MessageStatusContracts\n    {\n        public enum CanonicalMessageStatus\n        {\n            Unknown = 0,\n            Submitted,   // API accepted (optional)\n            Sent,        // provider accepted / sent\n            Delivered,\n            Read,\n            Failed\n        }\n        public sealed class UpdateMessageStatusRequest\n        {\n            public Guid BusinessId { get; set; }\n            public string Provider { get; set; } = \"\";              // \"meta_cloud\" | \"pinnacle\" | etc.\n            public string MessageId { get; set; } = \"\";             // provider message id (WAMID / id)\n            public string RawStatus { get; set; } = \"\";             // provider-specific (e.g., \"sent\", \"delivered\")\n            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any\n\n            public string? RecipientNumber { get; set; }            // optional sanity context\n            public string? ErrorCode { get; set; }                  // optional error info\n            public string? ErrorMessage { get; set; }               // optional error info\n            public string? RawPayloadJson { get; set; }             // optional audit/debug\n        }\n\n        public interface IMessageStatusUpdater\n        {\n            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusUpdater.cs",
      "sha256": "f4e65db34d4ce0053ffc8fc3fe0dd120089f3ee5ab8c44ebeb4e57e94e8befb8",
      "language": "csharp",
      "size": 8340,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\n// üëá make sure this is where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\nusing xbytechat.api.CRM.Models;                       // Contact (nav)\nusing xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n    /// </summary>\n    public class MessageStatusUpdater : IMessageStatusUpdater\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<MessageStatusUpdater> _log;\n\n        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n        {\n            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n            {\n                _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n                return;\n            }\n\n            // 1) Pull candidates (scoped to business + WAMID)\n            var sendLogQ = _db.Set<CampaignSendLog>()\n                              .AsTracking()\n                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n            var msgLogQ = _db.Set<MessageLog>()\n                             .AsTracking()\n                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);\n\n            // If caller passed a specific CampaignSendLogId, narrow further\n            if (ev.CampaignSendLogId is Guid sid)\n                sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n            // 2) Apply transition (idempotent)\n            var changed = ApplyTransition(sendLog, msgLog, ev);\n\n            // 3) Persist only if something actually changed\n            if (changed > 0)\n                await _db.SaveChangesAsync(ct);\n        }\n\n        /// <summary>Returns number of entities modified.</summary>\n        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n        {\n            int modified = 0;\n\n            // --- CampaignSendLog updates ---\n            if (sendLog != null)\n            {\n                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    sendLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n                        {\n                            sendLog.SendStatus = \"Sent\";\n                            modified++;\n                        }\n                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n                        {\n                            sendLog.SendStatus = \"Delivered\";\n                            modified++;\n                        }\n                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n                        {\n                            sendLog.SendStatus = \"Read\";\n                            modified++;\n                        }\n                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n                        {\n                            sendLog.SendStatus = \"Failed\";\n                            modified++;\n                        }\n                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            sendLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n                        {\n                            sendLog.SendStatus = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            // --- MessageLog updates ---\n            if (msgLog != null)\n            {\n                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    msgLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n                        {\n                            msgLog.Status = \"Sent\";\n                            modified++;\n                        }\n                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n                        {\n                            msgLog.Status = \"Delivered\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n                        {\n                            msgLog.Status = \"Read\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n                        {\n                            msgLog.Status = \"Failed\";\n                            modified++;\n                        }\n                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            msgLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n                        {\n                            msgLog.Status = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            if (sendLog == null && msgLog == null)\n            {\n                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n            }\n\n            return modified;\n        }\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/Controllers/WhatsAppTemplateController.cs",
      "sha256": "7cee6e94d95a99b2c7b15eb9567b21bea75fb9efd058d6c2a00fba7585616dc8",
      "language": "csharp",
      "size": 2867,
      "content": "\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing System.Net.Http.Headers;\nusing Newtonsoft.Json.Linq;\n\nnamespace xbytechat.api.Features.WhatsAppIntegration.Controllers\n{\n    [ApiController]\n    [Route(\"api/whatsapp\")]\n    public class WhatsAppTemplateController : ControllerBase\n    {\n        private readonly IConfiguration _config;\n\n        public WhatsAppTemplateController(IConfiguration config)\n        {\n            _config = config;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetTemplates()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var apiToken = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v22.0/{wabaId}/message_templates\";\n\n            using var client = new HttpClient();\n            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", apiToken);\n\n            try\n            {\n                var response = await client.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                    return StatusCode((int)response.StatusCode, new { success = false, error = json });\n\n                var root = JsonConvert.DeserializeObject<JObject>(json);\n                var templatesRaw = root[\"data\"] as JArray;\n\n                if (templatesRaw == null)\n                    return BadRequest(new { success = false, error = \"Meta API did not return data array.\" });\n\n                var templates = new List<object>();\n\n                foreach (var tpl in templatesRaw)\n                {\n                    string name = tpl[\"name\"]?.ToString() ?? \"\";\n                    string language = tpl[\"language\"]?.ToString() ?? \"en_US\";\n\n                    string bodyText = \"\";\n                    var components = tpl[\"components\"] as JArray;\n\n                    if (components != null)\n                    {\n                        foreach (var comp in components)\n                        {\n                            if (comp[\"type\"]?.ToString() == \"BODY\")\n                            {\n                                bodyText = comp[\"text\"]?.ToString() ?? \"\";\n                                break;\n                            }\n                        }\n                    }\n\n                    templates.Add(new\n                    {\n                        name,\n                        language,\n                        body = bodyText\n                    });\n                }\n\n                return Ok(new { success = true, templates });\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, new { success = false, error = ex.Message });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/DTOs/WhatsAppTemplateDto.cs",
      "sha256": "66133a62d929f35f6f56d4d6c3c9a872e14788627c9645fa41aa6eee13290993",
      "language": "csharp",
      "size": 111,
      "content": "namespace xbytechat.api.Features.WhatsAppIntegration.DTOs\n{\n    public class WhatsAppTemplateDto\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Controllers/LeadTimelineController.cs",
      "sha256": "2bf2b77897c9f322069f976352984cc8a0a0d25514e1e411e2e2393e3ccba3f0",
      "language": "csharp",
      "size": 2028,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.xbTimeline.Services;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"‚úÖ Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"üìÑ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // ‚úÖ Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // ‚úÖ Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "e6ce11c00e1130226359d24f7c9da23fe4fc68c6e725c5a449ed10a345378269",
      "language": "csharp",
      "size": 693,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // üß© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // üÜî Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // üìÇ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // ‚è∞ Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/LeadTimelineDto.cs",
      "sha256": "b4692f6cebba16abcb7dc7450172517334a4832fce8e02d3c4273da2d001f2c8",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } \n        public string ContactNumber { get; set; } \n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "de301765ab3465a422c99453aab98cf7b40ec5177358642af08c2d5ec36ead4a",
      "language": "csharp",
      "size": 1837,
      "content": "using xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // ‚úÖ Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // ‚úÖ Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // ‚úÖ CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // ‚úÖ Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Models/LeadTimeline.cs",
      "sha256": "deaadfd25e7f565dc0456a66a61612baa9aea7a7dc297feca882d2108906413f",
      "language": "csharp",
      "size": 1195,
      "content": "using xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // üÜï Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // ‚úÖ New\n        public bool IsSystemGenerated { get; set; } = false;  // ‚úÖ New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ILeadTimelineService.cs",
      "sha256": "4bff375276ef500fcbd0288211c9a8438d983b063537b2995a6fc98a8eba1148",
      "language": "csharp",
      "size": 709,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ITimelineService.cs",
      "sha256": "3e8a236b7ce0a2af07bc27014910b7fbd77a83c78e8ceebe38c99bab96d183e4",
      "language": "csharp",
      "size": 448,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public interface ITimelineService\n    {\n        // Already existing methods...\n\n        // üÜï CRM related methods\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/LeadTimelineService.cs",
      "sha256": "cf0715e549aeb3e6288ceb6cb82177dea0441d9953e64e6aca44f13ed2a19083",
      "language": "csharp",
      "size": 7579,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\n\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n       \n\n        public LeadTimelineService(AppDbContext context )\n        {\n            _context = context;\n        \n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"üìÑ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"üìÑ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üìà Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // ‚úÖ Timeline me readable text\n                    ReferenceId = dto.CampaignId, // ‚úÖ Linking to campaign record\n                    IsSystemGenerated = false,    // ‚úÖ Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // ‚úÖ Or actual user email if needed later\n                    Source = \"CampaignModule\",    // ‚úÖ Source field for clarity\n                    Category = \"Messaging\",       // ‚úÖ Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // ‚úÖ Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/TimelineService.cs",
      "sha256": "34982b110dddb7a0afcac7582aa0c8dfc2d85810317956df389aaf17bd1a0a1f",
      "language": "csharp",
      "size": 3341,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // üß© Log Note Added into Timeline\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"NoteAdded\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // ‚è∞ Log Reminder Set into Timeline\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"ReminderSet\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // üè∑Ô∏è Log Tag Applied into Timeline\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagApplied\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Flows/FlowClickTokenOptions.cs",
      "sha256": "77072ad81d2853a2fd79e3d9e38138f6adfdf21eea5558d5771531d9dde4eb9d",
      "language": "csharp",
      "size": 421,
      "content": "// üìÑ Infrastructure/Flows/FlowClickTokenOptions.cs\nnamespace xbytechat.api.Infrastructure.Flows\n{\n    public class FlowClickTokenOptions\n    {\n        public string Secret { get; set; } = \"\";   // long random string (256-bit recommended)\n        public string BaseUrl { get; set; } = \"\";  // e.g. https://app.yourdomain.com\n        public int TtlHours { get; set; } = 72;    // token lifetime (default 3 days)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Flows/FlowClickTokenService.cs",
      "sha256": "a259df299ffe015927cc0dfc8bf0818b0e45222cd93cfb2dfb5879f2658e0dfb",
      "language": "csharp",
      "size": 3570,
      "content": "// üìÑ Infrastructure/Flows/FlowClickTokenService.cs\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\nusing System.Text;\nusing Microsoft.Extensions.Options;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace xbytechat.api.Infrastructure.Flows\n{\n    public record FlowClickPayload(\n        Guid biz, Guid fid, int ver, Guid sid, short bi,\n        Guid mlid, string cp, long iat, long exp\n    );\n\n    public interface IFlowClickTokenService\n    {\n        string Create(FlowClickPayload p);\n        FlowClickPayload Validate(string token);\n        string BuildUrl(FlowClickPayload p);\n    }\n\n    public class FlowClickTokenService : IFlowClickTokenService\n    {\n        private readonly FlowClickTokenOptions _opt;\n        private readonly JwtSecurityTokenHandler _handler = new();\n\n        public FlowClickTokenService(IOptions<FlowClickTokenOptions> opt)\n        {\n            _opt = opt.Value;\n        }\n\n        public string Create(FlowClickPayload p)\n        {\n            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_opt.Secret));\n            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n            var claims = new[]\n            {\n                new Claim(\"biz\", p.biz.ToString()),\n                new Claim(\"fid\", p.fid.ToString()),\n                new Claim(\"ver\", p.ver.ToString()),\n                new Claim(\"sid\", p.sid.ToString()),\n                new Claim(\"bi\",  p.bi.ToString()),\n                new Claim(\"mlid\",p.mlid.ToString()),\n                new Claim(\"cp\",  p.cp),\n                new Claim(\"iat\", p.iat.ToString()),\n                new Claim(\"exp\", p.exp.ToString())\n            };\n\n            var token = new JwtSecurityToken(claims: claims, signingCredentials: creds);\n            return _handler.WriteToken(token);\n        }\n\n        public FlowClickPayload Validate(string token)\n        {\n            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_opt.Secret));\n\n            var parameters = new TokenValidationParameters\n            {\n                ValidateIssuer = false,\n                ValidateAudience = false,\n                ValidateLifetime = false, // we‚Äôll check manually\n                ValidateIssuerSigningKey = true,\n                IssuerSigningKey = key\n            };\n\n            _handler.ValidateToken(token, parameters, out var validated);\n            var jwt = (JwtSecurityToken)validated;\n\n            long iat = long.Parse(jwt.Claims.First(c => c.Type == \"iat\").Value);\n            long exp = long.Parse(jwt.Claims.First(c => c.Type == \"exp\").Value);\n            var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n            if (now > exp) throw new SecurityTokenExpiredException(\"Token expired\");\n\n            return new FlowClickPayload(\n                biz: Guid.Parse(jwt.Claims.First(c => c.Type == \"biz\").Value),\n                fid: Guid.Parse(jwt.Claims.First(c => c.Type == \"fid\").Value),\n                ver: int.Parse(jwt.Claims.First(c => c.Type == \"ver\").Value),\n                sid: Guid.Parse(jwt.Claims.First(c => c.Type == \"sid\").Value),\n                bi: short.Parse(jwt.Claims.First(c => c.Type == \"bi\").Value),\n                mlid: Guid.Parse(jwt.Claims.First(c => c.Type == \"mlid\").Value),\n                cp: jwt.Claims.First(c => c.Type == \"cp\").Value,\n                iat: iat,\n                exp: exp\n            );\n        }\n\n        public string BuildUrl(FlowClickPayload p)\n        {\n            var token = Create(p);\n            return $\"{_opt.BaseUrl.TrimEnd('/')}/r/flow/{token}\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Middlewares/GlobalExceptionMiddleware.cs",
      "sha256": "81f92c798910995fdc5e81622269bc30f14971bf74da00e5b27af3bfe4a04a79",
      "language": "csharp",
      "size": 3497,
      "content": "using System.Net;\nusing Serilog;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.AspNetCore.Hosting;\n\npublic class GlobalExceptionMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger<GlobalExceptionMiddleware> _logger;\n    private readonly IWebHostEnvironment _env;\n\n    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger, IWebHostEnvironment env)\n    {\n        _next = next;\n        _logger = logger;\n        _env = env;\n    }\n    public class ErrorResponse\n    {\n        public int StatusCode { get; set; }\n        public string Message { get; set; }\n        public string? StackTrace { get; set; }\n        public string Path { get; set; }\n    }\n\n    public async Task Invoke(HttpContext context)\n    {\n        try\n        {\n            await _next(context);\n        }\n        catch (Exception ex)\n        {\n            Log.Error(ex, \"‚ùå An unhandled exception occurred\");\n\n            // üö© Prevent double-write/headers-already-sent error!\n            if (context.Response.HasStarted)\n            {\n                _logger.LogError(\"Response has already started, unable to write error response for path: {Path}\", context.Request.Path);\n                return;\n            }\n\n            context.Response.ContentType = \"application/json\";\n            context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;\n\n            var response = new ErrorResponse\n            {\n                StatusCode = context.Response.StatusCode,\n                Message = ex.Message,\n                StackTrace = _env.IsDevelopment() ? ex.StackTrace : null,\n                Path = context.Request.Path\n            };\n            await context.Response.WriteAsJsonAsync(response);\n        }\n    }\n}\n\n\n//using System.Net;\n//using Serilog;\n//using System.Net;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Http;\n//using Microsoft.Extensions.Logging;\n//using Microsoft.AspNetCore.Hosting;\n\n//public class GlobalExceptionMiddleware\n//{\n//    private readonly RequestDelegate _next;\n//    private readonly ILogger<GlobalExceptionMiddleware> _logger;\n//    private readonly IWebHostEnvironment _env;\n\n//    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger, IWebHostEnvironment env)\n//    {\n//        _next = next;\n//        _logger = logger;\n//        _env = env;\n//    }\n//    public class ErrorResponse\n//    {\n//        public int StatusCode { get; set; }\n//        public string Message { get; set; }\n//        public string? StackTrace { get; set; }\n//        public string Path { get; set; }\n//    }\n\n//    public async Task Invoke(HttpContext context)\n//    {\n//        try\n//        {\n//            await _next(context);\n//        }\n//        catch (Exception ex)\n//        {\n//            Log.Error(ex, \"‚ùå An unhandled exception occurred\");\n\n//            context.Response.ContentType = \"application/json\";\n//            context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;\n\n//            var response = new ErrorResponse\n//            {\n//                StatusCode = context.Response.StatusCode,\n//                Message = ex.Message,\n//                StackTrace = _env.IsDevelopment() ? ex.StackTrace : null,\n//                Path = context.Request.Path\n//            };\n//            await context.Response.WriteAsJsonAsync(response);\n//        }\n//    }\n\n//}\n"
    },
    {
      "path": "xbytechat-api/Middlewares/JwtErrorHandlingMiddleware.cs",
      "sha256": "d35104606ec5c8b08c106f2499d4962349d1c9c99465f0772fe1a92366cdcfac",
      "language": "csharp",
      "size": 2000,
      "content": "using Microsoft.AspNetCore.Http;\nusing System.Net;\nusing System.Text.Json;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace xbytechat.api.Middlewares\n{\n    public class JwtErrorHandlingMiddleware\n    {\n        private readonly RequestDelegate _next;\n\n        public JwtErrorHandlingMiddleware(RequestDelegate next)\n        {\n            _next = next;\n        }\n\n        public async Task Invoke(HttpContext context)\n        {\n            try\n            {\n                await _next(context); // Proceed to next middleware\n            }\n            catch (SecurityTokenExpiredException)\n            {\n                context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n                context.Response.ContentType = \"application/json\";\n\n                var response = new\n                {\n                    success = false,\n                    message = \"‚ùå Token expired. Please login again.\"\n                };\n\n                await context.Response.WriteAsync(JsonSerializer.Serialize(response));\n            }\n            catch (SecurityTokenException ex)\n            {\n                context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n                context.Response.ContentType = \"application/json\";\n\n                var response = new\n                {\n                    success = false,\n                    message = $\"‚ùå Token invalid: {ex.Message}\"\n                };\n\n                await context.Response.WriteAsync(JsonSerializer.Serialize(response));\n            }\n            catch (Exception)\n            {\n                // Pass unhandled exceptions to global exception middleware\n                throw;\n            }\n        }\n    }\n\n    // Extension method for clean registration\n    public static class JwtErrorHandlingMiddlewareExtensions\n    {\n        public static IApplicationBuilder UseJwtErrorHandling(this IApplicationBuilder builder)\n        {\n            return builder.UseMiddleware<JwtErrorHandlingMiddleware>();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Middlewares/RequirePermissionAttribute.cs",
      "sha256": "a6d3aaceba78295b73d29b3f7b0c72837f08e7f8cb0004a15f1f77f1066dc3c2",
      "language": "csharp",
      "size": 1156,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing System;\nusing System.Linq;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.Middleware.Attributes\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]\n    public class RequirePermissionAttribute : Attribute, IAuthorizationFilter\n    {\n        private readonly string _requiredPermission;\n\n        public RequirePermissionAttribute(string requiredPermission)\n        {\n            _requiredPermission = requiredPermission;\n        }\n\n        public void OnAuthorization(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n\n            if (!user.Identity.IsAuthenticated)\n            {\n                context.Result = new UnauthorizedResult();\n                return;\n            }\n\n            var permissionsClaim = user.Claims.FirstOrDefault(c => c.Type == \"permissions\")?.Value;\n\n            if (permissionsClaim == null || !permissionsClaim.Split(',').Contains(_requiredPermission))\n            {\n                context.Result = new ForbidResult();\n            }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Middlewares/RequirePlanAttribute.cs",
      "sha256": "3e7d8fc23618708b9d4ae5351012eb53f013b2ab0f579426c3d4c9091ed06251",
      "language": "csharp",
      "size": 887,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing System;\nusing System.Linq;\n\nnamespace xbytechat.api.Middlewares\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]\n    public class RequirePlanAttribute : Attribute, IAuthorizationFilter\n    {\n        private readonly string[] _allowedPlans;\n\n        public RequirePlanAttribute(params string[] allowedPlans)\n        {\n            _allowedPlans = allowedPlans;\n        }\n\n        public void OnAuthorization(AuthorizationFilterContext context)\n        {\n            var plan = context.HttpContext.User.FindFirst(\"plan\")?.Value?.ToLowerInvariant();\n            if (string.IsNullOrEmpty(plan) || !_allowedPlans.Any(p => p.ToLowerInvariant() == plan))\n            {\n                context.Result = new ForbidResult(); // 403 Forbidden\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Middlewares/RequireRoleAttribute.cs",
      "sha256": "b8ca70695e176a36191713cb6b179e1f5097d9077227a77b8658f86392b98b6b",
      "language": "csharp",
      "size": 852,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing System;\nusing System.Linq;\n\nnamespace xbytechat.api.Middlewares\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]\n    public class RequireRoleAttribute : Attribute, IAuthorizationFilter\n    {\n        private readonly string[] _roles;\n\n        public RequireRoleAttribute(params string[] roles)\n        {\n            _roles = roles;\n        }\n\n        public void OnAuthorization(AuthorizationFilterContext context)\n        {\n            var role = context.HttpContext.User.FindFirst(\"role\")?.Value?.ToLowerInvariant();\n            if (string.IsNullOrEmpty(role) || !_roles.Any(r => r.ToLowerInvariant() == role))\n            {\n                context.Result = new ForbidResult(); // 403 Forbidden\n            }\n        }\n    }\n}\n"
    }
  ]
}
