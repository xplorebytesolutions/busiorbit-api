{
  "name": "xbytechat-api/Features/Webhooks",
  "generatedAt": "2025-08-11 18:04:10 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "4a0dbbf63a7e5e5dbdea08790538d449d81f91e4234da7a4b8acedf0ff744b25",
      "language": "csharp",
      "size": 3019,
      "content": "using System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services;\nusing xbytechat.api.Features.Webhooks.DTOs;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var clonedPayload = payload.Clone(); // ‚úÖ Avoid disposal issue\n\n                using var scope = _scopeFactory.CreateScope();\n\n                // üîÑ Resolve scoped dependencies\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                // üöÄ Dispatch\n                await dispatcher.DispatchAsync(clonedPayload);\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error while processing webhook payload.\");\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                       // RawJson = ex.Data[\"payload\"]?.ToString() ?? \"(unavailable)\",\n                        RawJson = ex.Data[\"payload\"]?.ToString() ?? \"{}\",\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    await failureLogger.LogFailureAsync(fallback);\n                }\n                catch (Exception innerEx)\n                {\n                    _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to log to FailedWebhookLogs table.\");\n                }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "d25c1bf6870c1712f3270bf8e478e741c09e7d32497bb0f3e64885e8e5c6c7ec",
      "language": "csharp",
      "size": 2801,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n            public WhatsAppWebhookController(ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config, AppDbContext context, IWhatsAppWebhookService webhookService, IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            // üîê Load your secret token from config or environment\n            var expectedToken = _config[\"WhatsApp:MetaToken\"];\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\"‚ùå WhatsApp webhook verification failed.\");\n            return Forbid(\"Token mismatch.\");\n        }\n\n     \n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            _logger.LogWarning(\"üì• Webhook received at controller:\\n\" + payload.ToString());\n\n            try\n            {\n                var cloned = payload.Clone(); // Important to clone here\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "68f4211391a24a94d3096c5cd71fbd6cbd0fed0211dd2929b92b1780ffd02fc8",
      "language": "csharp",
      "size": 2109,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceProvider _services;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(ILogger<FailedWebhookLogCleanupService> logger, IServiceProvider services)\n        {\n            _logger = logger;\n            _services = services;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _services.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Any())\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\"üßπ Deleted {Count} old failed webhook logs.\", oldLogs.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                await Task.Delay(_interval, stoppingToken); // wait before next cleanup\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "79f51c796e3319918315cd6043f985b763534fbb19a8357713d2c01aaf385112",
      "language": "csharp",
      "size": 227,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService .cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "0887fd0dd55ee4fa7ceaae2f534d1b7b0fbdb99dd3814e8a861f68c1b9145c3b",
      "language": "csharp",
      "size": 17249,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService)\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n        }\n\n\n        //public async Task ProcessClickAsync(JsonElement value)\n        //{\n        //    _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n        //    try\n        //    {\n        //        _logger.LogWarning(\"üì• [DEBUG] Click processor entered with value: \" + value.ToString());\n\n        //        if (!value.TryGetProperty(\"messages\", out var messages)) return;\n        //        var message = messages[0];\n\n        //        if (message.GetProperty(\"type\").GetString() != \"button\") return;\n\n        //        var clickMessageId = message.GetProperty(\"id\").GetString();\n        //        var originalMessageId = message.GetProperty(\"context\").GetProperty(\"id\").GetString();\n        //        var from = message.GetProperty(\"from\").GetString();\n        //        var buttonText = message.GetProperty(\"button\").GetProperty(\"text\").GetString()?.Trim().ToLower();\n\n        //        _logger.LogInformation(\"üñ±Ô∏è Button Click ‚ê¶ From: {From}, ClickMsgId: {ClickId}, OriginalMsgId: {OrigId}, Text: {Text}\",\n        //            from, clickMessageId, originalMessageId, buttonText);\n\n        //        Guid businessId = Guid.Empty;\n        //        Guid? contactId = null;\n        //        string contactPhone = from;\n        //        Guid? campaignId = null;\n        //        Guid? sendLogId = null;\n        //        string sourceType = \"catalog\";\n        //        Guid? sourceId = null;\n\n        //        // 1Ô∏è‚É£ Try CampaignSendLog\n        //        var campaignLog = await _context.CampaignSendLogs\n        //            .Include(l => l.Campaign)\n        //            .Include(l => l.Contact)\n        //            .FirstOrDefaultAsync(l => l.MessageId == originalMessageId);\n\n        //        if (campaignLog != null)\n        //        {\n        //            _logger.LogInformation(\"üìä CampaignSendLog matched via context.id\");\n\n        //            businessId = campaignLog.Campaign?.BusinessId ?? Guid.Empty;\n        //            contactId = campaignLog.ContactId;\n        //            contactPhone = campaignLog.Contact?.PhoneNumber ?? from;\n        //            campaignId = campaignLog.CampaignId;\n        //            sendLogId = campaignLog.Id;\n        //            sourceType = \"campaign\";\n        //            sourceId = campaignLog.CampaignId;\n\n        //            // üîÅ Auto Follow-Up\n        //            if (buttonText == \"interested\" &&\n        //                !string.IsNullOrWhiteSpace(campaignLog.Campaign?.FollowUpTemplateId))\n        //            {\n        //                var followUpDto = new SimpleTemplateMessageDto\n        //                {\n        //                    BusinessId = businessId,\n        //                    RecipientNumber = contactPhone,\n        //                    TemplateName = campaignLog.Campaign.FollowUpTemplateId,\n        //                    TemplateParameters = new() // Phase 1 ‚Üí no variables\n        //                };\n\n        //                var result = await _messageEngine.SendTemplateMessageSimpleAsync(followUpDto);\n        //                _logger.LogInformation(result.Success\n        //                    ? \"‚úÖ Follow-up message sent successfully.\"\n        //                    : $\"‚ùå Follow-up failed: {result.Message}\");\n        //            }\n        //        }\n        //        else\n        //        {\n        //            _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found. Trying fallback to MessageLogs.\");\n\n        //            var log = await _context.MessageLogs\n        //                .FirstOrDefaultAsync(m =>\n        //                    m.MessageId == originalMessageId ||\n        //                    m.Id.ToString() == originalMessageId ||\n        //                    m.RawResponse.Contains(originalMessageId));\n\n        //            if (log != null)\n        //            {\n        //                businessId = log.BusinessId;\n        //                contactId = log.ContactId;\n        //                contactPhone = log.RecipientNumber ?? from;\n        //                sourceType = \"flow\";\n        //                _logger.LogInformation(\"‚úÖ Fallback matched MessageLog. BusinessId: {BusinessId}\", businessId);\n        //            }\n        //            else\n        //            {\n        //                _logger.LogWarning(\"‚ùå Fallback to MessageLogs failed. No message found for: {OriginalId}\", originalMessageId);\n        //            }\n        //        }\n\n        //        if (businessId == Guid.Empty)\n        //        {\n        //            _logger.LogWarning(\"‚ùå TrackingLog failed: No BusinessId available for click.\");\n        //            return;\n        //        }\n\n        //        // 2Ô∏è‚É£ Save Tracking\n        //        var dto = new TrackingLogDto\n        //        {\n        //            BusinessId = businessId,\n        //            CampaignId = campaignId,\n        //            CampaignSendLogId = sendLogId,\n        //            ContactId = contactId,\n        //            ContactPhone = contactPhone,\n        //            MessageId = originalMessageId,\n        //            MessageLogId = null,\n        //            SourceType = sourceType,\n        //            SourceId = sourceId,\n        //            ButtonText = buttonText,\n        //            CTAType = buttonText,\n        //            ClickedVia = \"webhook\",\n        //            ClickedAt = DateTime.UtcNow,\n        //            Browser = \"WhatsApp\",\n        //            IPAddress = \"webhook\",\n        //            DeviceType = DeviceHelper.GetDeviceType(\"WhatsApp\"),\n        //            Country = await GeoHelper.GetCountryFromIP(\"webhook\"),\n        //            RawJson = value.ToString()\n        //        };\n\n        //        var resultLog = await _trackingService.LogCTAClickWithEnrichmentAsync(dto);\n        //        _logger.LogInformation(\"üì• Tracking Result: {Result}\", resultLog?.Message ?? \"N/A\");\n\n        //        // 3Ô∏è‚É£ Match Flow ‚Üí Trigger Next Step (if any)\n        //        try\n        //        {\n        //            if (!string.IsNullOrWhiteSpace(dto.ButtonText))\n        //            {\n        //                var matchedStep = await _flowService.MatchStepByButtonAsync(\n        //                    businessId,\n        //                    dto.ButtonText.Trim().ToLower(),\n        //                    \"quick_reply\",\n        //                    campaignLog?.Campaign?.MessageTemplate ?? \"\",  // currentTemplateName\n        //                    campaignId\n        //                );\n\n        //                if (matchedStep != null)\n        //                {\n        //                    ResponseResult sendResult;\n\n        //                    switch (matchedStep.TemplateType?.ToLower())\n        //                    {\n        //                        case \"image_template\":\n        //                            var imageDto = new ImageTemplateMessageDto\n        //                            {\n        //                                BusinessId = businessId,\n        //                                RecipientNumber = contactPhone,\n        //                                TemplateName = matchedStep.TemplateToSend,\n        //                                LanguageCode = \"en_US\"\n        //                            };\n        //                            sendResult = await _messageEngine.SendImageTemplateMessageAsync(imageDto);\n        //                            break;\n\n        //                        case \"text_template\":\n        //                            var textDto = new SimpleTemplateMessageDto\n        //                            {\n        //                                BusinessId = businessId,\n        //                                RecipientNumber = contactPhone,\n        //                                TemplateName = matchedStep.TemplateToSend,\n        //                                TemplateParameters = new() // Phase 1 = No placeholders\n        //                            };\n        //                            sendResult = await _messageEngine.SendTemplateMessageSimpleAsync(textDto);\n        //                            break;\n\n        //                        default:\n        //                            _logger.LogWarning(\"‚ùå Unsupported template type in flow step: {Type}\", matchedStep.TemplateType);\n        //                            return;\n        //                    }\n\n        //                    if (sendResult.Success)\n        //                    {\n        //                        _logger.LogInformation(\"‚ö° CTA Flow matched! Sent template: {Template}\", matchedStep.TemplateToSend);\n        //                    }\n        //                    else\n        //                    {\n        //                        _logger.LogWarning(\"‚ùå Failed to send matched CTA template: {Message}\", sendResult.Message);\n        //                    }\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogInformation(\"üü° No CTA Flow matched for button: {Text}\", dto.ButtonText);\n        //                }\n        //            }\n        //        }\n        //        catch (Exception flowEx)\n        //        {\n        //            _logger.LogError(flowEx, \"‚ùå CTA Flow trigger failed.\");\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Failed to process button click.\");\n        //    }\n        //}\n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages)) return;\n                var message = messages[0];\n\n                if (message.GetProperty(\"type\").GetString() != \"button\") return;\n\n                var clickMessageId = message.GetProperty(\"id\").GetString();\n                var originalMessageId = message.GetProperty(\"context\").GetProperty(\"id\").GetString();\n                var from = message.GetProperty(\"from\").GetString();\n                var buttonText = message.GetProperty(\"button\").GetProperty(\"text\").GetString()?.Trim();\n\n                _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                    from, clickMessageId, originalMessageId, buttonText);\n\n                Guid businessId = Guid.Empty;\n                Guid? contactId = null;\n                string contactPhone = from;\n                Guid? campaignId = null;\n                Guid? sendLogId = null;\n                string sourceType = \"catalog\";\n                Guid? sourceId = null;\n\n                // 1Ô∏è‚É£ Try CampaignSendLog\n                var campaignLog = await _context.CampaignSendLogs\n                    .Include(l => l.Campaign)\n                    .Include(l => l.Contact)\n                    .FirstOrDefaultAsync(l => l.MessageId == originalMessageId);\n\n                if (campaignLog != null)\n                {\n                    _logger.LogInformation(\"üìä CampaignSendLog matched via context.id\");\n\n                    businessId = campaignLog.Campaign?.BusinessId ?? Guid.Empty;\n                    contactId = campaignLog.ContactId;\n                    contactPhone = campaignLog.Contact?.PhoneNumber ?? from;\n                    campaignId = campaignLog.CampaignId;\n                    sendLogId = campaignLog.Id;\n                    sourceType = \"campaign\";\n                    sourceId = campaignLog.CampaignId;\n                }\n                else\n                {\n                    var log = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId ||\n                            m.Id.ToString() == originalMessageId ||\n                            m.RawResponse.Contains(originalMessageId));\n\n                    if (log != null)\n                    {\n                        businessId = log.BusinessId;\n                        contactId = log.ContactId;\n                        contactPhone = log.RecipientNumber ?? from;\n                        sourceType = \"flow\";\n                        _logger.LogInformation(\"‚úÖ Fallback matched MessageLog. BusinessId: {BusinessId}\", businessId);\n                    }\n                }\n\n                if (businessId == Guid.Empty)\n                {\n                    _logger.LogWarning(\"‚ùå TrackingLog failed: No BusinessId available.\");\n                    return;\n                }\n\n                // 2Ô∏è‚É£ Save Click Log with enrichment\n                var dto = new TrackingLogDto\n                {\n                    BusinessId = businessId,\n                    CampaignId = campaignId,\n                    CampaignSendLogId = sendLogId,\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n                    MessageId = originalMessageId,\n                    MessageLogId = null,\n                    SourceType = sourceType,\n                    SourceId = sourceId,\n                    ButtonText = buttonText,\n                    CTAType = buttonText,\n                    ClickedVia = \"webhook\",\n                    ClickedAt = DateTime.UtcNow,\n                    Browser = \"WhatsApp\",\n                    IPAddress = \"webhook\",\n                    DeviceType = DeviceHelper.GetDeviceType(\"WhatsApp\"),\n                    Country = await GeoHelper.GetCountryFromIP(\"webhook\"),\n                    RawJson = value.ToString()\n                };\n\n                var resultLog = await _trackingService.LogCTAClickWithEnrichmentAsync(dto);\n                _logger.LogInformation(\"üì• Click Tracked ‚Üí Result: {Msg}\", resultLog?.Message ?? \"N/A\");\n\n                // ‚úÖ Extract TrackingLog.Id from result\n                if (resultLog?.Success != true || resultLog.Data is not Guid trackingLogId)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Skipping flow execution: Tracking ID not found.\");\n                    return;\n                }\n\n                // 3Ô∏è‚É£ Match Flow Step and trigger flow\n                if (!string.IsNullOrWhiteSpace(dto.ButtonText))\n                {\n                    var matchedStep = await _flowService.MatchStepByButtonAsync(\n                        businessId,\n                        dto.ButtonText.Trim(),\n                        \"quick_reply\",\n                        campaignLog?.Campaign?.MessageTemplate ?? \"\",\n                        campaignId\n                    );\n\n                    if (matchedStep != null)\n                    {\n                        _logger.LogInformation(\"üîÅ Matched CTA Step ‚Üí {StepId}\", matchedStep.Id);\n\n                        await _flowService.ExecuteVisualFlowAsync(\n                            businessId,\n                            matchedStep.Id,\n                            trackingLogId\n                        );\n\n                        _logger.LogInformation(\"‚ö° Visual flow triggered via CTA click.\");\n                    }\n                    else\n                    {\n                        _logger.LogInformation(\"üü° No visual flow matched for this button: {Text}\", dto.ButtonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "4d185e53ba4a52cd2439e23dc136aab36f4f7469c5399dd644247fdfd5631ae9",
      "language": "csharp",
      "size": 6493,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\n\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory)\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n        }\n\n\n\n        \n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n                // ‚úÖ 1. Extract WhatsApp metadata and message\n                var msg = value.GetProperty(\"messages\")[0];\n                var contactPhone = msg.GetProperty(\"from\").GetString()!;\n                var content = msg.GetProperty(\"text\").GetProperty(\"body\").GetString();\n                var businessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString()!;\n\n                // ‚úÖ 2. Resolve business by WhatsApp number\n                var business = await db.Businesses\n                    .Include(b => b.WhatsAppSettings)\n                    .FirstOrDefaultAsync(b => b.WhatsAppSettings.WhatsAppBusinessNumber == businessNumber);\n\n                if (business == null)\n                {\n                    logger.LogWarning(\"‚ùå Business not found for WhatsApp number: {Number}\", businessNumber);\n                    return;\n                }\n\n                var businessId = business.Id;\n\n                // ‚úÖ 3. Find or create contact\n                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // ‚úÖ 4. Check chat mode (skip inbox sync if not agent)\n                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // ‚úÖ 5. Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                // ‚úÖ 6. Try to trigger automation by keyword\n                try\n                {\n                    var triggerKeyword = content.Trim().ToLower();\n                    var handled = await automationService.TryRunFlowByKeywordAsync(\n                        businessId,\n                        triggerKeyword,\n                        contact.PhoneNumber,\n                        sourceChannel: \"whatsapp\",\n                        industryTag: \"default\"\n                    );\n\n                    if (!handled)\n                    {\n                        logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n                }\n\n                // ‚úÖ 7. Only sync to inbox if chat mode is agent\n                if (isAgentMode)\n                {\n                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                    {\n                        BusinessId = businessId,\n                        ContactId = contact.Id,\n                        RecipientPhone = contact.PhoneNumber,\n                        MessageBody = messageLog.MessageContent,\n                        IsIncoming = true,\n                        Status = messageLog.Status,\n                        SentAt = messageLog.CreatedAt\n                    });\n\n                    logger.LogInformation(\"üì• Message synced to inbox for contact {Phone}\", contactPhone);\n                }\n                else\n                {\n                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "b1e65faf4d0e1fe42cb9f0ca594f5e67270ea101fb1aabf768ab89da63aba838",
      "language": "csharp",
      "size": 239,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "2ed51eba7ff737266deb3c2aa5a4276c3e6afed2ee2da7472bd02e8e695ed4b9",
      "language": "csharp",
      "size": 4153,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver; // ‚úÖ Injected resolver\n\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver) // ‚úÖ Accept resolver in constructor\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n        }\n\n        // üîÑ Extract statuses from the payload and route them to log resolver\n        public async Task ProcessAsync(JsonElement value)\n        {\n            if (!value.TryGetProperty(\"statuses\", out var statuses))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è 'statuses' field missing in webhook payload.\");\n                return;\n            }\n\n            foreach (var status in statuses.EnumerateArray())\n            {\n                var messageId = status.GetProperty(\"id\").GetString();\n                var statusText = status.GetProperty(\"status\").GetString();\n                //var timestamp = status.TryGetProperty(\"timestamp\", out var ts) ? ts.GetInt64() : 0;\n                //var timestamp = status.TryGetProperty(\"timestamp\", out var ts) ? ts.GetInt64() : 0;\n\n                long timestamp = 0;\n\n                if (status.TryGetProperty(\"timestamp\", out var ts))\n                {\n                    if (ts.ValueKind == JsonValueKind.String && long.TryParse(ts.GetString(), out var parsed))\n                    {\n                        timestamp = parsed;\n                    }\n                    else if (ts.ValueKind == JsonValueKind.Number)\n                    {\n                        timestamp = ts.GetInt64();\n                    }\n                }\n\n                var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;\n                _logger.LogDebug(\"üïì Parsed timestamp: {0} from raw type: {1}\", timestamp, ts.ValueKind);\n                // ‚úÖ Resolve the correct CampaignSendLog ID using the new resolver\n                var logId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n\n                if (logId == null)\n                {\n                    _logger.LogWarning($\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}\");\n                    continue;\n                }\n\n                // üîç Now load the row by resolved ID\n                var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId.Value);\n                if (log != null)\n                {\n                    log.SendStatus = statusText switch\n                    {\n                        \"sent\" => \"Sent\",\n                        \"delivered\" => \"Delivered\",\n                        \"read\" => \"Read\",\n                        _ => log.SendStatus\n                    };\n\n                    if (statusText == \"delivered\") log.DeliveredAt = time;\n                    if (statusText == \"read\") log.ReadAt = time;\n\n                    await _context.SaveChangesAsync();\n                    _logger.LogInformation($\"‚úÖ CampaignSendLog updated for MessageId: {messageId} ‚Üí {statusText}\");\n                }\n            }\n        }\n\n        // üîÅ Entry point from webhook dispatcher\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogWarning(\"üîç Incoming timestamp raw value: {0}\", payload.ToString());\n            var entry = payload.GetProperty(\"entry\")[0];\n            var changes = entry.GetProperty(\"changes\")[0];\n            var value = changes.GetProperty(\"value\");\n\n            await ProcessAsync(value); // ‚úÖ Unified internal call\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "a9129664eb60ff771e1f4895a51f74dd7277f7693c9a9638cab9363dc4618baa",
      "language": "csharp",
      "size": 369,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "34280daacb42fd65daf76845f254009aff42867432c235250272bb6fc6676084",
      "language": "csharp",
      "size": 1972,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "5de062949cd3197e00bf3971292ea36c2014849de597b6cc077673c464a02286",
      "language": "csharp",
      "size": 1054,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n\n        public WebhookQueueService()\n        {\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            if (!_queue.Writer.TryWrite(item))\n            {\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            return await _queue.Reader.ReadAsync(cancellationToken);\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "9b49d77f9faaa3791a6a92f988ad2269e92a283fc91898ef5e885ed90fbbd586",
      "language": "csharp",
      "size": 8135,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing static System.Net.Mime.MediaTypeNames;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Central dispatcher for WhatsApp webhook events.\n    /// Routes payloads to the appropriate processor based on payload type.\n    /// </summary>\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        private readonly IStatusWebhookProcessor _statusProcessor;\n        private readonly ITemplateWebhookProcessor _templateProcessor;\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IClickWebhookProcessor _clickProcessor;\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n        public WhatsAppWebhookDispatcher(\n            IStatusWebhookProcessor statusProcessor,\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor)\n        {\n            _statusProcessor = statusProcessor;\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n        }\n\n\n        //public async Task DispatchAsync(JsonElement payload)\n        //{\n        //    //throw new Exception(\"üß™ Simulated webhook dispatch failure for testing.\");\n        //    _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n\" + payload.ToString());\n        //    try\n        //    {\n        //        if (!payload.TryGetProperty(\"entry\", out var entries)) return;\n\n        //        foreach (var entry in entries.EnumerateArray())\n        //        {\n        //            if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n        //            foreach (var change in changes.EnumerateArray())\n        //            {\n        //                if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n        //                // üì® Status Updates\n        //                if (value.TryGetProperty(\"statuses\", out _))\n        //                {\n        //                    _logger.LogInformation(\"üì¶ Routing to Status Processor\");\n        //                    await _statusProcessor.ProcessStatusUpdateAsync(payload);\n        //                    continue;\n        //                }\n\n        //                // üßæ Template Events\n        //                if (value.TryGetProperty(\"event\", out var eventType)\n        //                    && eventType.GetString()?.StartsWith(\"template_\") == true)\n        //                {\n        //                    _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n        //                    await _templateProcessor.ProcessTemplateUpdateAsync(payload);\n        //                    continue;\n        //                }\n\n        //                // üéØ Click Events\n        //                if (value.TryGetProperty(\"messages\", out var messages)\n        //                    && messages.GetArrayLength() > 0\n        //                    && messages[0].TryGetProperty(\"type\", out var type)\n        //                    && type.GetString() == \"button\")\n        //                {\n        //                    _logger.LogInformation(\"üëâ Routing to Click Processor\");\n        //                    await _clickProcessor.ProcessClickAsync(value);\n        //                    continue;\n        //                }\n        //                // üì• Inbound text/image/audio messages from customer\n        //                if (value.TryGetProperty(\"messages\", out var messages) &&\n        //                    messages.GetArrayLength() > 0 &&\n        //                    messages[0].TryGetProperty(\"type\", out var typeProp))\n        //                {\n        //                    var type = typeProp.GetString();\n\n        //                    if (type is \"text\" or \"image\" or \"audio\")\n        //                    {\n        //                        _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n        //                        await _inboundProcessor.ProcessAsync(value);\n        //                        continue;\n        //                    }\n        //                }\n\n        //                _logger.LogWarning(\"‚ö†Ô∏è No matching event processor found.\");\n        //            }\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n        //    }\n        //}\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            //clickMessages for button clicks\n            // inboundMessages for text / image / audio\n\n            _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n\" + payload.ToString());\n\n            try\n            {\n                if (!payload.TryGetProperty(\"entry\", out var entries)) return;\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                        // üì® Status Updates\n                        if (value.TryGetProperty(\"statuses\", out _))\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Status Processor\");\n                            await _statusProcessor.ProcessStatusUpdateAsync(payload);\n                            continue;\n                        }\n\n                        // üßæ Template Events\n                        if (value.TryGetProperty(\"event\", out var eventType)\n                            && eventType.GetString()?.StartsWith(\"template_\") == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n                            await _templateProcessor.ProcessTemplateUpdateAsync(payload);\n                            continue;\n                        }\n\n                        // üéØ Click Events (button type)\n                        if (value.TryGetProperty(\"messages\", out var clickMessages)\n                            && clickMessages.GetArrayLength() > 0\n                            && clickMessages[0].TryGetProperty(\"type\", out var clickType)\n                            && clickType.GetString() == \"button\")\n                        {\n                            _logger.LogInformation(\"üëâ Routing to Click Processor\");\n                            await _clickProcessor.ProcessClickAsync(value);\n                            continue;\n                        }\n\n                        // üí¨ Inbound Messages (text/image/audio)\n                        if (value.TryGetProperty(\"messages\", out var inboundMessages)\n                            && inboundMessages.GetArrayLength() > 0\n                            && inboundMessages[0].TryGetProperty(\"type\", out var inboundType))\n                        {\n                            var type = inboundType.GetString();\n\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n                                await _inboundMessageProcessor.ProcessChatAsync(value);\n                                continue;\n                            }\n                        }\n\n                        _logger.LogWarning(\"‚ö†Ô∏è No matching event processor found.\");\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "1eab721a5c07db54368581314d45a8dfb105e5d301d1dd25be6883950deaad02",
      "language": "csharp",
      "size": 5546,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n\n        public WhatsAppWebhookService(AppDbContext context, ILogger<WhatsAppWebhookService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogInformation(\"üì¶ Processing Webhook Status:\\n\" +\n                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));\n\n            if (!payload.TryGetProperty(\"entry\", out var entries))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Payload missing 'entry' property.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                    if (!value.TryGetProperty(\"statuses\", out var statuses)) continue;\n\n                    foreach (var status in statuses.EnumerateArray())\n                    {\n                        string? messageId = status.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = status.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n                        long timestamp = status.TryGetProperty(\"timestamp\", out var tsProp) && tsProp.ValueKind == JsonValueKind.String\n                                         && long.TryParse(tsProp.GetString(), out var parsedTs)\n                                         ? parsedTs\n                                         : (tsProp.ValueKind == JsonValueKind.Number ? tsProp.GetInt64() : 0);\n\n                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))\n                        {\n                            _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or statusText in webhook payload.\");\n                            continue;\n                        }\n\n                        var log = await _context.CampaignSendLogs\n                            //.AsNoTracking()\n                            .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n                        if (log != null)\n                        {\n                            var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;\n\n                            //log.SendStatus = statusText switch\n                            //{\n                            //    \"sent\" => \"Sent\",\n                            //    \"delivered\" => \"Delivered\",\n                            //    \"read\" => \"Read\",\n                            //    _ => log.SendStatus\n                            //};\n\n                            //if (statusText == \"delivered\") log.DeliveredAt = time;\n                            //if (statusText == \"read\") log.ReadAt = time;\n\n                            //await _context.SaveChangesAsync();\n                            // üîÅ Avoid redundant updates\n                            var newStatus = statusText switch\n                            {\n                                \"sent\" => \"Sent\",\n                                \"delivered\" => \"Delivered\",\n                                \"read\" => \"Read\",\n                                _ => null\n                            };\n\n                            bool isUpdated = false;\n\n                            if (!string.IsNullOrEmpty(newStatus) && log.SendStatus != newStatus)\n                            {\n                                log.SendStatus = newStatus;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"delivered\" && log.DeliveredAt == null)\n                            {\n                                log.DeliveredAt = time;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"read\" && log.ReadAt == null)\n                            {\n                                log.ReadAt = time;\n                                isUpdated = true;\n                            }\n\n                            if (isUpdated)\n                            {\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation($\"‚úÖ Log updated for MessageId: {messageId} ‚Üí {newStatus}\");\n                            }\n                            else\n                            {\n                                _logger.LogInformation($\"üîÅ Duplicate status '{statusText}' skipped for MessageId: {messageId}\");\n                            }\n\n                            _logger.LogInformation($\"‚úÖ Log updated for MessageId: {messageId} ‚Üí {statusText}\");\n                        }\n                        else\n                        {\n                            _logger.LogWarning($\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}\");\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n}\n"
    }
  ]
}
