{
  "name": "xbytechat-api/Features",
  "part": 2,
  "of": 2,
  "generatedAt": "2025-08-11 18:04:10 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/ReportingModule/Services/MessageAnalyticsService.cs",
      "sha256": "3a87316fa63b4890a5bc35b2d867a96a2a7d73e8aea0e52ff6854e89c4245b7a",
      "language": "csharp",
      "size": 2844,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.ReportingModule.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ReportingModule.Services\n{\n    public class MessageAnalyticsService : IMessageAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public MessageAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<RecentMessageLogDto>> GetRecentLogsAsync(Guid businessId, int limit)\n        {\n            return await _context.MessageLogs\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(limit)\n                .Select(x => new RecentMessageLogDto\n                {\n                    Id = x.Id,\n                    RecipientNumber = x.RecipientNumber,\n                    MessageContent = x.MessageContent,\n                    CreatedAt = x.CreatedAt,\n                    CampaignId = x.CampaignId,\n                    Status = x.Status,\n                    SentAt = x.SentAt,\n                })\n                .ToListAsync();\n        }\n\n        public async Task<PaginatedResponse<RecentMessageLogDto>> GetPaginatedLogsAsync(Guid businessId, PaginatedRequest request)\n        {\n            var query = _context.MessageLogs\n                .Where(x => x.BusinessId == businessId);\n\n            if (!string.IsNullOrEmpty(request.Status))\n                query = query.Where(x => x.Status == request.Status);\n\n            if (!string.IsNullOrEmpty(request.Search))\n                query = query.Where(x =>\n                    x.RecipientNumber.Contains(request.Search) ||\n                    x.MessageContent.Contains(request.Search));\n\n            var totalCount = await query.CountAsync();\n\n            var items = await query\n                .OrderByDescending(x => x.CreatedAt)\n                .Skip((request.Page - 1) * request.PageSize)\n                .Take(request.PageSize)\n                .Select(x => new RecentMessageLogDto\n                {\n                    Id = x.Id,\n                    RecipientNumber = x.RecipientNumber,\n                    MessageContent = x.MessageContent,\n                    CreatedAt = x.CreatedAt,\n                    CampaignId = x.CampaignId,\n                    Status = x.Status,\n                    SentAt = x.SentAt,\n                })\n                .ToListAsync();\n\n            return new PaginatedResponse<RecentMessageLogDto>\n            {\n                Items = items,\n                TotalCount = totalCount,\n                Page = request.Page,\n                PageSize = request.PageSize\n            };\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Controllers/TemplatesController.cs",
      "sha256": "b7014e9c08b5d3cf85e8dbd5edf632bc51e34a2acac661dbb3109dcd259edf4c",
      "language": "csharp",
      "size": 1479,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateModule.Services;\n\nnamespace xbytechat.api.Features.TemplateModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/templates\")]\n    public class TemplatesController : ControllerBase\n    {\n        private readonly IWhatsAppTemplateService _templateService;\n        private readonly ILogger<TemplatesController> _logger;\n\n        public TemplatesController(IWhatsAppTemplateService templateService, ILogger<TemplatesController> logger)\n        {\n            _templateService = templateService;\n            _logger = logger;\n        }\n\n        /// <summary>\n        /// Fetches WhatsApp template metadata (name, language, body, placeholders)\n        /// </summary>\n        [HttpGet(\"metadata\")]\n        public async Task<IActionResult> GetTemplates()\n        {\n            try\n            {\n                var templates = await _templateService.FetchTemplatesAsync();\n                return Ok(new\n                {\n                    success = true,\n                    templates\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error fetching template metadata: \" + ex.Message);\n                return StatusCode(500, new\n                {\n                    success = false,\n                    message = \"‚ùå Failed to retrieve template metadata\",\n                    error = ex.Message\n                });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/IWhatsAppTemplateService.cs",
      "sha256": "2ed5f5891246b4fec02e29892760c3d033e76572488701c525fd801763f742a9",
      "language": "csharp",
      "size": 226,
      "content": "using xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public interface IWhatsAppTemplateService\n    {\n        Task<List<TemplateMetadataDto>> FetchTemplatesAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/WhatsAppTemplateService.cs",
      "sha256": "ee70376834e701f63425a69d50a4ea5d02170321edf828fe7fd2bd5d100bf3a1",
      "language": "csharp",
      "size": 2815,
      "content": "using Microsoft.Extensions.Configuration;\nusing Newtonsoft.Json;\nusing xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public class WhatsAppTemplateService : IWhatsAppTemplateService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly IConfiguration _config;\n        private readonly ILogger<WhatsAppTemplateService> _logger;\n\n        public WhatsAppTemplateService(HttpClient httpClient, IConfiguration config, ILogger<WhatsAppTemplateService> logger)\n        {\n            _httpClient = httpClient;\n            _config = config;\n            _logger = logger;\n        }\n\n        public async Task<List<TemplateMetadataDto>> FetchTemplatesAsync()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var token = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v18.0/{wabaId}/message_templates\";\n\n            var templates = new List<TemplateMetadataDto>();\n\n            try\n            {\n                _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);\n                var response = await _httpClient.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogError(\"Failed to fetch WhatsApp templates: \" + json);\n                    return templates;\n                }\n\n                var parsed = JsonConvert.DeserializeObject<dynamic>(json);\n\n                foreach (var tpl in parsed.data)\n                {\n                    string name = tpl.name;\n                    string language = tpl.language ?? \"en_US\";\n                    string body = \"\";\n\n                    foreach (var component in tpl.components)\n                    {\n                        if (component.type == \"BODY\")\n                        {\n                            body = component.text;\n                            break;\n                        }\n                    }\n\n                    // Count {{placeholders}}\n                    var placeholderCount = System.Text.RegularExpressions.Regex.Matches(body, \"{{(.*?)}}\").Count;\n\n                    templates.Add(new TemplateMetadataDto\n                    {\n                        Name = name,\n                        Language = language,\n                        Body = body,\n                        PlaceholderCount = placeholderCount\n                    });\n                }\n\n                return templates;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error while fetching templates from Meta: \" + ex.Message);\n                return templates;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingController.cs",
      "sha256": "eff454d0f22519fc547f7489d9205cb738600a0d241003c5f0ac3f38694b517a",
      "language": "csharp",
      "size": 11562,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking\")]\n    public class TrackingController : ControllerBase\n    {\n        private readonly ITrackingService _tracker;\n\n        public TrackingController(ITrackingService tracker)\n        {\n            _tracker = tracker;\n        }\n        #region \"Tracking Logs\"\n        //       [HttpGet(\"redirect\")]\n        //       public async Task<IActionResult> TrackAndRedirect(\n        //                                        [FromQuery] string src,\n        //                                        [FromQuery] Guid id,\n        //                                        [FromQuery] string btn,\n        //                                        [FromQuery] string? to = null,\n        //                                        [FromQuery] string? type = null,\n        //                                        [FromQuery] Guid? msg = null,\n        //                                        [FromQuery] Guid? contact = null,\n        //                                        [FromQuery] string? phone = null,\n        //                                        [FromQuery] string? session = null,\n        //                                        [FromQuery] string? thread = null\n        //)\n        //       {\n        //           var userAgent = Request.Headers[\"User-Agent\"].FirstOrDefault() ?? \"unknown\";\n        //           var ipAddress = Request.Headers[\"X-Forwarded-For\"].FirstOrDefault()\n        //                        ?? HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n\n        //           var country = await GeoHelper.GetCountryFromIP(ipAddress);\n        //           var deviceType = DeviceHelper.GetDeviceType(userAgent);\n\n        //           var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n        //           if (!Guid.TryParse(businessIdClaim, out var businessId))\n        //               return Unauthorized(\"Invalid business context\");\n\n        //           var dto = new TrackingLogDto\n        //           {\n        //               BusinessId = businessId,// Guid.Empty, // TODO: Replace with actual business lookup if available\n        //               ContactId = contact,\n        //               ContactPhone = phone,\n        //               SourceType = src,\n        //               SourceId = id,\n        //               ButtonText = btn,\n        //               CTAType = type ?? btn,\n        //               MessageId = msg?.ToString(),\n        //               SessionId = session,\n        //               ThreadId = thread,\n        //               ClickedAt = DateTime.UtcNow,\n        //               IPAddress = ipAddress,\n        //               Browser = userAgent,\n        //               DeviceType = deviceType,\n        //               Country = country,\n        //               ClickedVia = \"web\"\n        //           };\n\n        //           await _tracker.LogCTAClickAsync(dto);\n\n        //           if (string.IsNullOrWhiteSpace(to))\n        //               return BadRequest(\"Missing redirect target.\");\n\n        //           var decodedUrl = Uri.UnescapeDataString(to);\n        //           return Redirect(decodedUrl);\n        //       }\n\n        #endregion\n\n        //        [HttpGet(\"redirect\")]\n        //        public async Task<IActionResult> TrackAndRedirect(\n        //            [FromQuery] string src,\n        //            [FromQuery] Guid id,\n        //            [FromQuery] string btn,\n        //            [FromQuery] string? to = null,\n        //            [FromQuery] string? type = null,\n        //            [FromQuery] Guid? msg = null,\n        //            [FromQuery] Guid? contact = null,\n        //            [FromQuery] string? phone = null,\n        //            [FromQuery] string? session = null,\n        //            [FromQuery] string? thread = null\n        //)\n        //        {\n        //            var userAgent = Request.Headers[\"User-Agent\"].FirstOrDefault() ?? \"unknown\";\n        //            var ipAddress = Request.Headers[\"X-Forwarded-For\"].FirstOrDefault()\n        //                         ?? HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n\n        //            var country = await GeoHelper.GetCountryFromIP(ipAddress);\n        //            var deviceType = DeviceHelper.GetDeviceType(userAgent);\n\n        //            // üîç 1. Attempt to extract businessId from claims\n        //            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n        //            var hasBusinessId = Guid.TryParse(businessIdClaim, out var businessId);\n\n        //            // üß† 2. Create base DTO\n        //            var dto = new TrackingLogDto\n        //            {\n        //                BusinessId = hasBusinessId ? businessId : Guid.Empty, // fallback ‚Äî will enrich later\n        //                ContactId = contact,\n        //                ContactPhone = phone,\n        //                SourceType = src,\n        //                SourceId = id,\n        //                ButtonText = btn,\n        //                CTAType = type ?? btn,\n        //                MessageId = msg?.ToString(),\n        //                SessionId = session,\n        //                ThreadId = thread,\n        //                ClickedAt = DateTime.UtcNow,\n        //                IPAddress = ipAddress,\n        //                Browser = userAgent,\n        //                DeviceType = deviceType,\n        //                Country = country,\n        //                ClickedVia = \"web\"\n        //            };\n\n        //            // üîÅ 3. Fallback enrichment from MessageLog\n        //            if (msg.HasValue)\n        //            {\n        //                var messageLog = await _context.MessageLogs\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(m => m.Id == msg.Value || m.MessageId == msg.ToString());\n\n        //                if (messageLog != null)\n        //                {\n        //                    // üß© Backfill missing fields if needed\n        //                    dto.BusinessId = dto.BusinessId == Guid.Empty ? messageLog.BusinessId : dto.BusinessId;\n        //                    dto.ContactId ??= messageLog.ContactId;\n        //                    dto.CampaignId ??= messageLog.CampaignId;\n        //                    dto.MessageLogId ??= messageLog.Id;\n        //                }\n        //            }\n\n        //            // üîÅ 4. Fallback from CampaignSendLog (if SourceType is \"campaign\")\n        //            if (src == \"campaign\" && msg.HasValue && dto.CampaignId == null)\n        //            {\n        //                var sendLog = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(c => c.MessageId == msg.ToString());\n\n        //                if (sendLog != null)\n        //                {\n        //                    dto.BusinessId = dto.BusinessId == Guid.Empty ? sendLog.BusinessId : dto.BusinessId;\n        //                    dto.ContactId ??= sendLog.ContactId;\n        //                    dto.CampaignId ??= sendLog.CampaignId;\n        //                    dto.CampaignSendLogId ??= sendLog.Id;\n        //                }\n        //            }\n\n        //            // ‚úÖ 5. Final safety check\n        //            if (dto.BusinessId == Guid.Empty)\n        //            {\n        //                Log.Warning(\"‚ö†Ô∏è TrackingLog DTO missing valid BusinessId. msg={@msg}\", msg);\n        //                return Unauthorized(\"Business context missing or invalid.\");\n        //            }\n\n        //            // üíæ 6. Save to database\n        //            await _tracker.LogCTAClickAsync(dto);\n\n        //            // üåê 7. Redirect to final URL\n        //            if (string.IsNullOrWhiteSpace(to))\n        //                return BadRequest(\"Missing redirect target.\");\n\n        //            var decodedUrl = Uri.UnescapeDataString(to);\n        //            return Redirect(decodedUrl);\n        //        }\n        [HttpGet(\"redirect\")]\n        public async Task<IActionResult> TrackAndRedirect([FromQuery] string src, [FromQuery] Guid id,\n            [FromQuery] string btn, [FromQuery] string? to = null, [FromQuery] string? type = null,\n            [FromQuery] Guid? msg = null, [FromQuery] Guid? contact = null, [FromQuery] string? phone = null,\n            [FromQuery] string? session = null, [FromQuery] string? thread = null)\n        {\n            var userAgent = Request.Headers[\"User-Agent\"].FirstOrDefault() ?? \"unknown\";\n            var ipAddress = Request.Headers[\"X-Forwarded-For\"].FirstOrDefault()\n                         ?? HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n\n            var country = await GeoHelper.GetCountryFromIP(ipAddress);\n            var deviceType = DeviceHelper.GetDeviceType(userAgent);\n\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var hasBusinessId = Guid.TryParse(businessIdClaim, out var businessId);\n\n            var dto = new TrackingLogDto\n            {\n                BusinessId = hasBusinessId ? businessId : Guid.Empty,\n                ContactId = contact,\n                ContactPhone = phone,\n                SourceType = src,\n                SourceId = id,\n                ButtonText = btn,\n                CTAType = type ?? btn,\n                MessageId = msg?.ToString(),\n                SessionId = session,\n                ThreadId = thread,\n                ClickedAt = DateTime.UtcNow,\n                IPAddress = ipAddress,\n                Browser = userAgent,\n                DeviceType = deviceType,\n                Country = country,\n                ClickedVia = \"web\"\n            };\n\n            var result = await _tracker.LogCTAClickWithEnrichmentAsync(dto);\n            if (!result.Success)\n                return Unauthorized(result.Message);\n\n            if (string.IsNullOrWhiteSpace(to))\n                return BadRequest(\"Missing redirect target.\");\n\n            return Redirect(Uri.UnescapeDataString(to));\n        }\n\n        [HttpGet(\"logs/{id}/details\")]\n        public async Task<IActionResult> GetLogDetails(Guid id)\n        {\n            var result = await _tracker.GetLogDetailsAsync(id);\n            if (result == null)\n                return NotFound(\"Tracking log not found\");\n\n            return Ok(result);\n        }\n        [HttpGet(\"flow-clicks\")]\n       \n        public async Task<IActionResult> GetFlowClickLogs()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"‚ùå Invalid or missing business ID\");\n\n            var logs = await _tracker.GetFlowClickLogsAsync(businessId);\n\n            var dtoList = logs.Select(x => new\n            {\n                x.Id,\n                x.StepId,\n                x.ContactPhone,\n                x.ButtonText,\n                x.TemplateId,\n                x.FollowUpSent,\n                x.ClickedAt\n            });\n\n            return Ok(dtoList);\n        }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingViewerController.cs",
      "sha256": "6dfeff85fe69af455c90c7ae2ad1fd0614866359c0eaee39cf101ca67b819507",
      "language": "csharp",
      "size": 1584,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking/logs\")]\n    public class TrackingViewerController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n\n        public TrackingViewerController(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] Guid? campaignId = null)\n        {\n            var query = _context.TrackingLogs\n                .Include(t => t.Campaign) // Optional\n                .Include(t => t.Contact)  // Optional\n                .OrderByDescending(t => t.ClickedAt)\n                .AsQueryable();\n\n            if (campaignId.HasValue)\n                query = query.Where(t => t.CampaignId == campaignId);\n\n            var results = await query\n                .Select(t => new\n                {\n                    t.Id,\n                    t.ContactPhone,\n                    ContactName = t.Contact != null ? t.Contact.Name : \"(N/A)\",\n                    t.ButtonText,\n                    t.CTAType,\n                    t.SourceType,\n                    t.ClickedAt,\n                    t.DeviceType,\n                    t.Country,\n                    CampaignName = t.Campaign != null ? t.Campaign.Name : \"(Unknown)\"\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = results });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDetailsDto.cs",
      "sha256": "e27d7a86aea38ec1fef0aaf6d4d6c208e2481cfaf7033c57fa8da1c81d2c693c",
      "language": "csharp",
      "size": 453,
      "content": "using xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDetailsDto\n    {\n        public TrackingLogDto Tracking { get; set; } = new();\n        public ContactDto? Contact { get; set; }\n        public CampaignDto? Campaign { get; set; }\n        public MessageLogDto? MessageLog { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDto.cs",
      "sha256": "bae94801851bba1bbeb94d60e81f2d20efd13b86be1391265098462d82a3c762",
      "language": "csharp",
      "size": 1798,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDto\n    {\n        // üß© Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // üë§ CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n\n        // üîó Source Info\n        public string SourceType { get; set; } = string.Empty; // e.g. \"campaign\", \"reminder\", \"bot\"\n        public Guid? SourceId { get; set; }\n\n        // üîò CTA Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // üì® Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n\n        // üß† Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n        // üì° Tracking\n        public string? IPAddress { get; set; }\n        public string? Browser { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üîñ Session context\n        public string? SessionId { get; set; }\n        public string? ThreadId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Guid? CampaignSendLogId { get; set; }\n\n        public string RawJson { get; set; } = string.Empty; // used in queue method\n        public DateTime EnqueuedAt { get; set; } // used in queue method\n        public string? NextStepMatched { get; set; } // ‚úÖ Add this if not already there\n\n        public string? TemplateName { get; set; } // ‚úÖ Needed for follow-up matcher\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Models/TrackingLog.cs",
      "sha256": "ce8da394901366ef9d5d9b32a338d7a49d6b8d06eb1f911e89e02296506b4281",
      "language": "csharp",
      "size": 2252,
      "content": "using xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.Tracking.Models;\nnamespace xbytechat.api.Features.Tracking.Models\n{\n    public class TrackingLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß© Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // üë§ CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n        public Contact? Contact { get; set; } // ‚úÖ NEW\n\n        // üîó Source Info\n        public string SourceType { get; set; } = string.Empty;\n        public Guid? SourceId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; } // ‚úÖ NEW\n\n        public Guid? CampaignSendLogId { get; set; }\n        public CampaignSendLog? CampaignSendLog { get; set; } // ‚úÖ Optional\n\n        // üîò Button Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // üì® Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; } // ‚úÖ Optional\n\n        // üß† Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n\n        // üïí Audit Trail\n        public DateTime ClickedAt { get; set; } = DateTime.UtcNow;\n        public string? IPAddress { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // üîñ Follow-up & Analytics\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n\n        // üßµ Journey Tracking\n        public Guid? SessionId { get; set; }\n        public Guid? ThreadId { get; set; }\n        public Guid? StepId { get; set; } // ‚úÖ Link to CTAFlowStep for CTA Flow tracking\n\n       //  public string? NextStepMatched { get; set; } // Logs which template system resolved\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/ITrackingService.cs",
      "sha256": "7331e4a2b1fb44932573c4ed055613cc4ae21dcd9ec54bc25210c57cd340737c",
      "language": "csharp",
      "size": 528,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface ITrackingService\n    {\n        Task LogCTAClickAsync(TrackingLogDto dto);\n        Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId);\n        Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto);\n        Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingService.cs",
      "sha256": "90d3f4b3c6a0d5d10d83300d0c3ed58fc81149c2dec145768cfafe2886dccb0b",
      "language": "csharp",
      "size": 9142,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Shared.TrackingUtils;\nusing Serilog;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing AutoMapper;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class TrackingService : ITrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMapper _mapper;\n        public TrackingService(AppDbContext context, IMapper mapper)\n        {\n            _context = context;\n            _mapper = mapper;\n        }\n\n\n        public async Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                // üß† 1. Try enrich from MessageLog (if msg ID provided)\n                if (!string.IsNullOrEmpty(dto.MessageId))\n                {\n                    var messageLog = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m => m.MessageId == dto.MessageId || m.Id.ToString() == dto.MessageId);\n\n                    if (messageLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty ? messageLog.BusinessId : dto.BusinessId;\n                        dto.ContactId ??= messageLog.ContactId;\n                        dto.CampaignId ??= messageLog.CampaignId;\n                        dto.MessageLogId ??= messageLog.Id;\n                    }\n                }\n\n                // üß© 2. Enrich from CampaignSendLog if sourceType = campaign\n                CampaignSendLog? sendLog = null;\n\n                if (dto.SourceType == \"campaign\")\n                {\n                    if (!string.IsNullOrEmpty(dto.MessageId))\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .FirstOrDefaultAsync(c => c.MessageId == dto.MessageId);\n                    }\n\n                    if (sendLog == null && dto.CampaignId != null)\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .Where(c => c.CampaignId == dto.CampaignId)\n                            .OrderByDescending(c => c.CreatedAt)\n                            .FirstOrDefaultAsync();\n                    }\n\n                    if (sendLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty\n                            ? sendLog.Recipient?.BusinessId ?? Guid.Empty\n                            : dto.BusinessId;\n\n                        dto.ContactId ??= sendLog.ContactId;\n                        dto.CampaignId ??= sendLog.CampaignId;\n                        dto.CampaignSendLogId ??= sendLog.Id;\n\n                        // ‚úÖ Update campaign send log click details\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = dto.ClickedAt ?? DateTime.UtcNow;\n                        sendLog.ClickType = dto.ButtonText;\n\n                        await _context.SaveChangesAsync();\n                    }\n                }\n\n                // ‚úÖ 3. Validate business context\n                if (dto.BusinessId == Guid.Empty)\n                {\n                    Log.Warning(\"‚ùå TrackingLog failed: No BusinessId available for click.\");\n                    return ResponseResult.ErrorInfo(\"Business context is missing.\");\n                }\n\n                // üíæ 4. Save tracking log (inline instead of separate method)\n                var trackingLog = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(trackingLog);\n                await _context.SaveChangesAsync();\n\n                // ‚úÖ Return the TrackingLog.Id in the response\n                return ResponseResult.SuccessInfo(\"CTA click tracked successfully.\", trackingLog.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during CTA tracking enrichment\");\n                return ResponseResult.ErrorInfo(\"Exception during tracking: \" + ex.Message);\n            }\n        }\n\n        public async Task LogCTAClickAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                var log = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log CTA click\");\n            }\n        }\n        public async Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId)\n        {\n            var tracking = await _context.TrackingLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (tracking == null)\n                return null;\n\n            var contact = tracking.ContactId != null\n                ? await _context.Contacts.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.ContactId)\n                : null;\n\n            var campaign = tracking.CampaignId != null\n                ? await _context.Campaigns.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.CampaignId)\n                : null;\n\n            var messageLog = tracking.MessageLogId != null\n                ? await _context.MessageLogs.AsNoTracking().FirstOrDefaultAsync(m => m.Id == tracking.MessageLogId)\n                : null;\n\n            return new TrackingLogDetailsDto\n            {\n                Tracking = _mapper.Map<TrackingLogDto>(tracking),\n                Contact = contact != null ? _mapper.Map<ContactDto>(contact) : null,\n                Campaign = campaign != null ? _mapper.Map<CampaignDto>(campaign) : null,\n                MessageLog = messageLog != null ? _mapper.Map<MessageLogDto>(messageLog) : null\n            };\n        }\n        public async Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId)\n        {\n            return await _context.TrackingLogs\n                .Where(x => x.BusinessId == businessId && x.SourceType == \"cta-flow\")\n                .OrderByDescending(x => x.ClickedAt)\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "4a0dbbf63a7e5e5dbdea08790538d449d81f91e4234da7a4b8acedf0ff744b25",
      "language": "csharp",
      "size": 3019,
      "content": "using System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services;\nusing xbytechat.api.Features.Webhooks.DTOs;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var clonedPayload = payload.Clone(); // ‚úÖ Avoid disposal issue\n\n                using var scope = _scopeFactory.CreateScope();\n\n                // üîÑ Resolve scoped dependencies\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                // üöÄ Dispatch\n                await dispatcher.DispatchAsync(clonedPayload);\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error while processing webhook payload.\");\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                       // RawJson = ex.Data[\"payload\"]?.ToString() ?? \"(unavailable)\",\n                        RawJson = ex.Data[\"payload\"]?.ToString() ?? \"{}\",\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    await failureLogger.LogFailureAsync(fallback);\n                }\n                catch (Exception innerEx)\n                {\n                    _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to log to FailedWebhookLogs table.\");\n                }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "d25c1bf6870c1712f3270bf8e478e741c09e7d32497bb0f3e64885e8e5c6c7ec",
      "language": "csharp",
      "size": 2801,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n            public WhatsAppWebhookController(ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config, AppDbContext context, IWhatsAppWebhookService webhookService, IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            // üîê Load your secret token from config or environment\n            var expectedToken = _config[\"WhatsApp:MetaToken\"];\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\"‚ùå WhatsApp webhook verification failed.\");\n            return Forbid(\"Token mismatch.\");\n        }\n\n     \n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            _logger.LogWarning(\"üì• Webhook received at controller:\\n\" + payload.ToString());\n\n            try\n            {\n                var cloned = payload.Clone(); // Important to clone here\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "68f4211391a24a94d3096c5cd71fbd6cbd0fed0211dd2929b92b1780ffd02fc8",
      "language": "csharp",
      "size": 2109,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceProvider _services;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(ILogger<FailedWebhookLogCleanupService> logger, IServiceProvider services)\n        {\n            _logger = logger;\n            _services = services;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _services.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Any())\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\"üßπ Deleted {Count} old failed webhook logs.\", oldLogs.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                await Task.Delay(_interval, stoppingToken); // wait before next cleanup\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "79f51c796e3319918315cd6043f985b763534fbb19a8357713d2c01aaf385112",
      "language": "csharp",
      "size": 227,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService .cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "0887fd0dd55ee4fa7ceaae2f534d1b7b0fbdb99dd3814e8a861f68c1b9145c3b",
      "language": "csharp",
      "size": 17249,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService)\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n        }\n\n\n        //public async Task ProcessClickAsync(JsonElement value)\n        //{\n        //    _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n        //    try\n        //    {\n        //        _logger.LogWarning(\"üì• [DEBUG] Click processor entered with value: \" + value.ToString());\n\n        //        if (!value.TryGetProperty(\"messages\", out var messages)) return;\n        //        var message = messages[0];\n\n        //        if (message.GetProperty(\"type\").GetString() != \"button\") return;\n\n        //        var clickMessageId = message.GetProperty(\"id\").GetString();\n        //        var originalMessageId = message.GetProperty(\"context\").GetProperty(\"id\").GetString();\n        //        var from = message.GetProperty(\"from\").GetString();\n        //        var buttonText = message.GetProperty(\"button\").GetProperty(\"text\").GetString()?.Trim().ToLower();\n\n        //        _logger.LogInformation(\"üñ±Ô∏è Button Click ‚ê¶ From: {From}, ClickMsgId: {ClickId}, OriginalMsgId: {OrigId}, Text: {Text}\",\n        //            from, clickMessageId, originalMessageId, buttonText);\n\n        //        Guid businessId = Guid.Empty;\n        //        Guid? contactId = null;\n        //        string contactPhone = from;\n        //        Guid? campaignId = null;\n        //        Guid? sendLogId = null;\n        //        string sourceType = \"catalog\";\n        //        Guid? sourceId = null;\n\n        //        // 1Ô∏è‚É£ Try CampaignSendLog\n        //        var campaignLog = await _context.CampaignSendLogs\n        //            .Include(l => l.Campaign)\n        //            .Include(l => l.Contact)\n        //            .FirstOrDefaultAsync(l => l.MessageId == originalMessageId);\n\n        //        if (campaignLog != null)\n        //        {\n        //            _logger.LogInformation(\"üìä CampaignSendLog matched via context.id\");\n\n        //            businessId = campaignLog.Campaign?.BusinessId ?? Guid.Empty;\n        //            contactId = campaignLog.ContactId;\n        //            contactPhone = campaignLog.Contact?.PhoneNumber ?? from;\n        //            campaignId = campaignLog.CampaignId;\n        //            sendLogId = campaignLog.Id;\n        //            sourceType = \"campaign\";\n        //            sourceId = campaignLog.CampaignId;\n\n        //            // üîÅ Auto Follow-Up\n        //            if (buttonText == \"interested\" &&\n        //                !string.IsNullOrWhiteSpace(campaignLog.Campaign?.FollowUpTemplateId))\n        //            {\n        //                var followUpDto = new SimpleTemplateMessageDto\n        //                {\n        //                    BusinessId = businessId,\n        //                    RecipientNumber = contactPhone,\n        //                    TemplateName = campaignLog.Campaign.FollowUpTemplateId,\n        //                    TemplateParameters = new() // Phase 1 ‚Üí no variables\n        //                };\n\n        //                var result = await _messageEngine.SendTemplateMessageSimpleAsync(followUpDto);\n        //                _logger.LogInformation(result.Success\n        //                    ? \"‚úÖ Follow-up message sent successfully.\"\n        //                    : $\"‚ùå Follow-up failed: {result.Message}\");\n        //            }\n        //        }\n        //        else\n        //        {\n        //            _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found. Trying fallback to MessageLogs.\");\n\n        //            var log = await _context.MessageLogs\n        //                .FirstOrDefaultAsync(m =>\n        //                    m.MessageId == originalMessageId ||\n        //                    m.Id.ToString() == originalMessageId ||\n        //                    m.RawResponse.Contains(originalMessageId));\n\n        //            if (log != null)\n        //            {\n        //                businessId = log.BusinessId;\n        //                contactId = log.ContactId;\n        //                contactPhone = log.RecipientNumber ?? from;\n        //                sourceType = \"flow\";\n        //                _logger.LogInformation(\"‚úÖ Fallback matched MessageLog. BusinessId: {BusinessId}\", businessId);\n        //            }\n        //            else\n        //            {\n        //                _logger.LogWarning(\"‚ùå Fallback to MessageLogs failed. No message found for: {OriginalId}\", originalMessageId);\n        //            }\n        //        }\n\n        //        if (businessId == Guid.Empty)\n        //        {\n        //            _logger.LogWarning(\"‚ùå TrackingLog failed: No BusinessId available for click.\");\n        //            return;\n        //        }\n\n        //        // 2Ô∏è‚É£ Save Tracking\n        //        var dto = new TrackingLogDto\n        //        {\n        //            BusinessId = businessId,\n        //            CampaignId = campaignId,\n        //            CampaignSendLogId = sendLogId,\n        //            ContactId = contactId,\n        //            ContactPhone = contactPhone,\n        //            MessageId = originalMessageId,\n        //            MessageLogId = null,\n        //            SourceType = sourceType,\n        //            SourceId = sourceId,\n        //            ButtonText = buttonText,\n        //            CTAType = buttonText,\n        //            ClickedVia = \"webhook\",\n        //            ClickedAt = DateTime.UtcNow,\n        //            Browser = \"WhatsApp\",\n        //            IPAddress = \"webhook\",\n        //            DeviceType = DeviceHelper.GetDeviceType(\"WhatsApp\"),\n        //            Country = await GeoHelper.GetCountryFromIP(\"webhook\"),\n        //            RawJson = value.ToString()\n        //        };\n\n        //        var resultLog = await _trackingService.LogCTAClickWithEnrichmentAsync(dto);\n        //        _logger.LogInformation(\"üì• Tracking Result: {Result}\", resultLog?.Message ?? \"N/A\");\n\n        //        // 3Ô∏è‚É£ Match Flow ‚Üí Trigger Next Step (if any)\n        //        try\n        //        {\n        //            if (!string.IsNullOrWhiteSpace(dto.ButtonText))\n        //            {\n        //                var matchedStep = await _flowService.MatchStepByButtonAsync(\n        //                    businessId,\n        //                    dto.ButtonText.Trim().ToLower(),\n        //                    \"quick_reply\",\n        //                    campaignLog?.Campaign?.MessageTemplate ?? \"\",  // currentTemplateName\n        //                    campaignId\n        //                );\n\n        //                if (matchedStep != null)\n        //                {\n        //                    ResponseResult sendResult;\n\n        //                    switch (matchedStep.TemplateType?.ToLower())\n        //                    {\n        //                        case \"image_template\":\n        //                            var imageDto = new ImageTemplateMessageDto\n        //                            {\n        //                                BusinessId = businessId,\n        //                                RecipientNumber = contactPhone,\n        //                                TemplateName = matchedStep.TemplateToSend,\n        //                                LanguageCode = \"en_US\"\n        //                            };\n        //                            sendResult = await _messageEngine.SendImageTemplateMessageAsync(imageDto);\n        //                            break;\n\n        //                        case \"text_template\":\n        //                            var textDto = new SimpleTemplateMessageDto\n        //                            {\n        //                                BusinessId = businessId,\n        //                                RecipientNumber = contactPhone,\n        //                                TemplateName = matchedStep.TemplateToSend,\n        //                                TemplateParameters = new() // Phase 1 = No placeholders\n        //                            };\n        //                            sendResult = await _messageEngine.SendTemplateMessageSimpleAsync(textDto);\n        //                            break;\n\n        //                        default:\n        //                            _logger.LogWarning(\"‚ùå Unsupported template type in flow step: {Type}\", matchedStep.TemplateType);\n        //                            return;\n        //                    }\n\n        //                    if (sendResult.Success)\n        //                    {\n        //                        _logger.LogInformation(\"‚ö° CTA Flow matched! Sent template: {Template}\", matchedStep.TemplateToSend);\n        //                    }\n        //                    else\n        //                    {\n        //                        _logger.LogWarning(\"‚ùå Failed to send matched CTA template: {Message}\", sendResult.Message);\n        //                    }\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogInformation(\"üü° No CTA Flow matched for button: {Text}\", dto.ButtonText);\n        //                }\n        //            }\n        //        }\n        //        catch (Exception flowEx)\n        //        {\n        //            _logger.LogError(flowEx, \"‚ùå CTA Flow trigger failed.\");\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Failed to process button click.\");\n        //    }\n        //}\n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages)) return;\n                var message = messages[0];\n\n                if (message.GetProperty(\"type\").GetString() != \"button\") return;\n\n                var clickMessageId = message.GetProperty(\"id\").GetString();\n                var originalMessageId = message.GetProperty(\"context\").GetProperty(\"id\").GetString();\n                var from = message.GetProperty(\"from\").GetString();\n                var buttonText = message.GetProperty(\"button\").GetProperty(\"text\").GetString()?.Trim();\n\n                _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                    from, clickMessageId, originalMessageId, buttonText);\n\n                Guid businessId = Guid.Empty;\n                Guid? contactId = null;\n                string contactPhone = from;\n                Guid? campaignId = null;\n                Guid? sendLogId = null;\n                string sourceType = \"catalog\";\n                Guid? sourceId = null;\n\n                // 1Ô∏è‚É£ Try CampaignSendLog\n                var campaignLog = await _context.CampaignSendLogs\n                    .Include(l => l.Campaign)\n                    .Include(l => l.Contact)\n                    .FirstOrDefaultAsync(l => l.MessageId == originalMessageId);\n\n                if (campaignLog != null)\n                {\n                    _logger.LogInformation(\"üìä CampaignSendLog matched via context.id\");\n\n                    businessId = campaignLog.Campaign?.BusinessId ?? Guid.Empty;\n                    contactId = campaignLog.ContactId;\n                    contactPhone = campaignLog.Contact?.PhoneNumber ?? from;\n                    campaignId = campaignLog.CampaignId;\n                    sendLogId = campaignLog.Id;\n                    sourceType = \"campaign\";\n                    sourceId = campaignLog.CampaignId;\n                }\n                else\n                {\n                    var log = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId ||\n                            m.Id.ToString() == originalMessageId ||\n                            m.RawResponse.Contains(originalMessageId));\n\n                    if (log != null)\n                    {\n                        businessId = log.BusinessId;\n                        contactId = log.ContactId;\n                        contactPhone = log.RecipientNumber ?? from;\n                        sourceType = \"flow\";\n                        _logger.LogInformation(\"‚úÖ Fallback matched MessageLog. BusinessId: {BusinessId}\", businessId);\n                    }\n                }\n\n                if (businessId == Guid.Empty)\n                {\n                    _logger.LogWarning(\"‚ùå TrackingLog failed: No BusinessId available.\");\n                    return;\n                }\n\n                // 2Ô∏è‚É£ Save Click Log with enrichment\n                var dto = new TrackingLogDto\n                {\n                    BusinessId = businessId,\n                    CampaignId = campaignId,\n                    CampaignSendLogId = sendLogId,\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n                    MessageId = originalMessageId,\n                    MessageLogId = null,\n                    SourceType = sourceType,\n                    SourceId = sourceId,\n                    ButtonText = buttonText,\n                    CTAType = buttonText,\n                    ClickedVia = \"webhook\",\n                    ClickedAt = DateTime.UtcNow,\n                    Browser = \"WhatsApp\",\n                    IPAddress = \"webhook\",\n                    DeviceType = DeviceHelper.GetDeviceType(\"WhatsApp\"),\n                    Country = await GeoHelper.GetCountryFromIP(\"webhook\"),\n                    RawJson = value.ToString()\n                };\n\n                var resultLog = await _trackingService.LogCTAClickWithEnrichmentAsync(dto);\n                _logger.LogInformation(\"üì• Click Tracked ‚Üí Result: {Msg}\", resultLog?.Message ?? \"N/A\");\n\n                // ‚úÖ Extract TrackingLog.Id from result\n                if (resultLog?.Success != true || resultLog.Data is not Guid trackingLogId)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Skipping flow execution: Tracking ID not found.\");\n                    return;\n                }\n\n                // 3Ô∏è‚É£ Match Flow Step and trigger flow\n                if (!string.IsNullOrWhiteSpace(dto.ButtonText))\n                {\n                    var matchedStep = await _flowService.MatchStepByButtonAsync(\n                        businessId,\n                        dto.ButtonText.Trim(),\n                        \"quick_reply\",\n                        campaignLog?.Campaign?.MessageTemplate ?? \"\",\n                        campaignId\n                    );\n\n                    if (matchedStep != null)\n                    {\n                        _logger.LogInformation(\"üîÅ Matched CTA Step ‚Üí {StepId}\", matchedStep.Id);\n\n                        await _flowService.ExecuteVisualFlowAsync(\n                            businessId,\n                            matchedStep.Id,\n                            trackingLogId\n                        );\n\n                        _logger.LogInformation(\"‚ö° Visual flow triggered via CTA click.\");\n                    }\n                    else\n                    {\n                        _logger.LogInformation(\"üü° No visual flow matched for this button: {Text}\", dto.ButtonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "4d185e53ba4a52cd2439e23dc136aab36f4f7469c5399dd644247fdfd5631ae9",
      "language": "csharp",
      "size": 6493,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\n\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory)\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n        }\n\n\n\n        \n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n                // ‚úÖ 1. Extract WhatsApp metadata and message\n                var msg = value.GetProperty(\"messages\")[0];\n                var contactPhone = msg.GetProperty(\"from\").GetString()!;\n                var content = msg.GetProperty(\"text\").GetProperty(\"body\").GetString();\n                var businessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString()!;\n\n                // ‚úÖ 2. Resolve business by WhatsApp number\n                var business = await db.Businesses\n                    .Include(b => b.WhatsAppSettings)\n                    .FirstOrDefaultAsync(b => b.WhatsAppSettings.WhatsAppBusinessNumber == businessNumber);\n\n                if (business == null)\n                {\n                    logger.LogWarning(\"‚ùå Business not found for WhatsApp number: {Number}\", businessNumber);\n                    return;\n                }\n\n                var businessId = business.Id;\n\n                // ‚úÖ 3. Find or create contact\n                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // ‚úÖ 4. Check chat mode (skip inbox sync if not agent)\n                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // ‚úÖ 5. Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                // ‚úÖ 6. Try to trigger automation by keyword\n                try\n                {\n                    var triggerKeyword = content.Trim().ToLower();\n                    var handled = await automationService.TryRunFlowByKeywordAsync(\n                        businessId,\n                        triggerKeyword,\n                        contact.PhoneNumber,\n                        sourceChannel: \"whatsapp\",\n                        industryTag: \"default\"\n                    );\n\n                    if (!handled)\n                    {\n                        logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n                }\n\n                // ‚úÖ 7. Only sync to inbox if chat mode is agent\n                if (isAgentMode)\n                {\n                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                    {\n                        BusinessId = businessId,\n                        ContactId = contact.Id,\n                        RecipientPhone = contact.PhoneNumber,\n                        MessageBody = messageLog.MessageContent,\n                        IsIncoming = true,\n                        Status = messageLog.Status,\n                        SentAt = messageLog.CreatedAt\n                    });\n\n                    logger.LogInformation(\"üì• Message synced to inbox for contact {Phone}\", contactPhone);\n                }\n                else\n                {\n                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "b1e65faf4d0e1fe42cb9f0ca594f5e67270ea101fb1aabf768ab89da63aba838",
      "language": "csharp",
      "size": 239,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "2ed51eba7ff737266deb3c2aa5a4276c3e6afed2ee2da7472bd02e8e695ed4b9",
      "language": "csharp",
      "size": 4153,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver; // ‚úÖ Injected resolver\n\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver) // ‚úÖ Accept resolver in constructor\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n        }\n\n        // üîÑ Extract statuses from the payload and route them to log resolver\n        public async Task ProcessAsync(JsonElement value)\n        {\n            if (!value.TryGetProperty(\"statuses\", out var statuses))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è 'statuses' field missing in webhook payload.\");\n                return;\n            }\n\n            foreach (var status in statuses.EnumerateArray())\n            {\n                var messageId = status.GetProperty(\"id\").GetString();\n                var statusText = status.GetProperty(\"status\").GetString();\n                //var timestamp = status.TryGetProperty(\"timestamp\", out var ts) ? ts.GetInt64() : 0;\n                //var timestamp = status.TryGetProperty(\"timestamp\", out var ts) ? ts.GetInt64() : 0;\n\n                long timestamp = 0;\n\n                if (status.TryGetProperty(\"timestamp\", out var ts))\n                {\n                    if (ts.ValueKind == JsonValueKind.String && long.TryParse(ts.GetString(), out var parsed))\n                    {\n                        timestamp = parsed;\n                    }\n                    else if (ts.ValueKind == JsonValueKind.Number)\n                    {\n                        timestamp = ts.GetInt64();\n                    }\n                }\n\n                var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;\n                _logger.LogDebug(\"üïì Parsed timestamp: {0} from raw type: {1}\", timestamp, ts.ValueKind);\n                // ‚úÖ Resolve the correct CampaignSendLog ID using the new resolver\n                var logId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n\n                if (logId == null)\n                {\n                    _logger.LogWarning($\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}\");\n                    continue;\n                }\n\n                // üîç Now load the row by resolved ID\n                var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId.Value);\n                if (log != null)\n                {\n                    log.SendStatus = statusText switch\n                    {\n                        \"sent\" => \"Sent\",\n                        \"delivered\" => \"Delivered\",\n                        \"read\" => \"Read\",\n                        _ => log.SendStatus\n                    };\n\n                    if (statusText == \"delivered\") log.DeliveredAt = time;\n                    if (statusText == \"read\") log.ReadAt = time;\n\n                    await _context.SaveChangesAsync();\n                    _logger.LogInformation($\"‚úÖ CampaignSendLog updated for MessageId: {messageId} ‚Üí {statusText}\");\n                }\n            }\n        }\n\n        // üîÅ Entry point from webhook dispatcher\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogWarning(\"üîç Incoming timestamp raw value: {0}\", payload.ToString());\n            var entry = payload.GetProperty(\"entry\")[0];\n            var changes = entry.GetProperty(\"changes\")[0];\n            var value = changes.GetProperty(\"value\");\n\n            await ProcessAsync(value); // ‚úÖ Unified internal call\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "a9129664eb60ff771e1f4895a51f74dd7277f7693c9a9638cab9363dc4618baa",
      "language": "csharp",
      "size": 369,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "34280daacb42fd65daf76845f254009aff42867432c235250272bb6fc6676084",
      "language": "csharp",
      "size": 1972,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "5de062949cd3197e00bf3971292ea36c2014849de597b6cc077673c464a02286",
      "language": "csharp",
      "size": 1054,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n\n        public WebhookQueueService()\n        {\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            if (!_queue.Writer.TryWrite(item))\n            {\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            return await _queue.Reader.ReadAsync(cancellationToken);\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "9b49d77f9faaa3791a6a92f988ad2269e92a283fc91898ef5e885ed90fbbd586",
      "language": "csharp",
      "size": 8135,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing static System.Net.Mime.MediaTypeNames;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Central dispatcher for WhatsApp webhook events.\n    /// Routes payloads to the appropriate processor based on payload type.\n    /// </summary>\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        private readonly IStatusWebhookProcessor _statusProcessor;\n        private readonly ITemplateWebhookProcessor _templateProcessor;\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IClickWebhookProcessor _clickProcessor;\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n        public WhatsAppWebhookDispatcher(\n            IStatusWebhookProcessor statusProcessor,\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor)\n        {\n            _statusProcessor = statusProcessor;\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n        }\n\n\n        //public async Task DispatchAsync(JsonElement payload)\n        //{\n        //    //throw new Exception(\"üß™ Simulated webhook dispatch failure for testing.\");\n        //    _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n\" + payload.ToString());\n        //    try\n        //    {\n        //        if (!payload.TryGetProperty(\"entry\", out var entries)) return;\n\n        //        foreach (var entry in entries.EnumerateArray())\n        //        {\n        //            if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n        //            foreach (var change in changes.EnumerateArray())\n        //            {\n        //                if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n        //                // üì® Status Updates\n        //                if (value.TryGetProperty(\"statuses\", out _))\n        //                {\n        //                    _logger.LogInformation(\"üì¶ Routing to Status Processor\");\n        //                    await _statusProcessor.ProcessStatusUpdateAsync(payload);\n        //                    continue;\n        //                }\n\n        //                // üßæ Template Events\n        //                if (value.TryGetProperty(\"event\", out var eventType)\n        //                    && eventType.GetString()?.StartsWith(\"template_\") == true)\n        //                {\n        //                    _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n        //                    await _templateProcessor.ProcessTemplateUpdateAsync(payload);\n        //                    continue;\n        //                }\n\n        //                // üéØ Click Events\n        //                if (value.TryGetProperty(\"messages\", out var messages)\n        //                    && messages.GetArrayLength() > 0\n        //                    && messages[0].TryGetProperty(\"type\", out var type)\n        //                    && type.GetString() == \"button\")\n        //                {\n        //                    _logger.LogInformation(\"üëâ Routing to Click Processor\");\n        //                    await _clickProcessor.ProcessClickAsync(value);\n        //                    continue;\n        //                }\n        //                // üì• Inbound text/image/audio messages from customer\n        //                if (value.TryGetProperty(\"messages\", out var messages) &&\n        //                    messages.GetArrayLength() > 0 &&\n        //                    messages[0].TryGetProperty(\"type\", out var typeProp))\n        //                {\n        //                    var type = typeProp.GetString();\n\n        //                    if (type is \"text\" or \"image\" or \"audio\")\n        //                    {\n        //                        _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n        //                        await _inboundProcessor.ProcessAsync(value);\n        //                        continue;\n        //                    }\n        //                }\n\n        //                _logger.LogWarning(\"‚ö†Ô∏è No matching event processor found.\");\n        //            }\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n        //    }\n        //}\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            //clickMessages for button clicks\n            // inboundMessages for text / image / audio\n\n            _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n\" + payload.ToString());\n\n            try\n            {\n                if (!payload.TryGetProperty(\"entry\", out var entries)) return;\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                        // üì® Status Updates\n                        if (value.TryGetProperty(\"statuses\", out _))\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Status Processor\");\n                            await _statusProcessor.ProcessStatusUpdateAsync(payload);\n                            continue;\n                        }\n\n                        // üßæ Template Events\n                        if (value.TryGetProperty(\"event\", out var eventType)\n                            && eventType.GetString()?.StartsWith(\"template_\") == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n                            await _templateProcessor.ProcessTemplateUpdateAsync(payload);\n                            continue;\n                        }\n\n                        // üéØ Click Events (button type)\n                        if (value.TryGetProperty(\"messages\", out var clickMessages)\n                            && clickMessages.GetArrayLength() > 0\n                            && clickMessages[0].TryGetProperty(\"type\", out var clickType)\n                            && clickType.GetString() == \"button\")\n                        {\n                            _logger.LogInformation(\"üëâ Routing to Click Processor\");\n                            await _clickProcessor.ProcessClickAsync(value);\n                            continue;\n                        }\n\n                        // üí¨ Inbound Messages (text/image/audio)\n                        if (value.TryGetProperty(\"messages\", out var inboundMessages)\n                            && inboundMessages.GetArrayLength() > 0\n                            && inboundMessages[0].TryGetProperty(\"type\", out var inboundType))\n                        {\n                            var type = inboundType.GetString();\n\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n                                await _inboundMessageProcessor.ProcessChatAsync(value);\n                                continue;\n                            }\n                        }\n\n                        _logger.LogWarning(\"‚ö†Ô∏è No matching event processor found.\");\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "1eab721a5c07db54368581314d45a8dfb105e5d301d1dd25be6883950deaad02",
      "language": "csharp",
      "size": 5546,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n\n        public WhatsAppWebhookService(AppDbContext context, ILogger<WhatsAppWebhookService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogInformation(\"üì¶ Processing Webhook Status:\\n\" +\n                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));\n\n            if (!payload.TryGetProperty(\"entry\", out var entries))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Payload missing 'entry' property.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                    if (!value.TryGetProperty(\"statuses\", out var statuses)) continue;\n\n                    foreach (var status in statuses.EnumerateArray())\n                    {\n                        string? messageId = status.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = status.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n                        long timestamp = status.TryGetProperty(\"timestamp\", out var tsProp) && tsProp.ValueKind == JsonValueKind.String\n                                         && long.TryParse(tsProp.GetString(), out var parsedTs)\n                                         ? parsedTs\n                                         : (tsProp.ValueKind == JsonValueKind.Number ? tsProp.GetInt64() : 0);\n\n                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))\n                        {\n                            _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or statusText in webhook payload.\");\n                            continue;\n                        }\n\n                        var log = await _context.CampaignSendLogs\n                            //.AsNoTracking()\n                            .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n                        if (log != null)\n                        {\n                            var time = DateTimeOffset.FromUnixTimeSeconds(timestamp).UtcDateTime;\n\n                            //log.SendStatus = statusText switch\n                            //{\n                            //    \"sent\" => \"Sent\",\n                            //    \"delivered\" => \"Delivered\",\n                            //    \"read\" => \"Read\",\n                            //    _ => log.SendStatus\n                            //};\n\n                            //if (statusText == \"delivered\") log.DeliveredAt = time;\n                            //if (statusText == \"read\") log.ReadAt = time;\n\n                            //await _context.SaveChangesAsync();\n                            // üîÅ Avoid redundant updates\n                            var newStatus = statusText switch\n                            {\n                                \"sent\" => \"Sent\",\n                                \"delivered\" => \"Delivered\",\n                                \"read\" => \"Read\",\n                                _ => null\n                            };\n\n                            bool isUpdated = false;\n\n                            if (!string.IsNullOrEmpty(newStatus) && log.SendStatus != newStatus)\n                            {\n                                log.SendStatus = newStatus;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"delivered\" && log.DeliveredAt == null)\n                            {\n                                log.DeliveredAt = time;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"read\" && log.ReadAt == null)\n                            {\n                                log.ReadAt = time;\n                                isUpdated = true;\n                            }\n\n                            if (isUpdated)\n                            {\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation($\"‚úÖ Log updated for MessageId: {messageId} ‚Üí {newStatus}\");\n                            }\n                            else\n                            {\n                                _logger.LogInformation($\"üîÅ Duplicate status '{statusText}' skipped for MessageId: {messageId}\");\n                            }\n\n                            _logger.LogInformation($\"‚úÖ Log updated for MessageId: {messageId} ‚Üí {statusText}\");\n                        }\n                        else\n                        {\n                            _logger.LogWarning($\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {messageId}\");\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/Controllers/WhatsAppTemplateController.cs",
      "sha256": "7cee6e94d95a99b2c7b15eb9567b21bea75fb9efd058d6c2a00fba7585616dc8",
      "language": "csharp",
      "size": 2867,
      "content": "\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing System.Net.Http.Headers;\nusing Newtonsoft.Json.Linq;\n\nnamespace xbytechat.api.Features.WhatsAppIntegration.Controllers\n{\n    [ApiController]\n    [Route(\"api/whatsapp\")]\n    public class WhatsAppTemplateController : ControllerBase\n    {\n        private readonly IConfiguration _config;\n\n        public WhatsAppTemplateController(IConfiguration config)\n        {\n            _config = config;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetTemplates()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var apiToken = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v22.0/{wabaId}/message_templates\";\n\n            using var client = new HttpClient();\n            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", apiToken);\n\n            try\n            {\n                var response = await client.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                    return StatusCode((int)response.StatusCode, new { success = false, error = json });\n\n                var root = JsonConvert.DeserializeObject<JObject>(json);\n                var templatesRaw = root[\"data\"] as JArray;\n\n                if (templatesRaw == null)\n                    return BadRequest(new { success = false, error = \"Meta API did not return data array.\" });\n\n                var templates = new List<object>();\n\n                foreach (var tpl in templatesRaw)\n                {\n                    string name = tpl[\"name\"]?.ToString() ?? \"\";\n                    string language = tpl[\"language\"]?.ToString() ?? \"en_US\";\n\n                    string bodyText = \"\";\n                    var components = tpl[\"components\"] as JArray;\n\n                    if (components != null)\n                    {\n                        foreach (var comp in components)\n                        {\n                            if (comp[\"type\"]?.ToString() == \"BODY\")\n                            {\n                                bodyText = comp[\"text\"]?.ToString() ?? \"\";\n                                break;\n                            }\n                        }\n                    }\n\n                    templates.Add(new\n                    {\n                        name,\n                        language,\n                        body = bodyText\n                    });\n                }\n\n                return Ok(new { success = true, templates });\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, new { success = false, error = ex.Message });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/DTOs/WhatsAppTemplateDto.cs",
      "sha256": "66133a62d929f35f6f56d4d6c3c9a872e14788627c9645fa41aa6eee13290993",
      "language": "csharp",
      "size": 111,
      "content": "namespace xbytechat.api.Features.WhatsAppIntegration.DTOs\n{\n    public class WhatsAppTemplateDto\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Controllers/LeadTimelineController.cs",
      "sha256": "2bf2b77897c9f322069f976352984cc8a0a0d25514e1e411e2e2393e3ccba3f0",
      "language": "csharp",
      "size": 2028,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.xbTimeline.Services;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"‚úÖ Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"üìÑ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // ‚úÖ Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // ‚úÖ Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "e6ce11c00e1130226359d24f7c9da23fe4fc68c6e725c5a449ed10a345378269",
      "language": "csharp",
      "size": 693,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // üß© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // üÜî Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // üìÇ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // ‚è∞ Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/LeadTimelineDto.cs",
      "sha256": "b4692f6cebba16abcb7dc7450172517334a4832fce8e02d3c4273da2d001f2c8",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } \n        public string ContactNumber { get; set; } \n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "de301765ab3465a422c99453aab98cf7b40ec5177358642af08c2d5ec36ead4a",
      "language": "csharp",
      "size": 1837,
      "content": "using xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // ‚úÖ Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // ‚úÖ Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // ‚úÖ CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // ‚úÖ Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Models/LeadTimeline.cs",
      "sha256": "deaadfd25e7f565dc0456a66a61612baa9aea7a7dc297feca882d2108906413f",
      "language": "csharp",
      "size": 1195,
      "content": "using xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // üÜï Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // ‚úÖ New\n        public bool IsSystemGenerated { get; set; } = false;  // ‚úÖ New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ILeadTimelineService.cs",
      "sha256": "4bff375276ef500fcbd0288211c9a8438d983b063537b2995a6fc98a8eba1148",
      "language": "csharp",
      "size": 709,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ITimelineService.cs",
      "sha256": "3e8a236b7ce0a2af07bc27014910b7fbd77a83c78e8ceebe38c99bab96d183e4",
      "language": "csharp",
      "size": 448,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public interface ITimelineService\n    {\n        // Already existing methods...\n\n        // üÜï CRM related methods\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/LeadTimelineService.cs",
      "sha256": "cf0715e549aeb3e6288ceb6cb82177dea0441d9953e64e6aca44f13ed2a19083",
      "language": "csharp",
      "size": 7579,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\n\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n       \n\n        public LeadTimelineService(AppDbContext context )\n        {\n            _context = context;\n        \n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"üìÑ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"üìÑ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üìà Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // ‚úÖ Timeline me readable text\n                    ReferenceId = dto.CampaignId, // ‚úÖ Linking to campaign record\n                    IsSystemGenerated = false,    // ‚úÖ Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // ‚úÖ Or actual user email if needed later\n                    Source = \"CampaignModule\",    // ‚úÖ Source field for clarity\n                    Category = \"Messaging\",       // ‚úÖ Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // ‚úÖ Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/TimelineService.cs",
      "sha256": "34982b110dddb7a0afcac7582aa0c8dfc2d85810317956df389aaf17bd1a0a1f",
      "language": "csharp",
      "size": 3341,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // üß© Log Note Added into Timeline\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"NoteAdded\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // ‚è∞ Log Reminder Set into Timeline\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"ReminderSet\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // üè∑Ô∏è Log Tag Applied into Timeline\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagApplied\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    }
  ]
}
